/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const PropTradingProtocol = $root.PropTradingProtocol = (() => {

    /**
     * Namespace PropTradingProtocol.
     * @exports PropTradingProtocol
     * @namespace
     */
    const PropTradingProtocol = {};

    PropTradingProtocol.ClientRequestMsg = (function() {

        /**
         * Properties of a ClientRequestMsg.
         * @memberof PropTradingProtocol
         * @interface IClientRequestMsg
         * @property {PropTradingProtocol.ILoginRequestMsg|null} [LoginReq] ClientRequestMsg LoginReq
         * @property {PropTradingProtocol.IPingMsg|null} [Ping] ClientRequestMsg Ping
         * @property {PropTradingProtocol.IInfoReqMsg|null} [InfoReq] ClientRequestMsg InfoReq
         * @property {PropTradingProtocol.IContractReqMsg|null} [ContractReq] ClientRequestMsg ContractReq
         * @property {Array.<PropTradingProtocol.IDailyPlReqMsg>|null} [DailyPls] ClientRequestMsg DailyPls
         * @property {Array.<PropTradingProtocol.IOrderMsg>|null} [Order] ClientRequestMsg Order
         * @property {PropTradingProtocol.ILogInfoMsg|null} [LogMsg] ClientRequestMsg LogMsg
         * @property {PropTradingProtocol.ISymbolLookupReqMsg|null} [SymbolLookup] ClientRequestMsg SymbolLookup
         * @property {PropTradingProtocol.ICancelFlatReqMsg|null} [CancelFlatReq] ClientRequestMsg CancelFlatReq
         * @property {PropTradingProtocol.IAccountSubscribeReqMsg|null} [AccountSubscribeReq] ClientRequestMsg AccountSubscribeReq
         * @property {PropTradingProtocol.ICancelReverseReqMsg|null} [CancelReverseReq] ClientRequestMsg CancelReverseReq
         * @property {PropTradingProtocol.ICurrencyRatesReqMsg|null} [CurrenyRatesReq] ClientRequestMsg CurrenyRatesReq
         * @property {PropTradingProtocol.IAccountTradingSymbolInfoReqMsg|null} [AccountTradingSymbolInfoReq] ClientRequestMsg AccountTradingSymbolInfoReq
         * @property {PropTradingProtocol.IAccountUserRiskRuleInfoReqMsg|null} [AccountUserRiskRuleInfoReq] ClientRequestMsg AccountUserRiskRuleInfoReq
         * @property {PropTradingProtocol.IAccountUserRiskRuleSetReqMsg|null} [AccountUserRiskRuleSetReq] ClientRequestMsg AccountUserRiskRuleSetReq
         * @property {PropTradingProtocol.IAccountDailyLockoutReqMsg|null} [AccountDailyLockoutReq] ClientRequestMsg AccountDailyLockoutReq
         * @property {PropTradingProtocol.IAccountHistoricalSessionReqMsg|null} [AccountHistoricalSessionReq] ClientRequestMsg AccountHistoricalSessionReq
         * @property {PropTradingProtocol.IContractRequestWrapperMsg|null} [ContractsReqs] ClientRequestMsg ContractsReqs
         * @property {PropTradingProtocol.IAccountTradingSymbolMultiReqMsg|null} [AccountTradingSymbolMultiReq] ClientRequestMsg AccountTradingSymbolMultiReq
         */

        /**
         * Constructs a new ClientRequestMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a ClientRequestMsg.
         * @implements IClientRequestMsg
         * @constructor
         * @param {PropTradingProtocol.IClientRequestMsg=} [properties] Properties to set
         */
        function ClientRequestMsg(properties) {
            this.DailyPls = [];
            this.Order = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientRequestMsg LoginReq.
         * @member {PropTradingProtocol.ILoginRequestMsg|null|undefined} LoginReq
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.LoginReq = null;

        /**
         * ClientRequestMsg Ping.
         * @member {PropTradingProtocol.IPingMsg|null|undefined} Ping
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.Ping = null;

        /**
         * ClientRequestMsg InfoReq.
         * @member {PropTradingProtocol.IInfoReqMsg|null|undefined} InfoReq
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.InfoReq = null;

        /**
         * ClientRequestMsg ContractReq.
         * @member {PropTradingProtocol.IContractReqMsg|null|undefined} ContractReq
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.ContractReq = null;

        /**
         * ClientRequestMsg DailyPls.
         * @member {Array.<PropTradingProtocol.IDailyPlReqMsg>} DailyPls
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.DailyPls = $util.emptyArray;

        /**
         * ClientRequestMsg Order.
         * @member {Array.<PropTradingProtocol.IOrderMsg>} Order
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.Order = $util.emptyArray;

        /**
         * ClientRequestMsg LogMsg.
         * @member {PropTradingProtocol.ILogInfoMsg|null|undefined} LogMsg
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.LogMsg = null;

        /**
         * ClientRequestMsg SymbolLookup.
         * @member {PropTradingProtocol.ISymbolLookupReqMsg|null|undefined} SymbolLookup
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.SymbolLookup = null;

        /**
         * ClientRequestMsg CancelFlatReq.
         * @member {PropTradingProtocol.ICancelFlatReqMsg|null|undefined} CancelFlatReq
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.CancelFlatReq = null;

        /**
         * ClientRequestMsg AccountSubscribeReq.
         * @member {PropTradingProtocol.IAccountSubscribeReqMsg|null|undefined} AccountSubscribeReq
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.AccountSubscribeReq = null;

        /**
         * ClientRequestMsg CancelReverseReq.
         * @member {PropTradingProtocol.ICancelReverseReqMsg|null|undefined} CancelReverseReq
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.CancelReverseReq = null;

        /**
         * ClientRequestMsg CurrenyRatesReq.
         * @member {PropTradingProtocol.ICurrencyRatesReqMsg|null|undefined} CurrenyRatesReq
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.CurrenyRatesReq = null;

        /**
         * ClientRequestMsg AccountTradingSymbolInfoReq.
         * @member {PropTradingProtocol.IAccountTradingSymbolInfoReqMsg|null|undefined} AccountTradingSymbolInfoReq
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.AccountTradingSymbolInfoReq = null;

        /**
         * ClientRequestMsg AccountUserRiskRuleInfoReq.
         * @member {PropTradingProtocol.IAccountUserRiskRuleInfoReqMsg|null|undefined} AccountUserRiskRuleInfoReq
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.AccountUserRiskRuleInfoReq = null;

        /**
         * ClientRequestMsg AccountUserRiskRuleSetReq.
         * @member {PropTradingProtocol.IAccountUserRiskRuleSetReqMsg|null|undefined} AccountUserRiskRuleSetReq
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.AccountUserRiskRuleSetReq = null;

        /**
         * ClientRequestMsg AccountDailyLockoutReq.
         * @member {PropTradingProtocol.IAccountDailyLockoutReqMsg|null|undefined} AccountDailyLockoutReq
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.AccountDailyLockoutReq = null;

        /**
         * ClientRequestMsg AccountHistoricalSessionReq.
         * @member {PropTradingProtocol.IAccountHistoricalSessionReqMsg|null|undefined} AccountHistoricalSessionReq
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.AccountHistoricalSessionReq = null;

        /**
         * ClientRequestMsg ContractsReqs.
         * @member {PropTradingProtocol.IContractRequestWrapperMsg|null|undefined} ContractsReqs
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.ContractsReqs = null;

        /**
         * ClientRequestMsg AccountTradingSymbolMultiReq.
         * @member {PropTradingProtocol.IAccountTradingSymbolMultiReqMsg|null|undefined} AccountTradingSymbolMultiReq
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         */
        ClientRequestMsg.prototype.AccountTradingSymbolMultiReq = null;

        /**
         * Creates a new ClientRequestMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @static
         * @param {PropTradingProtocol.IClientRequestMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.ClientRequestMsg} ClientRequestMsg instance
         */
        ClientRequestMsg.create = function create(properties) {
            return new ClientRequestMsg(properties);
        };

        /**
         * Encodes the specified ClientRequestMsg message. Does not implicitly {@link PropTradingProtocol.ClientRequestMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @static
         * @param {PropTradingProtocol.IClientRequestMsg} message ClientRequestMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRequestMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.LoginReq != null && Object.hasOwnProperty.call(message, "LoginReq"))
                $root.PropTradingProtocol.LoginRequestMsg.encode(message.LoginReq, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.Ping != null && Object.hasOwnProperty.call(message, "Ping"))
                $root.PropTradingProtocol.PingMsg.encode(message.Ping, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.InfoReq != null && Object.hasOwnProperty.call(message, "InfoReq"))
                $root.PropTradingProtocol.InfoReqMsg.encode(message.InfoReq, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.ContractReq != null && Object.hasOwnProperty.call(message, "ContractReq"))
                $root.PropTradingProtocol.ContractReqMsg.encode(message.ContractReq, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.DailyPls != null && message.DailyPls.length)
                for (let i = 0; i < message.DailyPls.length; ++i)
                    $root.PropTradingProtocol.DailyPlReqMsg.encode(message.DailyPls[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.Order != null && message.Order.length)
                for (let i = 0; i < message.Order.length; ++i)
                    $root.PropTradingProtocol.OrderMsg.encode(message.Order[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.LogMsg != null && Object.hasOwnProperty.call(message, "LogMsg"))
                $root.PropTradingProtocol.LogInfoMsg.encode(message.LogMsg, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.SymbolLookup != null && Object.hasOwnProperty.call(message, "SymbolLookup"))
                $root.PropTradingProtocol.SymbolLookupReqMsg.encode(message.SymbolLookup, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.CancelFlatReq != null && Object.hasOwnProperty.call(message, "CancelFlatReq"))
                $root.PropTradingProtocol.CancelFlatReqMsg.encode(message.CancelFlatReq, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.AccountSubscribeReq != null && Object.hasOwnProperty.call(message, "AccountSubscribeReq"))
                $root.PropTradingProtocol.AccountSubscribeReqMsg.encode(message.AccountSubscribeReq, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.CancelReverseReq != null && Object.hasOwnProperty.call(message, "CancelReverseReq"))
                $root.PropTradingProtocol.CancelReverseReqMsg.encode(message.CancelReverseReq, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.CurrenyRatesReq != null && Object.hasOwnProperty.call(message, "CurrenyRatesReq"))
                $root.PropTradingProtocol.CurrencyRatesReqMsg.encode(message.CurrenyRatesReq, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.AccountTradingSymbolInfoReq != null && Object.hasOwnProperty.call(message, "AccountTradingSymbolInfoReq"))
                $root.PropTradingProtocol.AccountTradingSymbolInfoReqMsg.encode(message.AccountTradingSymbolInfoReq, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.AccountUserRiskRuleInfoReq != null && Object.hasOwnProperty.call(message, "AccountUserRiskRuleInfoReq"))
                $root.PropTradingProtocol.AccountUserRiskRuleInfoReqMsg.encode(message.AccountUserRiskRuleInfoReq, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.AccountUserRiskRuleSetReq != null && Object.hasOwnProperty.call(message, "AccountUserRiskRuleSetReq"))
                $root.PropTradingProtocol.AccountUserRiskRuleSetReqMsg.encode(message.AccountUserRiskRuleSetReq, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.AccountDailyLockoutReq != null && Object.hasOwnProperty.call(message, "AccountDailyLockoutReq"))
                $root.PropTradingProtocol.AccountDailyLockoutReqMsg.encode(message.AccountDailyLockoutReq, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.AccountHistoricalSessionReq != null && Object.hasOwnProperty.call(message, "AccountHistoricalSessionReq"))
                $root.PropTradingProtocol.AccountHistoricalSessionReqMsg.encode(message.AccountHistoricalSessionReq, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.ContractsReqs != null && Object.hasOwnProperty.call(message, "ContractsReqs"))
                $root.PropTradingProtocol.ContractRequestWrapperMsg.encode(message.ContractsReqs, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.AccountTradingSymbolMultiReq != null && Object.hasOwnProperty.call(message, "AccountTradingSymbolMultiReq"))
                $root.PropTradingProtocol.AccountTradingSymbolMultiReqMsg.encode(message.AccountTradingSymbolMultiReq, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClientRequestMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.ClientRequestMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @static
         * @param {PropTradingProtocol.IClientRequestMsg} message ClientRequestMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRequestMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientRequestMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.ClientRequestMsg} ClientRequestMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRequestMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.ClientRequestMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.LoginReq = $root.PropTradingProtocol.LoginRequestMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.Ping = $root.PropTradingProtocol.PingMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.InfoReq = $root.PropTradingProtocol.InfoReqMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.ContractReq = $root.PropTradingProtocol.ContractReqMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        if (!(message.DailyPls && message.DailyPls.length))
                            message.DailyPls = [];
                        message.DailyPls.push($root.PropTradingProtocol.DailyPlReqMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        if (!(message.Order && message.Order.length))
                            message.Order = [];
                        message.Order.push($root.PropTradingProtocol.OrderMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        message.LogMsg = $root.PropTradingProtocol.LogInfoMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.SymbolLookup = $root.PropTradingProtocol.SymbolLookupReqMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.CancelFlatReq = $root.PropTradingProtocol.CancelFlatReqMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.AccountSubscribeReq = $root.PropTradingProtocol.AccountSubscribeReqMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.CancelReverseReq = $root.PropTradingProtocol.CancelReverseReqMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.CurrenyRatesReq = $root.PropTradingProtocol.CurrencyRatesReqMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.AccountTradingSymbolInfoReq = $root.PropTradingProtocol.AccountTradingSymbolInfoReqMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.AccountUserRiskRuleInfoReq = $root.PropTradingProtocol.AccountUserRiskRuleInfoReqMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.AccountUserRiskRuleSetReq = $root.PropTradingProtocol.AccountUserRiskRuleSetReqMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 16: {
                        message.AccountDailyLockoutReq = $root.PropTradingProtocol.AccountDailyLockoutReqMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message.AccountHistoricalSessionReq = $root.PropTradingProtocol.AccountHistoricalSessionReqMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 18: {
                        message.ContractsReqs = $root.PropTradingProtocol.ContractRequestWrapperMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 19: {
                        message.AccountTradingSymbolMultiReq = $root.PropTradingProtocol.AccountTradingSymbolMultiReqMsg.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientRequestMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.ClientRequestMsg} ClientRequestMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRequestMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientRequestMsg message.
         * @function verify
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientRequestMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.LoginReq != null && message.hasOwnProperty("LoginReq")) {
                let error = $root.PropTradingProtocol.LoginRequestMsg.verify(message.LoginReq);
                if (error)
                    return "LoginReq." + error;
            }
            if (message.Ping != null && message.hasOwnProperty("Ping")) {
                let error = $root.PropTradingProtocol.PingMsg.verify(message.Ping);
                if (error)
                    return "Ping." + error;
            }
            if (message.InfoReq != null && message.hasOwnProperty("InfoReq")) {
                let error = $root.PropTradingProtocol.InfoReqMsg.verify(message.InfoReq);
                if (error)
                    return "InfoReq." + error;
            }
            if (message.ContractReq != null && message.hasOwnProperty("ContractReq")) {
                let error = $root.PropTradingProtocol.ContractReqMsg.verify(message.ContractReq);
                if (error)
                    return "ContractReq." + error;
            }
            if (message.DailyPls != null && message.hasOwnProperty("DailyPls")) {
                if (!Array.isArray(message.DailyPls))
                    return "DailyPls: array expected";
                for (let i = 0; i < message.DailyPls.length; ++i) {
                    let error = $root.PropTradingProtocol.DailyPlReqMsg.verify(message.DailyPls[i]);
                    if (error)
                        return "DailyPls." + error;
                }
            }
            if (message.Order != null && message.hasOwnProperty("Order")) {
                if (!Array.isArray(message.Order))
                    return "Order: array expected";
                for (let i = 0; i < message.Order.length; ++i) {
                    let error = $root.PropTradingProtocol.OrderMsg.verify(message.Order[i]);
                    if (error)
                        return "Order." + error;
                }
            }
            if (message.LogMsg != null && message.hasOwnProperty("LogMsg")) {
                let error = $root.PropTradingProtocol.LogInfoMsg.verify(message.LogMsg);
                if (error)
                    return "LogMsg." + error;
            }
            if (message.SymbolLookup != null && message.hasOwnProperty("SymbolLookup")) {
                let error = $root.PropTradingProtocol.SymbolLookupReqMsg.verify(message.SymbolLookup);
                if (error)
                    return "SymbolLookup." + error;
            }
            if (message.CancelFlatReq != null && message.hasOwnProperty("CancelFlatReq")) {
                let error = $root.PropTradingProtocol.CancelFlatReqMsg.verify(message.CancelFlatReq);
                if (error)
                    return "CancelFlatReq." + error;
            }
            if (message.AccountSubscribeReq != null && message.hasOwnProperty("AccountSubscribeReq")) {
                let error = $root.PropTradingProtocol.AccountSubscribeReqMsg.verify(message.AccountSubscribeReq);
                if (error)
                    return "AccountSubscribeReq." + error;
            }
            if (message.CancelReverseReq != null && message.hasOwnProperty("CancelReverseReq")) {
                let error = $root.PropTradingProtocol.CancelReverseReqMsg.verify(message.CancelReverseReq);
                if (error)
                    return "CancelReverseReq." + error;
            }
            if (message.CurrenyRatesReq != null && message.hasOwnProperty("CurrenyRatesReq")) {
                let error = $root.PropTradingProtocol.CurrencyRatesReqMsg.verify(message.CurrenyRatesReq);
                if (error)
                    return "CurrenyRatesReq." + error;
            }
            if (message.AccountTradingSymbolInfoReq != null && message.hasOwnProperty("AccountTradingSymbolInfoReq")) {
                let error = $root.PropTradingProtocol.AccountTradingSymbolInfoReqMsg.verify(message.AccountTradingSymbolInfoReq);
                if (error)
                    return "AccountTradingSymbolInfoReq." + error;
            }
            if (message.AccountUserRiskRuleInfoReq != null && message.hasOwnProperty("AccountUserRiskRuleInfoReq")) {
                let error = $root.PropTradingProtocol.AccountUserRiskRuleInfoReqMsg.verify(message.AccountUserRiskRuleInfoReq);
                if (error)
                    return "AccountUserRiskRuleInfoReq." + error;
            }
            if (message.AccountUserRiskRuleSetReq != null && message.hasOwnProperty("AccountUserRiskRuleSetReq")) {
                let error = $root.PropTradingProtocol.AccountUserRiskRuleSetReqMsg.verify(message.AccountUserRiskRuleSetReq);
                if (error)
                    return "AccountUserRiskRuleSetReq." + error;
            }
            if (message.AccountDailyLockoutReq != null && message.hasOwnProperty("AccountDailyLockoutReq")) {
                let error = $root.PropTradingProtocol.AccountDailyLockoutReqMsg.verify(message.AccountDailyLockoutReq);
                if (error)
                    return "AccountDailyLockoutReq." + error;
            }
            if (message.AccountHistoricalSessionReq != null && message.hasOwnProperty("AccountHistoricalSessionReq")) {
                let error = $root.PropTradingProtocol.AccountHistoricalSessionReqMsg.verify(message.AccountHistoricalSessionReq);
                if (error)
                    return "AccountHistoricalSessionReq." + error;
            }
            if (message.ContractsReqs != null && message.hasOwnProperty("ContractsReqs")) {
                let error = $root.PropTradingProtocol.ContractRequestWrapperMsg.verify(message.ContractsReqs);
                if (error)
                    return "ContractsReqs." + error;
            }
            if (message.AccountTradingSymbolMultiReq != null && message.hasOwnProperty("AccountTradingSymbolMultiReq")) {
                let error = $root.PropTradingProtocol.AccountTradingSymbolMultiReqMsg.verify(message.AccountTradingSymbolMultiReq);
                if (error)
                    return "AccountTradingSymbolMultiReq." + error;
            }
            return null;
        };

        /**
         * Creates a ClientRequestMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.ClientRequestMsg} ClientRequestMsg
         */
        ClientRequestMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.ClientRequestMsg)
                return object;
            let message = new $root.PropTradingProtocol.ClientRequestMsg();
            if (object.LoginReq != null) {
                if (typeof object.LoginReq !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.LoginReq: object expected");
                message.LoginReq = $root.PropTradingProtocol.LoginRequestMsg.fromObject(object.LoginReq);
            }
            if (object.Ping != null) {
                if (typeof object.Ping !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.Ping: object expected");
                message.Ping = $root.PropTradingProtocol.PingMsg.fromObject(object.Ping);
            }
            if (object.InfoReq != null) {
                if (typeof object.InfoReq !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.InfoReq: object expected");
                message.InfoReq = $root.PropTradingProtocol.InfoReqMsg.fromObject(object.InfoReq);
            }
            if (object.ContractReq != null) {
                if (typeof object.ContractReq !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.ContractReq: object expected");
                message.ContractReq = $root.PropTradingProtocol.ContractReqMsg.fromObject(object.ContractReq);
            }
            if (object.DailyPls) {
                if (!Array.isArray(object.DailyPls))
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.DailyPls: array expected");
                message.DailyPls = [];
                for (let i = 0; i < object.DailyPls.length; ++i) {
                    if (typeof object.DailyPls[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ClientRequestMsg.DailyPls: object expected");
                    message.DailyPls[i] = $root.PropTradingProtocol.DailyPlReqMsg.fromObject(object.DailyPls[i]);
                }
            }
            if (object.Order) {
                if (!Array.isArray(object.Order))
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.Order: array expected");
                message.Order = [];
                for (let i = 0; i < object.Order.length; ++i) {
                    if (typeof object.Order[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ClientRequestMsg.Order: object expected");
                    message.Order[i] = $root.PropTradingProtocol.OrderMsg.fromObject(object.Order[i]);
                }
            }
            if (object.LogMsg != null) {
                if (typeof object.LogMsg !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.LogMsg: object expected");
                message.LogMsg = $root.PropTradingProtocol.LogInfoMsg.fromObject(object.LogMsg);
            }
            if (object.SymbolLookup != null) {
                if (typeof object.SymbolLookup !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.SymbolLookup: object expected");
                message.SymbolLookup = $root.PropTradingProtocol.SymbolLookupReqMsg.fromObject(object.SymbolLookup);
            }
            if (object.CancelFlatReq != null) {
                if (typeof object.CancelFlatReq !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.CancelFlatReq: object expected");
                message.CancelFlatReq = $root.PropTradingProtocol.CancelFlatReqMsg.fromObject(object.CancelFlatReq);
            }
            if (object.AccountSubscribeReq != null) {
                if (typeof object.AccountSubscribeReq !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.AccountSubscribeReq: object expected");
                message.AccountSubscribeReq = $root.PropTradingProtocol.AccountSubscribeReqMsg.fromObject(object.AccountSubscribeReq);
            }
            if (object.CancelReverseReq != null) {
                if (typeof object.CancelReverseReq !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.CancelReverseReq: object expected");
                message.CancelReverseReq = $root.PropTradingProtocol.CancelReverseReqMsg.fromObject(object.CancelReverseReq);
            }
            if (object.CurrenyRatesReq != null) {
                if (typeof object.CurrenyRatesReq !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.CurrenyRatesReq: object expected");
                message.CurrenyRatesReq = $root.PropTradingProtocol.CurrencyRatesReqMsg.fromObject(object.CurrenyRatesReq);
            }
            if (object.AccountTradingSymbolInfoReq != null) {
                if (typeof object.AccountTradingSymbolInfoReq !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.AccountTradingSymbolInfoReq: object expected");
                message.AccountTradingSymbolInfoReq = $root.PropTradingProtocol.AccountTradingSymbolInfoReqMsg.fromObject(object.AccountTradingSymbolInfoReq);
            }
            if (object.AccountUserRiskRuleInfoReq != null) {
                if (typeof object.AccountUserRiskRuleInfoReq !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.AccountUserRiskRuleInfoReq: object expected");
                message.AccountUserRiskRuleInfoReq = $root.PropTradingProtocol.AccountUserRiskRuleInfoReqMsg.fromObject(object.AccountUserRiskRuleInfoReq);
            }
            if (object.AccountUserRiskRuleSetReq != null) {
                if (typeof object.AccountUserRiskRuleSetReq !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.AccountUserRiskRuleSetReq: object expected");
                message.AccountUserRiskRuleSetReq = $root.PropTradingProtocol.AccountUserRiskRuleSetReqMsg.fromObject(object.AccountUserRiskRuleSetReq);
            }
            if (object.AccountDailyLockoutReq != null) {
                if (typeof object.AccountDailyLockoutReq !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.AccountDailyLockoutReq: object expected");
                message.AccountDailyLockoutReq = $root.PropTradingProtocol.AccountDailyLockoutReqMsg.fromObject(object.AccountDailyLockoutReq);
            }
            if (object.AccountHistoricalSessionReq != null) {
                if (typeof object.AccountHistoricalSessionReq !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.AccountHistoricalSessionReq: object expected");
                message.AccountHistoricalSessionReq = $root.PropTradingProtocol.AccountHistoricalSessionReqMsg.fromObject(object.AccountHistoricalSessionReq);
            }
            if (object.ContractsReqs != null) {
                if (typeof object.ContractsReqs !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.ContractsReqs: object expected");
                message.ContractsReqs = $root.PropTradingProtocol.ContractRequestWrapperMsg.fromObject(object.ContractsReqs);
            }
            if (object.AccountTradingSymbolMultiReq != null) {
                if (typeof object.AccountTradingSymbolMultiReq !== "object")
                    throw TypeError(".PropTradingProtocol.ClientRequestMsg.AccountTradingSymbolMultiReq: object expected");
                message.AccountTradingSymbolMultiReq = $root.PropTradingProtocol.AccountTradingSymbolMultiReqMsg.fromObject(object.AccountTradingSymbolMultiReq);
            }
            return message;
        };

        /**
         * Creates a plain object from a ClientRequestMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @static
         * @param {PropTradingProtocol.ClientRequestMsg} message ClientRequestMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientRequestMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.DailyPls = [];
                object.Order = [];
            }
            if (options.defaults) {
                object.LoginReq = null;
                object.Ping = null;
                object.InfoReq = null;
                object.ContractReq = null;
                object.LogMsg = null;
                object.SymbolLookup = null;
                object.CancelFlatReq = null;
                object.AccountSubscribeReq = null;
                object.CancelReverseReq = null;
                object.CurrenyRatesReq = null;
                object.AccountTradingSymbolInfoReq = null;
                object.AccountUserRiskRuleInfoReq = null;
                object.AccountUserRiskRuleSetReq = null;
                object.AccountDailyLockoutReq = null;
                object.AccountHistoricalSessionReq = null;
                object.ContractsReqs = null;
                object.AccountTradingSymbolMultiReq = null;
            }
            if (message.LoginReq != null && message.hasOwnProperty("LoginReq"))
                object.LoginReq = $root.PropTradingProtocol.LoginRequestMsg.toObject(message.LoginReq, options);
            if (message.Ping != null && message.hasOwnProperty("Ping"))
                object.Ping = $root.PropTradingProtocol.PingMsg.toObject(message.Ping, options);
            if (message.InfoReq != null && message.hasOwnProperty("InfoReq"))
                object.InfoReq = $root.PropTradingProtocol.InfoReqMsg.toObject(message.InfoReq, options);
            if (message.ContractReq != null && message.hasOwnProperty("ContractReq"))
                object.ContractReq = $root.PropTradingProtocol.ContractReqMsg.toObject(message.ContractReq, options);
            if (message.DailyPls && message.DailyPls.length) {
                object.DailyPls = [];
                for (let j = 0; j < message.DailyPls.length; ++j)
                    object.DailyPls[j] = $root.PropTradingProtocol.DailyPlReqMsg.toObject(message.DailyPls[j], options);
            }
            if (message.Order && message.Order.length) {
                object.Order = [];
                for (let j = 0; j < message.Order.length; ++j)
                    object.Order[j] = $root.PropTradingProtocol.OrderMsg.toObject(message.Order[j], options);
            }
            if (message.LogMsg != null && message.hasOwnProperty("LogMsg"))
                object.LogMsg = $root.PropTradingProtocol.LogInfoMsg.toObject(message.LogMsg, options);
            if (message.SymbolLookup != null && message.hasOwnProperty("SymbolLookup"))
                object.SymbolLookup = $root.PropTradingProtocol.SymbolLookupReqMsg.toObject(message.SymbolLookup, options);
            if (message.CancelFlatReq != null && message.hasOwnProperty("CancelFlatReq"))
                object.CancelFlatReq = $root.PropTradingProtocol.CancelFlatReqMsg.toObject(message.CancelFlatReq, options);
            if (message.AccountSubscribeReq != null && message.hasOwnProperty("AccountSubscribeReq"))
                object.AccountSubscribeReq = $root.PropTradingProtocol.AccountSubscribeReqMsg.toObject(message.AccountSubscribeReq, options);
            if (message.CancelReverseReq != null && message.hasOwnProperty("CancelReverseReq"))
                object.CancelReverseReq = $root.PropTradingProtocol.CancelReverseReqMsg.toObject(message.CancelReverseReq, options);
            if (message.CurrenyRatesReq != null && message.hasOwnProperty("CurrenyRatesReq"))
                object.CurrenyRatesReq = $root.PropTradingProtocol.CurrencyRatesReqMsg.toObject(message.CurrenyRatesReq, options);
            if (message.AccountTradingSymbolInfoReq != null && message.hasOwnProperty("AccountTradingSymbolInfoReq"))
                object.AccountTradingSymbolInfoReq = $root.PropTradingProtocol.AccountTradingSymbolInfoReqMsg.toObject(message.AccountTradingSymbolInfoReq, options);
            if (message.AccountUserRiskRuleInfoReq != null && message.hasOwnProperty("AccountUserRiskRuleInfoReq"))
                object.AccountUserRiskRuleInfoReq = $root.PropTradingProtocol.AccountUserRiskRuleInfoReqMsg.toObject(message.AccountUserRiskRuleInfoReq, options);
            if (message.AccountUserRiskRuleSetReq != null && message.hasOwnProperty("AccountUserRiskRuleSetReq"))
                object.AccountUserRiskRuleSetReq = $root.PropTradingProtocol.AccountUserRiskRuleSetReqMsg.toObject(message.AccountUserRiskRuleSetReq, options);
            if (message.AccountDailyLockoutReq != null && message.hasOwnProperty("AccountDailyLockoutReq"))
                object.AccountDailyLockoutReq = $root.PropTradingProtocol.AccountDailyLockoutReqMsg.toObject(message.AccountDailyLockoutReq, options);
            if (message.AccountHistoricalSessionReq != null && message.hasOwnProperty("AccountHistoricalSessionReq"))
                object.AccountHistoricalSessionReq = $root.PropTradingProtocol.AccountHistoricalSessionReqMsg.toObject(message.AccountHistoricalSessionReq, options);
            if (message.ContractsReqs != null && message.hasOwnProperty("ContractsReqs"))
                object.ContractsReqs = $root.PropTradingProtocol.ContractRequestWrapperMsg.toObject(message.ContractsReqs, options);
            if (message.AccountTradingSymbolMultiReq != null && message.hasOwnProperty("AccountTradingSymbolMultiReq"))
                object.AccountTradingSymbolMultiReq = $root.PropTradingProtocol.AccountTradingSymbolMultiReqMsg.toObject(message.AccountTradingSymbolMultiReq, options);
            return object;
        };

        /**
         * Converts this ClientRequestMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientRequestMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientRequestMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.ClientRequestMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientRequestMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.ClientRequestMsg";
        };

        return ClientRequestMsg;
    })();

    PropTradingProtocol.ServerResponseMsg = (function() {

        /**
         * Properties of a ServerResponseMsg.
         * @memberof PropTradingProtocol
         * @interface IServerResponseMsg
         * @property {PropTradingProtocol.ILoginResponseMsg|null} [LoginMsg] ServerResponseMsg LoginMsg
         * @property {PropTradingProtocol.IPongMsg|null} [Pong] ServerResponseMsg Pong
         * @property {PropTradingProtocol.IInfoRespMsg|null} [InfoMsg] ServerResponseMsg InfoMsg
         * @property {Array.<PropTradingProtocol.IBalanceMsg>|null} [BalanceInfo] ServerResponseMsg BalanceInfo
         * @property {PropTradingProtocol.IContractRespMsg|null} [ContractMsg] ServerResponseMsg ContractMsg
         * @property {Array.<PropTradingProtocol.IDailyPlRespMsg>|null} [DailyPls] ServerResponseMsg DailyPls
         * @property {Array.<PropTradingProtocol.IOrderInfoMsg>|null} [OrderInfo] ServerResponseMsg OrderInfo
         * @property {PropTradingProtocol.ILoggedOffMsg|null} [LoggedOff] ServerResponseMsg LoggedOff
         * @property {PropTradingProtocol.ILogInfoMsg|null} [LogMsg] ServerResponseMsg LogMsg
         * @property {PropTradingProtocol.ISymbolLookupRespMsg|null} [SymbolLookup] ServerResponseMsg SymbolLookup
         * @property {Array.<PropTradingProtocol.IPositionInfoMsg>|null} [PositionInfo] ServerResponseMsg PositionInfo
         * @property {PropTradingProtocol.ICancelFlatRespMsg|null} [CancelFlatMsg] ServerResponseMsg CancelFlatMsg
         * @property {Array.<PropTradingProtocol.IBracketInfoMsg>|null} [BracketInfo] ServerResponseMsg BracketInfo
         * @property {PropTradingProtocol.IBracketInsertReportMsg|null} [BracketStrategyInsertReport] ServerResponseMsg BracketStrategyInsertReport
         * @property {PropTradingProtocol.IAccountSubscribeRespMsg|null} [AccountSubscribeResp] ServerResponseMsg AccountSubscribeResp
         * @property {Array.<PropTradingProtocol.IAccountStatusUpdateMsg>|null} [AccountStatusUpdates] ServerResponseMsg AccountStatusUpdates
         * @property {PropTradingProtocol.IOcoGroupReportMsg|null} [OcoGroupReport] ServerResponseMsg OcoGroupReport
         * @property {Array.<PropTradingProtocol.IFillReportMsg>|null} [FillReports] ServerResponseMsg FillReports
         * @property {Array.<PropTradingProtocol.ITradeReportMsg>|null} [TradeReports] ServerResponseMsg TradeReports
         * @property {Array.<PropTradingProtocol.IFillTradeReportMsg>|null} [FillTradeReports] ServerResponseMsg FillTradeReports
         * @property {PropTradingProtocol.ICancelReverseRespMsg|null} [CancelReverseMsg] ServerResponseMsg CancelReverseMsg
         * @property {Array.<PropTradingProtocol.IUserSessionLogMsg>|null} [UserSessionLogs] ServerResponseMsg UserSessionLogs
         * @property {Array.<PropTradingProtocol.IAccountTradingSymbolInfoMsg>|null} [AccountTradingSymbolInfoUpdate] ServerResponseMsg AccountTradingSymbolInfoUpdate
         * @property {Array.<PropTradingProtocol.ICurrencyRateInfoMsg>|null} [CurrencyRates] ServerResponseMsg CurrencyRates
         * @property {PropTradingProtocol.IAccountTradingSymbolInfoRespMsg|null} [AccountTradingSymbolInfoResp] ServerResponseMsg AccountTradingSymbolInfoResp
         * @property {PropTradingProtocol.IAccountUserRiskRuleInfoRespMsg|null} [AccountUserRiskRuleInfoResp] ServerResponseMsg AccountUserRiskRuleInfoResp
         * @property {PropTradingProtocol.IAccountUserRiskRuleSetRespMsg|null} [AccountUserRiskRuleSetResp] ServerResponseMsg AccountUserRiskRuleSetResp
         * @property {PropTradingProtocol.IAccountDailyLockoutRespMsg|null} [AccountDailyLockoutResp] ServerResponseMsg AccountDailyLockoutResp
         * @property {PropTradingProtocol.IAccountHistoricalSessionRespMsg|null} [AccountHistoricalSessionResp] ServerResponseMsg AccountHistoricalSessionResp
         * @property {PropTradingProtocol.IContractResponseWrapperMsg|null} [ContractsResps] ServerResponseMsg ContractsResps
         * @property {PropTradingProtocol.IAccountTradingSymbolMultiRespMsg|null} [AccountTradingSymbolMultiResp] ServerResponseMsg AccountTradingSymbolMultiResp
         */

        /**
         * Constructs a new ServerResponseMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a ServerResponseMsg.
         * @implements IServerResponseMsg
         * @constructor
         * @param {PropTradingProtocol.IServerResponseMsg=} [properties] Properties to set
         */
        function ServerResponseMsg(properties) {
            this.BalanceInfo = [];
            this.DailyPls = [];
            this.OrderInfo = [];
            this.PositionInfo = [];
            this.BracketInfo = [];
            this.AccountStatusUpdates = [];
            this.FillReports = [];
            this.TradeReports = [];
            this.FillTradeReports = [];
            this.UserSessionLogs = [];
            this.AccountTradingSymbolInfoUpdate = [];
            this.CurrencyRates = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerResponseMsg LoginMsg.
         * @member {PropTradingProtocol.ILoginResponseMsg|null|undefined} LoginMsg
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.LoginMsg = null;

        /**
         * ServerResponseMsg Pong.
         * @member {PropTradingProtocol.IPongMsg|null|undefined} Pong
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.Pong = null;

        /**
         * ServerResponseMsg InfoMsg.
         * @member {PropTradingProtocol.IInfoRespMsg|null|undefined} InfoMsg
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.InfoMsg = null;

        /**
         * ServerResponseMsg BalanceInfo.
         * @member {Array.<PropTradingProtocol.IBalanceMsg>} BalanceInfo
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.BalanceInfo = $util.emptyArray;

        /**
         * ServerResponseMsg ContractMsg.
         * @member {PropTradingProtocol.IContractRespMsg|null|undefined} ContractMsg
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.ContractMsg = null;

        /**
         * ServerResponseMsg DailyPls.
         * @member {Array.<PropTradingProtocol.IDailyPlRespMsg>} DailyPls
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.DailyPls = $util.emptyArray;

        /**
         * ServerResponseMsg OrderInfo.
         * @member {Array.<PropTradingProtocol.IOrderInfoMsg>} OrderInfo
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.OrderInfo = $util.emptyArray;

        /**
         * ServerResponseMsg LoggedOff.
         * @member {PropTradingProtocol.ILoggedOffMsg|null|undefined} LoggedOff
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.LoggedOff = null;

        /**
         * ServerResponseMsg LogMsg.
         * @member {PropTradingProtocol.ILogInfoMsg|null|undefined} LogMsg
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.LogMsg = null;

        /**
         * ServerResponseMsg SymbolLookup.
         * @member {PropTradingProtocol.ISymbolLookupRespMsg|null|undefined} SymbolLookup
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.SymbolLookup = null;

        /**
         * ServerResponseMsg PositionInfo.
         * @member {Array.<PropTradingProtocol.IPositionInfoMsg>} PositionInfo
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.PositionInfo = $util.emptyArray;

        /**
         * ServerResponseMsg CancelFlatMsg.
         * @member {PropTradingProtocol.ICancelFlatRespMsg|null|undefined} CancelFlatMsg
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.CancelFlatMsg = null;

        /**
         * ServerResponseMsg BracketInfo.
         * @member {Array.<PropTradingProtocol.IBracketInfoMsg>} BracketInfo
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.BracketInfo = $util.emptyArray;

        /**
         * ServerResponseMsg BracketStrategyInsertReport.
         * @member {PropTradingProtocol.IBracketInsertReportMsg|null|undefined} BracketStrategyInsertReport
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.BracketStrategyInsertReport = null;

        /**
         * ServerResponseMsg AccountSubscribeResp.
         * @member {PropTradingProtocol.IAccountSubscribeRespMsg|null|undefined} AccountSubscribeResp
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.AccountSubscribeResp = null;

        /**
         * ServerResponseMsg AccountStatusUpdates.
         * @member {Array.<PropTradingProtocol.IAccountStatusUpdateMsg>} AccountStatusUpdates
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.AccountStatusUpdates = $util.emptyArray;

        /**
         * ServerResponseMsg OcoGroupReport.
         * @member {PropTradingProtocol.IOcoGroupReportMsg|null|undefined} OcoGroupReport
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.OcoGroupReport = null;

        /**
         * ServerResponseMsg FillReports.
         * @member {Array.<PropTradingProtocol.IFillReportMsg>} FillReports
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.FillReports = $util.emptyArray;

        /**
         * ServerResponseMsg TradeReports.
         * @member {Array.<PropTradingProtocol.ITradeReportMsg>} TradeReports
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.TradeReports = $util.emptyArray;

        /**
         * ServerResponseMsg FillTradeReports.
         * @member {Array.<PropTradingProtocol.IFillTradeReportMsg>} FillTradeReports
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.FillTradeReports = $util.emptyArray;

        /**
         * ServerResponseMsg CancelReverseMsg.
         * @member {PropTradingProtocol.ICancelReverseRespMsg|null|undefined} CancelReverseMsg
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.CancelReverseMsg = null;

        /**
         * ServerResponseMsg UserSessionLogs.
         * @member {Array.<PropTradingProtocol.IUserSessionLogMsg>} UserSessionLogs
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.UserSessionLogs = $util.emptyArray;

        /**
         * ServerResponseMsg AccountTradingSymbolInfoUpdate.
         * @member {Array.<PropTradingProtocol.IAccountTradingSymbolInfoMsg>} AccountTradingSymbolInfoUpdate
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.AccountTradingSymbolInfoUpdate = $util.emptyArray;

        /**
         * ServerResponseMsg CurrencyRates.
         * @member {Array.<PropTradingProtocol.ICurrencyRateInfoMsg>} CurrencyRates
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.CurrencyRates = $util.emptyArray;

        /**
         * ServerResponseMsg AccountTradingSymbolInfoResp.
         * @member {PropTradingProtocol.IAccountTradingSymbolInfoRespMsg|null|undefined} AccountTradingSymbolInfoResp
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.AccountTradingSymbolInfoResp = null;

        /**
         * ServerResponseMsg AccountUserRiskRuleInfoResp.
         * @member {PropTradingProtocol.IAccountUserRiskRuleInfoRespMsg|null|undefined} AccountUserRiskRuleInfoResp
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.AccountUserRiskRuleInfoResp = null;

        /**
         * ServerResponseMsg AccountUserRiskRuleSetResp.
         * @member {PropTradingProtocol.IAccountUserRiskRuleSetRespMsg|null|undefined} AccountUserRiskRuleSetResp
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.AccountUserRiskRuleSetResp = null;

        /**
         * ServerResponseMsg AccountDailyLockoutResp.
         * @member {PropTradingProtocol.IAccountDailyLockoutRespMsg|null|undefined} AccountDailyLockoutResp
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.AccountDailyLockoutResp = null;

        /**
         * ServerResponseMsg AccountHistoricalSessionResp.
         * @member {PropTradingProtocol.IAccountHistoricalSessionRespMsg|null|undefined} AccountHistoricalSessionResp
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.AccountHistoricalSessionResp = null;

        /**
         * ServerResponseMsg ContractsResps.
         * @member {PropTradingProtocol.IContractResponseWrapperMsg|null|undefined} ContractsResps
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.ContractsResps = null;

        /**
         * ServerResponseMsg AccountTradingSymbolMultiResp.
         * @member {PropTradingProtocol.IAccountTradingSymbolMultiRespMsg|null|undefined} AccountTradingSymbolMultiResp
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         */
        ServerResponseMsg.prototype.AccountTradingSymbolMultiResp = null;

        /**
         * Creates a new ServerResponseMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @static
         * @param {PropTradingProtocol.IServerResponseMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.ServerResponseMsg} ServerResponseMsg instance
         */
        ServerResponseMsg.create = function create(properties) {
            return new ServerResponseMsg(properties);
        };

        /**
         * Encodes the specified ServerResponseMsg message. Does not implicitly {@link PropTradingProtocol.ServerResponseMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @static
         * @param {PropTradingProtocol.IServerResponseMsg} message ServerResponseMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerResponseMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.LoginMsg != null && Object.hasOwnProperty.call(message, "LoginMsg"))
                $root.PropTradingProtocol.LoginResponseMsg.encode(message.LoginMsg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.Pong != null && Object.hasOwnProperty.call(message, "Pong"))
                $root.PropTradingProtocol.PongMsg.encode(message.Pong, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.InfoMsg != null && Object.hasOwnProperty.call(message, "InfoMsg"))
                $root.PropTradingProtocol.InfoRespMsg.encode(message.InfoMsg, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.BalanceInfo != null && message.BalanceInfo.length)
                for (let i = 0; i < message.BalanceInfo.length; ++i)
                    $root.PropTradingProtocol.BalanceMsg.encode(message.BalanceInfo[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.ContractMsg != null && Object.hasOwnProperty.call(message, "ContractMsg"))
                $root.PropTradingProtocol.ContractRespMsg.encode(message.ContractMsg, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.DailyPls != null && message.DailyPls.length)
                for (let i = 0; i < message.DailyPls.length; ++i)
                    $root.PropTradingProtocol.DailyPlRespMsg.encode(message.DailyPls[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.OrderInfo != null && message.OrderInfo.length)
                for (let i = 0; i < message.OrderInfo.length; ++i)
                    $root.PropTradingProtocol.OrderInfoMsg.encode(message.OrderInfo[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.LoggedOff != null && Object.hasOwnProperty.call(message, "LoggedOff"))
                $root.PropTradingProtocol.LoggedOffMsg.encode(message.LoggedOff, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.LogMsg != null && Object.hasOwnProperty.call(message, "LogMsg"))
                $root.PropTradingProtocol.LogInfoMsg.encode(message.LogMsg, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.SymbolLookup != null && Object.hasOwnProperty.call(message, "SymbolLookup"))
                $root.PropTradingProtocol.SymbolLookupRespMsg.encode(message.SymbolLookup, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.PositionInfo != null && message.PositionInfo.length)
                for (let i = 0; i < message.PositionInfo.length; ++i)
                    $root.PropTradingProtocol.PositionInfoMsg.encode(message.PositionInfo[i], writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.CancelFlatMsg != null && Object.hasOwnProperty.call(message, "CancelFlatMsg"))
                $root.PropTradingProtocol.CancelFlatRespMsg.encode(message.CancelFlatMsg, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.BracketInfo != null && message.BracketInfo.length)
                for (let i = 0; i < message.BracketInfo.length; ++i)
                    $root.PropTradingProtocol.BracketInfoMsg.encode(message.BracketInfo[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.BracketStrategyInsertReport != null && Object.hasOwnProperty.call(message, "BracketStrategyInsertReport"))
                $root.PropTradingProtocol.BracketInsertReportMsg.encode(message.BracketStrategyInsertReport, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.AccountSubscribeResp != null && Object.hasOwnProperty.call(message, "AccountSubscribeResp"))
                $root.PropTradingProtocol.AccountSubscribeRespMsg.encode(message.AccountSubscribeResp, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.AccountStatusUpdates != null && message.AccountStatusUpdates.length)
                for (let i = 0; i < message.AccountStatusUpdates.length; ++i)
                    $root.PropTradingProtocol.AccountStatusUpdateMsg.encode(message.AccountStatusUpdates[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.OcoGroupReport != null && Object.hasOwnProperty.call(message, "OcoGroupReport"))
                $root.PropTradingProtocol.OcoGroupReportMsg.encode(message.OcoGroupReport, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.FillReports != null && message.FillReports.length)
                for (let i = 0; i < message.FillReports.length; ++i)
                    $root.PropTradingProtocol.FillReportMsg.encode(message.FillReports[i], writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.TradeReports != null && message.TradeReports.length)
                for (let i = 0; i < message.TradeReports.length; ++i)
                    $root.PropTradingProtocol.TradeReportMsg.encode(message.TradeReports[i], writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.FillTradeReports != null && message.FillTradeReports.length)
                for (let i = 0; i < message.FillTradeReports.length; ++i)
                    $root.PropTradingProtocol.FillTradeReportMsg.encode(message.FillTradeReports[i], writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.CancelReverseMsg != null && Object.hasOwnProperty.call(message, "CancelReverseMsg"))
                $root.PropTradingProtocol.CancelReverseRespMsg.encode(message.CancelReverseMsg, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.UserSessionLogs != null && message.UserSessionLogs.length)
                for (let i = 0; i < message.UserSessionLogs.length; ++i)
                    $root.PropTradingProtocol.UserSessionLogMsg.encode(message.UserSessionLogs[i], writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.AccountTradingSymbolInfoUpdate != null && message.AccountTradingSymbolInfoUpdate.length)
                for (let i = 0; i < message.AccountTradingSymbolInfoUpdate.length; ++i)
                    $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.encode(message.AccountTradingSymbolInfoUpdate[i], writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.CurrencyRates != null && message.CurrencyRates.length)
                for (let i = 0; i < message.CurrencyRates.length; ++i)
                    $root.PropTradingProtocol.CurrencyRateInfoMsg.encode(message.CurrencyRates[i], writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.AccountTradingSymbolInfoResp != null && Object.hasOwnProperty.call(message, "AccountTradingSymbolInfoResp"))
                $root.PropTradingProtocol.AccountTradingSymbolInfoRespMsg.encode(message.AccountTradingSymbolInfoResp, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.AccountUserRiskRuleInfoResp != null && Object.hasOwnProperty.call(message, "AccountUserRiskRuleInfoResp"))
                $root.PropTradingProtocol.AccountUserRiskRuleInfoRespMsg.encode(message.AccountUserRiskRuleInfoResp, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.AccountUserRiskRuleSetResp != null && Object.hasOwnProperty.call(message, "AccountUserRiskRuleSetResp"))
                $root.PropTradingProtocol.AccountUserRiskRuleSetRespMsg.encode(message.AccountUserRiskRuleSetResp, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.AccountDailyLockoutResp != null && Object.hasOwnProperty.call(message, "AccountDailyLockoutResp"))
                $root.PropTradingProtocol.AccountDailyLockoutRespMsg.encode(message.AccountDailyLockoutResp, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
            if (message.AccountHistoricalSessionResp != null && Object.hasOwnProperty.call(message, "AccountHistoricalSessionResp"))
                $root.PropTradingProtocol.AccountHistoricalSessionRespMsg.encode(message.AccountHistoricalSessionResp, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
            if (message.ContractsResps != null && Object.hasOwnProperty.call(message, "ContractsResps"))
                $root.PropTradingProtocol.ContractResponseWrapperMsg.encode(message.ContractsResps, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            if (message.AccountTradingSymbolMultiResp != null && Object.hasOwnProperty.call(message, "AccountTradingSymbolMultiResp"))
                $root.PropTradingProtocol.AccountTradingSymbolMultiRespMsg.encode(message.AccountTradingSymbolMultiResp, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServerResponseMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.ServerResponseMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @static
         * @param {PropTradingProtocol.IServerResponseMsg} message ServerResponseMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerResponseMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerResponseMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.ServerResponseMsg} ServerResponseMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerResponseMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.ServerResponseMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.LoginMsg = $root.PropTradingProtocol.LoginResponseMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.Pong = $root.PropTradingProtocol.PongMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.InfoMsg = $root.PropTradingProtocol.InfoRespMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        if (!(message.BalanceInfo && message.BalanceInfo.length))
                            message.BalanceInfo = [];
                        message.BalanceInfo.push($root.PropTradingProtocol.BalanceMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.ContractMsg = $root.PropTradingProtocol.ContractRespMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        if (!(message.DailyPls && message.DailyPls.length))
                            message.DailyPls = [];
                        message.DailyPls.push($root.PropTradingProtocol.DailyPlRespMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        if (!(message.OrderInfo && message.OrderInfo.length))
                            message.OrderInfo = [];
                        message.OrderInfo.push($root.PropTradingProtocol.OrderInfoMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 8: {
                        message.LoggedOff = $root.PropTradingProtocol.LoggedOffMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.LogMsg = $root.PropTradingProtocol.LogInfoMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.SymbolLookup = $root.PropTradingProtocol.SymbolLookupRespMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        if (!(message.PositionInfo && message.PositionInfo.length))
                            message.PositionInfo = [];
                        message.PositionInfo.push($root.PropTradingProtocol.PositionInfoMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 12: {
                        message.CancelFlatMsg = $root.PropTradingProtocol.CancelFlatRespMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        if (!(message.BracketInfo && message.BracketInfo.length))
                            message.BracketInfo = [];
                        message.BracketInfo.push($root.PropTradingProtocol.BracketInfoMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 14: {
                        message.BracketStrategyInsertReport = $root.PropTradingProtocol.BracketInsertReportMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.AccountSubscribeResp = $root.PropTradingProtocol.AccountSubscribeRespMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 16: {
                        if (!(message.AccountStatusUpdates && message.AccountStatusUpdates.length))
                            message.AccountStatusUpdates = [];
                        message.AccountStatusUpdates.push($root.PropTradingProtocol.AccountStatusUpdateMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 17: {
                        message.OcoGroupReport = $root.PropTradingProtocol.OcoGroupReportMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 18: {
                        if (!(message.FillReports && message.FillReports.length))
                            message.FillReports = [];
                        message.FillReports.push($root.PropTradingProtocol.FillReportMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 19: {
                        if (!(message.TradeReports && message.TradeReports.length))
                            message.TradeReports = [];
                        message.TradeReports.push($root.PropTradingProtocol.TradeReportMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 20: {
                        if (!(message.FillTradeReports && message.FillTradeReports.length))
                            message.FillTradeReports = [];
                        message.FillTradeReports.push($root.PropTradingProtocol.FillTradeReportMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 21: {
                        message.CancelReverseMsg = $root.PropTradingProtocol.CancelReverseRespMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 22: {
                        if (!(message.UserSessionLogs && message.UserSessionLogs.length))
                            message.UserSessionLogs = [];
                        message.UserSessionLogs.push($root.PropTradingProtocol.UserSessionLogMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 23: {
                        if (!(message.AccountTradingSymbolInfoUpdate && message.AccountTradingSymbolInfoUpdate.length))
                            message.AccountTradingSymbolInfoUpdate = [];
                        message.AccountTradingSymbolInfoUpdate.push($root.PropTradingProtocol.AccountTradingSymbolInfoMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 24: {
                        if (!(message.CurrencyRates && message.CurrencyRates.length))
                            message.CurrencyRates = [];
                        message.CurrencyRates.push($root.PropTradingProtocol.CurrencyRateInfoMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 25: {
                        message.AccountTradingSymbolInfoResp = $root.PropTradingProtocol.AccountTradingSymbolInfoRespMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 26: {
                        message.AccountUserRiskRuleInfoResp = $root.PropTradingProtocol.AccountUserRiskRuleInfoRespMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 27: {
                        message.AccountUserRiskRuleSetResp = $root.PropTradingProtocol.AccountUserRiskRuleSetRespMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 28: {
                        message.AccountDailyLockoutResp = $root.PropTradingProtocol.AccountDailyLockoutRespMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 29: {
                        message.AccountHistoricalSessionResp = $root.PropTradingProtocol.AccountHistoricalSessionRespMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 30: {
                        message.ContractsResps = $root.PropTradingProtocol.ContractResponseWrapperMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 31: {
                        message.AccountTradingSymbolMultiResp = $root.PropTradingProtocol.AccountTradingSymbolMultiRespMsg.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerResponseMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.ServerResponseMsg} ServerResponseMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerResponseMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerResponseMsg message.
         * @function verify
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerResponseMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.LoginMsg != null && message.hasOwnProperty("LoginMsg")) {
                let error = $root.PropTradingProtocol.LoginResponseMsg.verify(message.LoginMsg);
                if (error)
                    return "LoginMsg." + error;
            }
            if (message.Pong != null && message.hasOwnProperty("Pong")) {
                let error = $root.PropTradingProtocol.PongMsg.verify(message.Pong);
                if (error)
                    return "Pong." + error;
            }
            if (message.InfoMsg != null && message.hasOwnProperty("InfoMsg")) {
                let error = $root.PropTradingProtocol.InfoRespMsg.verify(message.InfoMsg);
                if (error)
                    return "InfoMsg." + error;
            }
            if (message.BalanceInfo != null && message.hasOwnProperty("BalanceInfo")) {
                if (!Array.isArray(message.BalanceInfo))
                    return "BalanceInfo: array expected";
                for (let i = 0; i < message.BalanceInfo.length; ++i) {
                    let error = $root.PropTradingProtocol.BalanceMsg.verify(message.BalanceInfo[i]);
                    if (error)
                        return "BalanceInfo." + error;
                }
            }
            if (message.ContractMsg != null && message.hasOwnProperty("ContractMsg")) {
                let error = $root.PropTradingProtocol.ContractRespMsg.verify(message.ContractMsg);
                if (error)
                    return "ContractMsg." + error;
            }
            if (message.DailyPls != null && message.hasOwnProperty("DailyPls")) {
                if (!Array.isArray(message.DailyPls))
                    return "DailyPls: array expected";
                for (let i = 0; i < message.DailyPls.length; ++i) {
                    let error = $root.PropTradingProtocol.DailyPlRespMsg.verify(message.DailyPls[i]);
                    if (error)
                        return "DailyPls." + error;
                }
            }
            if (message.OrderInfo != null && message.hasOwnProperty("OrderInfo")) {
                if (!Array.isArray(message.OrderInfo))
                    return "OrderInfo: array expected";
                for (let i = 0; i < message.OrderInfo.length; ++i) {
                    let error = $root.PropTradingProtocol.OrderInfoMsg.verify(message.OrderInfo[i]);
                    if (error)
                        return "OrderInfo." + error;
                }
            }
            if (message.LoggedOff != null && message.hasOwnProperty("LoggedOff")) {
                let error = $root.PropTradingProtocol.LoggedOffMsg.verify(message.LoggedOff);
                if (error)
                    return "LoggedOff." + error;
            }
            if (message.LogMsg != null && message.hasOwnProperty("LogMsg")) {
                let error = $root.PropTradingProtocol.LogInfoMsg.verify(message.LogMsg);
                if (error)
                    return "LogMsg." + error;
            }
            if (message.SymbolLookup != null && message.hasOwnProperty("SymbolLookup")) {
                let error = $root.PropTradingProtocol.SymbolLookupRespMsg.verify(message.SymbolLookup);
                if (error)
                    return "SymbolLookup." + error;
            }
            if (message.PositionInfo != null && message.hasOwnProperty("PositionInfo")) {
                if (!Array.isArray(message.PositionInfo))
                    return "PositionInfo: array expected";
                for (let i = 0; i < message.PositionInfo.length; ++i) {
                    let error = $root.PropTradingProtocol.PositionInfoMsg.verify(message.PositionInfo[i]);
                    if (error)
                        return "PositionInfo." + error;
                }
            }
            if (message.CancelFlatMsg != null && message.hasOwnProperty("CancelFlatMsg")) {
                let error = $root.PropTradingProtocol.CancelFlatRespMsg.verify(message.CancelFlatMsg);
                if (error)
                    return "CancelFlatMsg." + error;
            }
            if (message.BracketInfo != null && message.hasOwnProperty("BracketInfo")) {
                if (!Array.isArray(message.BracketInfo))
                    return "BracketInfo: array expected";
                for (let i = 0; i < message.BracketInfo.length; ++i) {
                    let error = $root.PropTradingProtocol.BracketInfoMsg.verify(message.BracketInfo[i]);
                    if (error)
                        return "BracketInfo." + error;
                }
            }
            if (message.BracketStrategyInsertReport != null && message.hasOwnProperty("BracketStrategyInsertReport")) {
                let error = $root.PropTradingProtocol.BracketInsertReportMsg.verify(message.BracketStrategyInsertReport);
                if (error)
                    return "BracketStrategyInsertReport." + error;
            }
            if (message.AccountSubscribeResp != null && message.hasOwnProperty("AccountSubscribeResp")) {
                let error = $root.PropTradingProtocol.AccountSubscribeRespMsg.verify(message.AccountSubscribeResp);
                if (error)
                    return "AccountSubscribeResp." + error;
            }
            if (message.AccountStatusUpdates != null && message.hasOwnProperty("AccountStatusUpdates")) {
                if (!Array.isArray(message.AccountStatusUpdates))
                    return "AccountStatusUpdates: array expected";
                for (let i = 0; i < message.AccountStatusUpdates.length; ++i) {
                    let error = $root.PropTradingProtocol.AccountStatusUpdateMsg.verify(message.AccountStatusUpdates[i]);
                    if (error)
                        return "AccountStatusUpdates." + error;
                }
            }
            if (message.OcoGroupReport != null && message.hasOwnProperty("OcoGroupReport")) {
                let error = $root.PropTradingProtocol.OcoGroupReportMsg.verify(message.OcoGroupReport);
                if (error)
                    return "OcoGroupReport." + error;
            }
            if (message.FillReports != null && message.hasOwnProperty("FillReports")) {
                if (!Array.isArray(message.FillReports))
                    return "FillReports: array expected";
                for (let i = 0; i < message.FillReports.length; ++i) {
                    let error = $root.PropTradingProtocol.FillReportMsg.verify(message.FillReports[i]);
                    if (error)
                        return "FillReports." + error;
                }
            }
            if (message.TradeReports != null && message.hasOwnProperty("TradeReports")) {
                if (!Array.isArray(message.TradeReports))
                    return "TradeReports: array expected";
                for (let i = 0; i < message.TradeReports.length; ++i) {
                    let error = $root.PropTradingProtocol.TradeReportMsg.verify(message.TradeReports[i]);
                    if (error)
                        return "TradeReports." + error;
                }
            }
            if (message.FillTradeReports != null && message.hasOwnProperty("FillTradeReports")) {
                if (!Array.isArray(message.FillTradeReports))
                    return "FillTradeReports: array expected";
                for (let i = 0; i < message.FillTradeReports.length; ++i) {
                    let error = $root.PropTradingProtocol.FillTradeReportMsg.verify(message.FillTradeReports[i]);
                    if (error)
                        return "FillTradeReports." + error;
                }
            }
            if (message.CancelReverseMsg != null && message.hasOwnProperty("CancelReverseMsg")) {
                let error = $root.PropTradingProtocol.CancelReverseRespMsg.verify(message.CancelReverseMsg);
                if (error)
                    return "CancelReverseMsg." + error;
            }
            if (message.UserSessionLogs != null && message.hasOwnProperty("UserSessionLogs")) {
                if (!Array.isArray(message.UserSessionLogs))
                    return "UserSessionLogs: array expected";
                for (let i = 0; i < message.UserSessionLogs.length; ++i) {
                    let error = $root.PropTradingProtocol.UserSessionLogMsg.verify(message.UserSessionLogs[i]);
                    if (error)
                        return "UserSessionLogs." + error;
                }
            }
            if (message.AccountTradingSymbolInfoUpdate != null && message.hasOwnProperty("AccountTradingSymbolInfoUpdate")) {
                if (!Array.isArray(message.AccountTradingSymbolInfoUpdate))
                    return "AccountTradingSymbolInfoUpdate: array expected";
                for (let i = 0; i < message.AccountTradingSymbolInfoUpdate.length; ++i) {
                    let error = $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.verify(message.AccountTradingSymbolInfoUpdate[i]);
                    if (error)
                        return "AccountTradingSymbolInfoUpdate." + error;
                }
            }
            if (message.CurrencyRates != null && message.hasOwnProperty("CurrencyRates")) {
                if (!Array.isArray(message.CurrencyRates))
                    return "CurrencyRates: array expected";
                for (let i = 0; i < message.CurrencyRates.length; ++i) {
                    let error = $root.PropTradingProtocol.CurrencyRateInfoMsg.verify(message.CurrencyRates[i]);
                    if (error)
                        return "CurrencyRates." + error;
                }
            }
            if (message.AccountTradingSymbolInfoResp != null && message.hasOwnProperty("AccountTradingSymbolInfoResp")) {
                let error = $root.PropTradingProtocol.AccountTradingSymbolInfoRespMsg.verify(message.AccountTradingSymbolInfoResp);
                if (error)
                    return "AccountTradingSymbolInfoResp." + error;
            }
            if (message.AccountUserRiskRuleInfoResp != null && message.hasOwnProperty("AccountUserRiskRuleInfoResp")) {
                let error = $root.PropTradingProtocol.AccountUserRiskRuleInfoRespMsg.verify(message.AccountUserRiskRuleInfoResp);
                if (error)
                    return "AccountUserRiskRuleInfoResp." + error;
            }
            if (message.AccountUserRiskRuleSetResp != null && message.hasOwnProperty("AccountUserRiskRuleSetResp")) {
                let error = $root.PropTradingProtocol.AccountUserRiskRuleSetRespMsg.verify(message.AccountUserRiskRuleSetResp);
                if (error)
                    return "AccountUserRiskRuleSetResp." + error;
            }
            if (message.AccountDailyLockoutResp != null && message.hasOwnProperty("AccountDailyLockoutResp")) {
                let error = $root.PropTradingProtocol.AccountDailyLockoutRespMsg.verify(message.AccountDailyLockoutResp);
                if (error)
                    return "AccountDailyLockoutResp." + error;
            }
            if (message.AccountHistoricalSessionResp != null && message.hasOwnProperty("AccountHistoricalSessionResp")) {
                let error = $root.PropTradingProtocol.AccountHistoricalSessionRespMsg.verify(message.AccountHistoricalSessionResp);
                if (error)
                    return "AccountHistoricalSessionResp." + error;
            }
            if (message.ContractsResps != null && message.hasOwnProperty("ContractsResps")) {
                let error = $root.PropTradingProtocol.ContractResponseWrapperMsg.verify(message.ContractsResps);
                if (error)
                    return "ContractsResps." + error;
            }
            if (message.AccountTradingSymbolMultiResp != null && message.hasOwnProperty("AccountTradingSymbolMultiResp")) {
                let error = $root.PropTradingProtocol.AccountTradingSymbolMultiRespMsg.verify(message.AccountTradingSymbolMultiResp);
                if (error)
                    return "AccountTradingSymbolMultiResp." + error;
            }
            return null;
        };

        /**
         * Creates a ServerResponseMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.ServerResponseMsg} ServerResponseMsg
         */
        ServerResponseMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.ServerResponseMsg)
                return object;
            let message = new $root.PropTradingProtocol.ServerResponseMsg();
            if (object.LoginMsg != null) {
                if (typeof object.LoginMsg !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.LoginMsg: object expected");
                message.LoginMsg = $root.PropTradingProtocol.LoginResponseMsg.fromObject(object.LoginMsg);
            }
            if (object.Pong != null) {
                if (typeof object.Pong !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.Pong: object expected");
                message.Pong = $root.PropTradingProtocol.PongMsg.fromObject(object.Pong);
            }
            if (object.InfoMsg != null) {
                if (typeof object.InfoMsg !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.InfoMsg: object expected");
                message.InfoMsg = $root.PropTradingProtocol.InfoRespMsg.fromObject(object.InfoMsg);
            }
            if (object.BalanceInfo) {
                if (!Array.isArray(object.BalanceInfo))
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.BalanceInfo: array expected");
                message.BalanceInfo = [];
                for (let i = 0; i < object.BalanceInfo.length; ++i) {
                    if (typeof object.BalanceInfo[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ServerResponseMsg.BalanceInfo: object expected");
                    message.BalanceInfo[i] = $root.PropTradingProtocol.BalanceMsg.fromObject(object.BalanceInfo[i]);
                }
            }
            if (object.ContractMsg != null) {
                if (typeof object.ContractMsg !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.ContractMsg: object expected");
                message.ContractMsg = $root.PropTradingProtocol.ContractRespMsg.fromObject(object.ContractMsg);
            }
            if (object.DailyPls) {
                if (!Array.isArray(object.DailyPls))
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.DailyPls: array expected");
                message.DailyPls = [];
                for (let i = 0; i < object.DailyPls.length; ++i) {
                    if (typeof object.DailyPls[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ServerResponseMsg.DailyPls: object expected");
                    message.DailyPls[i] = $root.PropTradingProtocol.DailyPlRespMsg.fromObject(object.DailyPls[i]);
                }
            }
            if (object.OrderInfo) {
                if (!Array.isArray(object.OrderInfo))
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.OrderInfo: array expected");
                message.OrderInfo = [];
                for (let i = 0; i < object.OrderInfo.length; ++i) {
                    if (typeof object.OrderInfo[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ServerResponseMsg.OrderInfo: object expected");
                    message.OrderInfo[i] = $root.PropTradingProtocol.OrderInfoMsg.fromObject(object.OrderInfo[i]);
                }
            }
            if (object.LoggedOff != null) {
                if (typeof object.LoggedOff !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.LoggedOff: object expected");
                message.LoggedOff = $root.PropTradingProtocol.LoggedOffMsg.fromObject(object.LoggedOff);
            }
            if (object.LogMsg != null) {
                if (typeof object.LogMsg !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.LogMsg: object expected");
                message.LogMsg = $root.PropTradingProtocol.LogInfoMsg.fromObject(object.LogMsg);
            }
            if (object.SymbolLookup != null) {
                if (typeof object.SymbolLookup !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.SymbolLookup: object expected");
                message.SymbolLookup = $root.PropTradingProtocol.SymbolLookupRespMsg.fromObject(object.SymbolLookup);
            }
            if (object.PositionInfo) {
                if (!Array.isArray(object.PositionInfo))
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.PositionInfo: array expected");
                message.PositionInfo = [];
                for (let i = 0; i < object.PositionInfo.length; ++i) {
                    if (typeof object.PositionInfo[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ServerResponseMsg.PositionInfo: object expected");
                    message.PositionInfo[i] = $root.PropTradingProtocol.PositionInfoMsg.fromObject(object.PositionInfo[i]);
                }
            }
            if (object.CancelFlatMsg != null) {
                if (typeof object.CancelFlatMsg !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.CancelFlatMsg: object expected");
                message.CancelFlatMsg = $root.PropTradingProtocol.CancelFlatRespMsg.fromObject(object.CancelFlatMsg);
            }
            if (object.BracketInfo) {
                if (!Array.isArray(object.BracketInfo))
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.BracketInfo: array expected");
                message.BracketInfo = [];
                for (let i = 0; i < object.BracketInfo.length; ++i) {
                    if (typeof object.BracketInfo[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ServerResponseMsg.BracketInfo: object expected");
                    message.BracketInfo[i] = $root.PropTradingProtocol.BracketInfoMsg.fromObject(object.BracketInfo[i]);
                }
            }
            if (object.BracketStrategyInsertReport != null) {
                if (typeof object.BracketStrategyInsertReport !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.BracketStrategyInsertReport: object expected");
                message.BracketStrategyInsertReport = $root.PropTradingProtocol.BracketInsertReportMsg.fromObject(object.BracketStrategyInsertReport);
            }
            if (object.AccountSubscribeResp != null) {
                if (typeof object.AccountSubscribeResp !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.AccountSubscribeResp: object expected");
                message.AccountSubscribeResp = $root.PropTradingProtocol.AccountSubscribeRespMsg.fromObject(object.AccountSubscribeResp);
            }
            if (object.AccountStatusUpdates) {
                if (!Array.isArray(object.AccountStatusUpdates))
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.AccountStatusUpdates: array expected");
                message.AccountStatusUpdates = [];
                for (let i = 0; i < object.AccountStatusUpdates.length; ++i) {
                    if (typeof object.AccountStatusUpdates[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ServerResponseMsg.AccountStatusUpdates: object expected");
                    message.AccountStatusUpdates[i] = $root.PropTradingProtocol.AccountStatusUpdateMsg.fromObject(object.AccountStatusUpdates[i]);
                }
            }
            if (object.OcoGroupReport != null) {
                if (typeof object.OcoGroupReport !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.OcoGroupReport: object expected");
                message.OcoGroupReport = $root.PropTradingProtocol.OcoGroupReportMsg.fromObject(object.OcoGroupReport);
            }
            if (object.FillReports) {
                if (!Array.isArray(object.FillReports))
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.FillReports: array expected");
                message.FillReports = [];
                for (let i = 0; i < object.FillReports.length; ++i) {
                    if (typeof object.FillReports[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ServerResponseMsg.FillReports: object expected");
                    message.FillReports[i] = $root.PropTradingProtocol.FillReportMsg.fromObject(object.FillReports[i]);
                }
            }
            if (object.TradeReports) {
                if (!Array.isArray(object.TradeReports))
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.TradeReports: array expected");
                message.TradeReports = [];
                for (let i = 0; i < object.TradeReports.length; ++i) {
                    if (typeof object.TradeReports[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ServerResponseMsg.TradeReports: object expected");
                    message.TradeReports[i] = $root.PropTradingProtocol.TradeReportMsg.fromObject(object.TradeReports[i]);
                }
            }
            if (object.FillTradeReports) {
                if (!Array.isArray(object.FillTradeReports))
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.FillTradeReports: array expected");
                message.FillTradeReports = [];
                for (let i = 0; i < object.FillTradeReports.length; ++i) {
                    if (typeof object.FillTradeReports[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ServerResponseMsg.FillTradeReports: object expected");
                    message.FillTradeReports[i] = $root.PropTradingProtocol.FillTradeReportMsg.fromObject(object.FillTradeReports[i]);
                }
            }
            if (object.CancelReverseMsg != null) {
                if (typeof object.CancelReverseMsg !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.CancelReverseMsg: object expected");
                message.CancelReverseMsg = $root.PropTradingProtocol.CancelReverseRespMsg.fromObject(object.CancelReverseMsg);
            }
            if (object.UserSessionLogs) {
                if (!Array.isArray(object.UserSessionLogs))
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.UserSessionLogs: array expected");
                message.UserSessionLogs = [];
                for (let i = 0; i < object.UserSessionLogs.length; ++i) {
                    if (typeof object.UserSessionLogs[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ServerResponseMsg.UserSessionLogs: object expected");
                    message.UserSessionLogs[i] = $root.PropTradingProtocol.UserSessionLogMsg.fromObject(object.UserSessionLogs[i]);
                }
            }
            if (object.AccountTradingSymbolInfoUpdate) {
                if (!Array.isArray(object.AccountTradingSymbolInfoUpdate))
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.AccountTradingSymbolInfoUpdate: array expected");
                message.AccountTradingSymbolInfoUpdate = [];
                for (let i = 0; i < object.AccountTradingSymbolInfoUpdate.length; ++i) {
                    if (typeof object.AccountTradingSymbolInfoUpdate[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ServerResponseMsg.AccountTradingSymbolInfoUpdate: object expected");
                    message.AccountTradingSymbolInfoUpdate[i] = $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.fromObject(object.AccountTradingSymbolInfoUpdate[i]);
                }
            }
            if (object.CurrencyRates) {
                if (!Array.isArray(object.CurrencyRates))
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.CurrencyRates: array expected");
                message.CurrencyRates = [];
                for (let i = 0; i < object.CurrencyRates.length; ++i) {
                    if (typeof object.CurrencyRates[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ServerResponseMsg.CurrencyRates: object expected");
                    message.CurrencyRates[i] = $root.PropTradingProtocol.CurrencyRateInfoMsg.fromObject(object.CurrencyRates[i]);
                }
            }
            if (object.AccountTradingSymbolInfoResp != null) {
                if (typeof object.AccountTradingSymbolInfoResp !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.AccountTradingSymbolInfoResp: object expected");
                message.AccountTradingSymbolInfoResp = $root.PropTradingProtocol.AccountTradingSymbolInfoRespMsg.fromObject(object.AccountTradingSymbolInfoResp);
            }
            if (object.AccountUserRiskRuleInfoResp != null) {
                if (typeof object.AccountUserRiskRuleInfoResp !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.AccountUserRiskRuleInfoResp: object expected");
                message.AccountUserRiskRuleInfoResp = $root.PropTradingProtocol.AccountUserRiskRuleInfoRespMsg.fromObject(object.AccountUserRiskRuleInfoResp);
            }
            if (object.AccountUserRiskRuleSetResp != null) {
                if (typeof object.AccountUserRiskRuleSetResp !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.AccountUserRiskRuleSetResp: object expected");
                message.AccountUserRiskRuleSetResp = $root.PropTradingProtocol.AccountUserRiskRuleSetRespMsg.fromObject(object.AccountUserRiskRuleSetResp);
            }
            if (object.AccountDailyLockoutResp != null) {
                if (typeof object.AccountDailyLockoutResp !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.AccountDailyLockoutResp: object expected");
                message.AccountDailyLockoutResp = $root.PropTradingProtocol.AccountDailyLockoutRespMsg.fromObject(object.AccountDailyLockoutResp);
            }
            if (object.AccountHistoricalSessionResp != null) {
                if (typeof object.AccountHistoricalSessionResp !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.AccountHistoricalSessionResp: object expected");
                message.AccountHistoricalSessionResp = $root.PropTradingProtocol.AccountHistoricalSessionRespMsg.fromObject(object.AccountHistoricalSessionResp);
            }
            if (object.ContractsResps != null) {
                if (typeof object.ContractsResps !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.ContractsResps: object expected");
                message.ContractsResps = $root.PropTradingProtocol.ContractResponseWrapperMsg.fromObject(object.ContractsResps);
            }
            if (object.AccountTradingSymbolMultiResp != null) {
                if (typeof object.AccountTradingSymbolMultiResp !== "object")
                    throw TypeError(".PropTradingProtocol.ServerResponseMsg.AccountTradingSymbolMultiResp: object expected");
                message.AccountTradingSymbolMultiResp = $root.PropTradingProtocol.AccountTradingSymbolMultiRespMsg.fromObject(object.AccountTradingSymbolMultiResp);
            }
            return message;
        };

        /**
         * Creates a plain object from a ServerResponseMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @static
         * @param {PropTradingProtocol.ServerResponseMsg} message ServerResponseMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerResponseMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.BalanceInfo = [];
                object.DailyPls = [];
                object.OrderInfo = [];
                object.PositionInfo = [];
                object.BracketInfo = [];
                object.AccountStatusUpdates = [];
                object.FillReports = [];
                object.TradeReports = [];
                object.FillTradeReports = [];
                object.UserSessionLogs = [];
                object.AccountTradingSymbolInfoUpdate = [];
                object.CurrencyRates = [];
            }
            if (options.defaults) {
                object.LoginMsg = null;
                object.Pong = null;
                object.InfoMsg = null;
                object.ContractMsg = null;
                object.LoggedOff = null;
                object.LogMsg = null;
                object.SymbolLookup = null;
                object.CancelFlatMsg = null;
                object.BracketStrategyInsertReport = null;
                object.AccountSubscribeResp = null;
                object.OcoGroupReport = null;
                object.CancelReverseMsg = null;
                object.AccountTradingSymbolInfoResp = null;
                object.AccountUserRiskRuleInfoResp = null;
                object.AccountUserRiskRuleSetResp = null;
                object.AccountDailyLockoutResp = null;
                object.AccountHistoricalSessionResp = null;
                object.ContractsResps = null;
                object.AccountTradingSymbolMultiResp = null;
            }
            if (message.LoginMsg != null && message.hasOwnProperty("LoginMsg"))
                object.LoginMsg = $root.PropTradingProtocol.LoginResponseMsg.toObject(message.LoginMsg, options);
            if (message.Pong != null && message.hasOwnProperty("Pong"))
                object.Pong = $root.PropTradingProtocol.PongMsg.toObject(message.Pong, options);
            if (message.InfoMsg != null && message.hasOwnProperty("InfoMsg"))
                object.InfoMsg = $root.PropTradingProtocol.InfoRespMsg.toObject(message.InfoMsg, options);
            if (message.BalanceInfo && message.BalanceInfo.length) {
                object.BalanceInfo = [];
                for (let j = 0; j < message.BalanceInfo.length; ++j)
                    object.BalanceInfo[j] = $root.PropTradingProtocol.BalanceMsg.toObject(message.BalanceInfo[j], options);
            }
            if (message.ContractMsg != null && message.hasOwnProperty("ContractMsg"))
                object.ContractMsg = $root.PropTradingProtocol.ContractRespMsg.toObject(message.ContractMsg, options);
            if (message.DailyPls && message.DailyPls.length) {
                object.DailyPls = [];
                for (let j = 0; j < message.DailyPls.length; ++j)
                    object.DailyPls[j] = $root.PropTradingProtocol.DailyPlRespMsg.toObject(message.DailyPls[j], options);
            }
            if (message.OrderInfo && message.OrderInfo.length) {
                object.OrderInfo = [];
                for (let j = 0; j < message.OrderInfo.length; ++j)
                    object.OrderInfo[j] = $root.PropTradingProtocol.OrderInfoMsg.toObject(message.OrderInfo[j], options);
            }
            if (message.LoggedOff != null && message.hasOwnProperty("LoggedOff"))
                object.LoggedOff = $root.PropTradingProtocol.LoggedOffMsg.toObject(message.LoggedOff, options);
            if (message.LogMsg != null && message.hasOwnProperty("LogMsg"))
                object.LogMsg = $root.PropTradingProtocol.LogInfoMsg.toObject(message.LogMsg, options);
            if (message.SymbolLookup != null && message.hasOwnProperty("SymbolLookup"))
                object.SymbolLookup = $root.PropTradingProtocol.SymbolLookupRespMsg.toObject(message.SymbolLookup, options);
            if (message.PositionInfo && message.PositionInfo.length) {
                object.PositionInfo = [];
                for (let j = 0; j < message.PositionInfo.length; ++j)
                    object.PositionInfo[j] = $root.PropTradingProtocol.PositionInfoMsg.toObject(message.PositionInfo[j], options);
            }
            if (message.CancelFlatMsg != null && message.hasOwnProperty("CancelFlatMsg"))
                object.CancelFlatMsg = $root.PropTradingProtocol.CancelFlatRespMsg.toObject(message.CancelFlatMsg, options);
            if (message.BracketInfo && message.BracketInfo.length) {
                object.BracketInfo = [];
                for (let j = 0; j < message.BracketInfo.length; ++j)
                    object.BracketInfo[j] = $root.PropTradingProtocol.BracketInfoMsg.toObject(message.BracketInfo[j], options);
            }
            if (message.BracketStrategyInsertReport != null && message.hasOwnProperty("BracketStrategyInsertReport"))
                object.BracketStrategyInsertReport = $root.PropTradingProtocol.BracketInsertReportMsg.toObject(message.BracketStrategyInsertReport, options);
            if (message.AccountSubscribeResp != null && message.hasOwnProperty("AccountSubscribeResp"))
                object.AccountSubscribeResp = $root.PropTradingProtocol.AccountSubscribeRespMsg.toObject(message.AccountSubscribeResp, options);
            if (message.AccountStatusUpdates && message.AccountStatusUpdates.length) {
                object.AccountStatusUpdates = [];
                for (let j = 0; j < message.AccountStatusUpdates.length; ++j)
                    object.AccountStatusUpdates[j] = $root.PropTradingProtocol.AccountStatusUpdateMsg.toObject(message.AccountStatusUpdates[j], options);
            }
            if (message.OcoGroupReport != null && message.hasOwnProperty("OcoGroupReport"))
                object.OcoGroupReport = $root.PropTradingProtocol.OcoGroupReportMsg.toObject(message.OcoGroupReport, options);
            if (message.FillReports && message.FillReports.length) {
                object.FillReports = [];
                for (let j = 0; j < message.FillReports.length; ++j)
                    object.FillReports[j] = $root.PropTradingProtocol.FillReportMsg.toObject(message.FillReports[j], options);
            }
            if (message.TradeReports && message.TradeReports.length) {
                object.TradeReports = [];
                for (let j = 0; j < message.TradeReports.length; ++j)
                    object.TradeReports[j] = $root.PropTradingProtocol.TradeReportMsg.toObject(message.TradeReports[j], options);
            }
            if (message.FillTradeReports && message.FillTradeReports.length) {
                object.FillTradeReports = [];
                for (let j = 0; j < message.FillTradeReports.length; ++j)
                    object.FillTradeReports[j] = $root.PropTradingProtocol.FillTradeReportMsg.toObject(message.FillTradeReports[j], options);
            }
            if (message.CancelReverseMsg != null && message.hasOwnProperty("CancelReverseMsg"))
                object.CancelReverseMsg = $root.PropTradingProtocol.CancelReverseRespMsg.toObject(message.CancelReverseMsg, options);
            if (message.UserSessionLogs && message.UserSessionLogs.length) {
                object.UserSessionLogs = [];
                for (let j = 0; j < message.UserSessionLogs.length; ++j)
                    object.UserSessionLogs[j] = $root.PropTradingProtocol.UserSessionLogMsg.toObject(message.UserSessionLogs[j], options);
            }
            if (message.AccountTradingSymbolInfoUpdate && message.AccountTradingSymbolInfoUpdate.length) {
                object.AccountTradingSymbolInfoUpdate = [];
                for (let j = 0; j < message.AccountTradingSymbolInfoUpdate.length; ++j)
                    object.AccountTradingSymbolInfoUpdate[j] = $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.toObject(message.AccountTradingSymbolInfoUpdate[j], options);
            }
            if (message.CurrencyRates && message.CurrencyRates.length) {
                object.CurrencyRates = [];
                for (let j = 0; j < message.CurrencyRates.length; ++j)
                    object.CurrencyRates[j] = $root.PropTradingProtocol.CurrencyRateInfoMsg.toObject(message.CurrencyRates[j], options);
            }
            if (message.AccountTradingSymbolInfoResp != null && message.hasOwnProperty("AccountTradingSymbolInfoResp"))
                object.AccountTradingSymbolInfoResp = $root.PropTradingProtocol.AccountTradingSymbolInfoRespMsg.toObject(message.AccountTradingSymbolInfoResp, options);
            if (message.AccountUserRiskRuleInfoResp != null && message.hasOwnProperty("AccountUserRiskRuleInfoResp"))
                object.AccountUserRiskRuleInfoResp = $root.PropTradingProtocol.AccountUserRiskRuleInfoRespMsg.toObject(message.AccountUserRiskRuleInfoResp, options);
            if (message.AccountUserRiskRuleSetResp != null && message.hasOwnProperty("AccountUserRiskRuleSetResp"))
                object.AccountUserRiskRuleSetResp = $root.PropTradingProtocol.AccountUserRiskRuleSetRespMsg.toObject(message.AccountUserRiskRuleSetResp, options);
            if (message.AccountDailyLockoutResp != null && message.hasOwnProperty("AccountDailyLockoutResp"))
                object.AccountDailyLockoutResp = $root.PropTradingProtocol.AccountDailyLockoutRespMsg.toObject(message.AccountDailyLockoutResp, options);
            if (message.AccountHistoricalSessionResp != null && message.hasOwnProperty("AccountHistoricalSessionResp"))
                object.AccountHistoricalSessionResp = $root.PropTradingProtocol.AccountHistoricalSessionRespMsg.toObject(message.AccountHistoricalSessionResp, options);
            if (message.ContractsResps != null && message.hasOwnProperty("ContractsResps"))
                object.ContractsResps = $root.PropTradingProtocol.ContractResponseWrapperMsg.toObject(message.ContractsResps, options);
            if (message.AccountTradingSymbolMultiResp != null && message.hasOwnProperty("AccountTradingSymbolMultiResp"))
                object.AccountTradingSymbolMultiResp = $root.PropTradingProtocol.AccountTradingSymbolMultiRespMsg.toObject(message.AccountTradingSymbolMultiResp, options);
            return object;
        };

        /**
         * Converts this ServerResponseMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerResponseMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerResponseMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.ServerResponseMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerResponseMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.ServerResponseMsg";
        };

        return ServerResponseMsg;
    })();

    /**
     * AccountSubscriptionModeEnum enum.
     * @name PropTradingProtocol.AccountSubscriptionModeEnum
     * @enum {number}
     * @property {number} Undefined=0 Undefined value
     * @property {number} Manual=1 Manual value
     * @property {number} Existing=2 Existing value
     * @property {number} ExistingAndNew=3 ExistingAndNew value
     */
    PropTradingProtocol.AccountSubscriptionModeEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Undefined"] = 0;
        values[valuesById[1] = "Manual"] = 1;
        values[valuesById[2] = "Existing"] = 2;
        values[valuesById[3] = "ExistingAndNew"] = 3;
        return values;
    })();

    PropTradingProtocol.LoginRequestMsg = (function() {

        /**
         * Properties of a LoginRequestMsg.
         * @memberof PropTradingProtocol
         * @interface ILoginRequestMsg
         * @property {string|null} [Token] LoginRequestMsg Token
         * @property {string|null} [OtpCode] LoginRequestMsg OtpCode
         * @property {boolean|null} [IsManualAccountSubscribe] LoginRequestMsg IsManualAccountSubscribe
         * @property {boolean|null} [KeepConcurrentSessionOn] LoginRequestMsg KeepConcurrentSessionOn
         * @property {PropTradingProtocol.AccountSubscriptionModeEnum|null} [AccountSubscriptionMode] LoginRequestMsg AccountSubscriptionMode
         */

        /**
         * Constructs a new LoginRequestMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a LoginRequestMsg.
         * @implements ILoginRequestMsg
         * @constructor
         * @param {PropTradingProtocol.ILoginRequestMsg=} [properties] Properties to set
         */
        function LoginRequestMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginRequestMsg Token.
         * @member {string} Token
         * @memberof PropTradingProtocol.LoginRequestMsg
         * @instance
         */
        LoginRequestMsg.prototype.Token = "";

        /**
         * LoginRequestMsg OtpCode.
         * @member {string} OtpCode
         * @memberof PropTradingProtocol.LoginRequestMsg
         * @instance
         */
        LoginRequestMsg.prototype.OtpCode = "";

        /**
         * LoginRequestMsg IsManualAccountSubscribe.
         * @member {boolean} IsManualAccountSubscribe
         * @memberof PropTradingProtocol.LoginRequestMsg
         * @instance
         */
        LoginRequestMsg.prototype.IsManualAccountSubscribe = false;

        /**
         * LoginRequestMsg KeepConcurrentSessionOn.
         * @member {boolean} KeepConcurrentSessionOn
         * @memberof PropTradingProtocol.LoginRequestMsg
         * @instance
         */
        LoginRequestMsg.prototype.KeepConcurrentSessionOn = false;

        /**
         * LoginRequestMsg AccountSubscriptionMode.
         * @member {PropTradingProtocol.AccountSubscriptionModeEnum} AccountSubscriptionMode
         * @memberof PropTradingProtocol.LoginRequestMsg
         * @instance
         */
        LoginRequestMsg.prototype.AccountSubscriptionMode = 0;

        /**
         * Creates a new LoginRequestMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.LoginRequestMsg
         * @static
         * @param {PropTradingProtocol.ILoginRequestMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.LoginRequestMsg} LoginRequestMsg instance
         */
        LoginRequestMsg.create = function create(properties) {
            return new LoginRequestMsg(properties);
        };

        /**
         * Encodes the specified LoginRequestMsg message. Does not implicitly {@link PropTradingProtocol.LoginRequestMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.LoginRequestMsg
         * @static
         * @param {PropTradingProtocol.ILoginRequestMsg} message LoginRequestMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginRequestMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Token != null && Object.hasOwnProperty.call(message, "Token"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Token);
            if (message.OtpCode != null && Object.hasOwnProperty.call(message, "OtpCode"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.OtpCode);
            if (message.IsManualAccountSubscribe != null && Object.hasOwnProperty.call(message, "IsManualAccountSubscribe"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.IsManualAccountSubscribe);
            if (message.KeepConcurrentSessionOn != null && Object.hasOwnProperty.call(message, "KeepConcurrentSessionOn"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.KeepConcurrentSessionOn);
            if (message.AccountSubscriptionMode != null && Object.hasOwnProperty.call(message, "AccountSubscriptionMode"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.AccountSubscriptionMode);
            return writer;
        };

        /**
         * Encodes the specified LoginRequestMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.LoginRequestMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.LoginRequestMsg
         * @static
         * @param {PropTradingProtocol.ILoginRequestMsg} message LoginRequestMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginRequestMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginRequestMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.LoginRequestMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.LoginRequestMsg} LoginRequestMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginRequestMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.LoginRequestMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.Token = reader.string();
                        break;
                    }
                case 2: {
                        message.OtpCode = reader.string();
                        break;
                    }
                case 3: {
                        message.IsManualAccountSubscribe = reader.bool();
                        break;
                    }
                case 4: {
                        message.KeepConcurrentSessionOn = reader.bool();
                        break;
                    }
                case 5: {
                        message.AccountSubscriptionMode = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginRequestMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.LoginRequestMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.LoginRequestMsg} LoginRequestMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginRequestMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginRequestMsg message.
         * @function verify
         * @memberof PropTradingProtocol.LoginRequestMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginRequestMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Token != null && message.hasOwnProperty("Token"))
                if (!$util.isString(message.Token))
                    return "Token: string expected";
            if (message.OtpCode != null && message.hasOwnProperty("OtpCode"))
                if (!$util.isString(message.OtpCode))
                    return "OtpCode: string expected";
            if (message.IsManualAccountSubscribe != null && message.hasOwnProperty("IsManualAccountSubscribe"))
                if (typeof message.IsManualAccountSubscribe !== "boolean")
                    return "IsManualAccountSubscribe: boolean expected";
            if (message.KeepConcurrentSessionOn != null && message.hasOwnProperty("KeepConcurrentSessionOn"))
                if (typeof message.KeepConcurrentSessionOn !== "boolean")
                    return "KeepConcurrentSessionOn: boolean expected";
            if (message.AccountSubscriptionMode != null && message.hasOwnProperty("AccountSubscriptionMode"))
                switch (message.AccountSubscriptionMode) {
                default:
                    return "AccountSubscriptionMode: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a LoginRequestMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.LoginRequestMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.LoginRequestMsg} LoginRequestMsg
         */
        LoginRequestMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.LoginRequestMsg)
                return object;
            let message = new $root.PropTradingProtocol.LoginRequestMsg();
            if (object.Token != null)
                message.Token = String(object.Token);
            if (object.OtpCode != null)
                message.OtpCode = String(object.OtpCode);
            if (object.IsManualAccountSubscribe != null)
                message.IsManualAccountSubscribe = Boolean(object.IsManualAccountSubscribe);
            if (object.KeepConcurrentSessionOn != null)
                message.KeepConcurrentSessionOn = Boolean(object.KeepConcurrentSessionOn);
            switch (object.AccountSubscriptionMode) {
            default:
                if (typeof object.AccountSubscriptionMode === "number") {
                    message.AccountSubscriptionMode = object.AccountSubscriptionMode;
                    break;
                }
                break;
            case "Undefined":
            case 0:
                message.AccountSubscriptionMode = 0;
                break;
            case "Manual":
            case 1:
                message.AccountSubscriptionMode = 1;
                break;
            case "Existing":
            case 2:
                message.AccountSubscriptionMode = 2;
                break;
            case "ExistingAndNew":
            case 3:
                message.AccountSubscriptionMode = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a LoginRequestMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.LoginRequestMsg
         * @static
         * @param {PropTradingProtocol.LoginRequestMsg} message LoginRequestMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginRequestMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.Token = "";
                object.OtpCode = "";
                object.IsManualAccountSubscribe = false;
                object.KeepConcurrentSessionOn = false;
                object.AccountSubscriptionMode = options.enums === String ? "Undefined" : 0;
            }
            if (message.Token != null && message.hasOwnProperty("Token"))
                object.Token = message.Token;
            if (message.OtpCode != null && message.hasOwnProperty("OtpCode"))
                object.OtpCode = message.OtpCode;
            if (message.IsManualAccountSubscribe != null && message.hasOwnProperty("IsManualAccountSubscribe"))
                object.IsManualAccountSubscribe = message.IsManualAccountSubscribe;
            if (message.KeepConcurrentSessionOn != null && message.hasOwnProperty("KeepConcurrentSessionOn"))
                object.KeepConcurrentSessionOn = message.KeepConcurrentSessionOn;
            if (message.AccountSubscriptionMode != null && message.hasOwnProperty("AccountSubscriptionMode"))
                object.AccountSubscriptionMode = options.enums === String ? $root.PropTradingProtocol.AccountSubscriptionModeEnum[message.AccountSubscriptionMode] === undefined ? message.AccountSubscriptionMode : $root.PropTradingProtocol.AccountSubscriptionModeEnum[message.AccountSubscriptionMode] : message.AccountSubscriptionMode;
            return object;
        };

        /**
         * Converts this LoginRequestMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.LoginRequestMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginRequestMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LoginRequestMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.LoginRequestMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LoginRequestMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.LoginRequestMsg";
        };

        return LoginRequestMsg;
    })();

    PropTradingProtocol.LoginResponseMsg = (function() {

        /**
         * Properties of a LoginResponseMsg.
         * @memberof PropTradingProtocol
         * @interface ILoginResponseMsg
         * @property {boolean|null} [Success] LoginResponseMsg Success
         * @property {string|null} [Reason] LoginResponseMsg Reason
         * @property {PropTradingProtocol.LoginReasonsCodeEnum|null} [ReasonCode] LoginResponseMsg ReasonCode
         * @property {number|Long|null} [Version] LoginResponseMsg Version
         */

        /**
         * Constructs a new LoginResponseMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a LoginResponseMsg.
         * @implements ILoginResponseMsg
         * @constructor
         * @param {PropTradingProtocol.ILoginResponseMsg=} [properties] Properties to set
         */
        function LoginResponseMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginResponseMsg Success.
         * @member {boolean} Success
         * @memberof PropTradingProtocol.LoginResponseMsg
         * @instance
         */
        LoginResponseMsg.prototype.Success = false;

        /**
         * LoginResponseMsg Reason.
         * @member {string} Reason
         * @memberof PropTradingProtocol.LoginResponseMsg
         * @instance
         */
        LoginResponseMsg.prototype.Reason = "";

        /**
         * LoginResponseMsg ReasonCode.
         * @member {PropTradingProtocol.LoginReasonsCodeEnum} ReasonCode
         * @memberof PropTradingProtocol.LoginResponseMsg
         * @instance
         */
        LoginResponseMsg.prototype.ReasonCode = 0;

        /**
         * LoginResponseMsg Version.
         * @member {number|Long} Version
         * @memberof PropTradingProtocol.LoginResponseMsg
         * @instance
         */
        LoginResponseMsg.prototype.Version = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new LoginResponseMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.LoginResponseMsg
         * @static
         * @param {PropTradingProtocol.ILoginResponseMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.LoginResponseMsg} LoginResponseMsg instance
         */
        LoginResponseMsg.create = function create(properties) {
            return new LoginResponseMsg(properties);
        };

        /**
         * Encodes the specified LoginResponseMsg message. Does not implicitly {@link PropTradingProtocol.LoginResponseMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.LoginResponseMsg
         * @static
         * @param {PropTradingProtocol.ILoginResponseMsg} message LoginResponseMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginResponseMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Success != null && Object.hasOwnProperty.call(message, "Success"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.Success);
            if (message.Reason != null && Object.hasOwnProperty.call(message, "Reason"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Reason);
            if (message.ReasonCode != null && Object.hasOwnProperty.call(message, "ReasonCode"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.ReasonCode);
            if (message.Version != null && Object.hasOwnProperty.call(message, "Version"))
                writer.uint32(/* id 4, wireType 0 =*/32).sint64(message.Version);
            return writer;
        };

        /**
         * Encodes the specified LoginResponseMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.LoginResponseMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.LoginResponseMsg
         * @static
         * @param {PropTradingProtocol.ILoginResponseMsg} message LoginResponseMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginResponseMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginResponseMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.LoginResponseMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.LoginResponseMsg} LoginResponseMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginResponseMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.LoginResponseMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.Success = reader.bool();
                        break;
                    }
                case 2: {
                        message.Reason = reader.string();
                        break;
                    }
                case 3: {
                        message.ReasonCode = reader.int32();
                        break;
                    }
                case 4: {
                        message.Version = reader.sint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginResponseMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.LoginResponseMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.LoginResponseMsg} LoginResponseMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginResponseMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginResponseMsg message.
         * @function verify
         * @memberof PropTradingProtocol.LoginResponseMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginResponseMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Success != null && message.hasOwnProperty("Success"))
                if (typeof message.Success !== "boolean")
                    return "Success: boolean expected";
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                if (!$util.isString(message.Reason))
                    return "Reason: string expected";
            if (message.ReasonCode != null && message.hasOwnProperty("ReasonCode"))
                switch (message.ReasonCode) {
                default:
                    return "ReasonCode: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.Version != null && message.hasOwnProperty("Version"))
                if (!$util.isInteger(message.Version) && !(message.Version && $util.isInteger(message.Version.low) && $util.isInteger(message.Version.high)))
                    return "Version: integer|Long expected";
            return null;
        };

        /**
         * Creates a LoginResponseMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.LoginResponseMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.LoginResponseMsg} LoginResponseMsg
         */
        LoginResponseMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.LoginResponseMsg)
                return object;
            let message = new $root.PropTradingProtocol.LoginResponseMsg();
            if (object.Success != null)
                message.Success = Boolean(object.Success);
            if (object.Reason != null)
                message.Reason = String(object.Reason);
            switch (object.ReasonCode) {
            default:
                if (typeof object.ReasonCode === "number") {
                    message.ReasonCode = object.ReasonCode;
                    break;
                }
                break;
            case "CREDENTIALS":
            case 0:
                message.ReasonCode = 0;
                break;
            case "CONCURRENT_SESSION":
            case 1:
                message.ReasonCode = 1;
                break;
            case "UNEXPECTED_ERROR":
            case 2:
                message.ReasonCode = 2;
                break;
            }
            if (object.Version != null)
                if ($util.Long)
                    (message.Version = $util.Long.fromValue(object.Version)).unsigned = false;
                else if (typeof object.Version === "string")
                    message.Version = parseInt(object.Version, 10);
                else if (typeof object.Version === "number")
                    message.Version = object.Version;
                else if (typeof object.Version === "object")
                    message.Version = new $util.LongBits(object.Version.low >>> 0, object.Version.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a LoginResponseMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.LoginResponseMsg
         * @static
         * @param {PropTradingProtocol.LoginResponseMsg} message LoginResponseMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoginResponseMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.Success = false;
                object.Reason = "";
                object.ReasonCode = options.enums === String ? "CREDENTIALS" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.Version = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Version = options.longs === String ? "0" : 0;
            }
            if (message.Success != null && message.hasOwnProperty("Success"))
                object.Success = message.Success;
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                object.Reason = message.Reason;
            if (message.ReasonCode != null && message.hasOwnProperty("ReasonCode"))
                object.ReasonCode = options.enums === String ? $root.PropTradingProtocol.LoginReasonsCodeEnum[message.ReasonCode] === undefined ? message.ReasonCode : $root.PropTradingProtocol.LoginReasonsCodeEnum[message.ReasonCode] : message.ReasonCode;
            if (message.Version != null && message.hasOwnProperty("Version"))
                if (typeof message.Version === "number")
                    object.Version = options.longs === String ? String(message.Version) : message.Version;
                else
                    object.Version = options.longs === String ? $util.Long.prototype.toString.call(message.Version) : options.longs === Number ? new $util.LongBits(message.Version.low >>> 0, message.Version.high >>> 0).toNumber() : message.Version;
            return object;
        };

        /**
         * Converts this LoginResponseMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.LoginResponseMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoginResponseMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LoginResponseMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.LoginResponseMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LoginResponseMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.LoginResponseMsg";
        };

        return LoginResponseMsg;
    })();

    PropTradingProtocol.LoggedOffMsg = (function() {

        /**
         * Properties of a LoggedOffMsg.
         * @memberof PropTradingProtocol
         * @interface ILoggedOffMsg
         * @property {string|null} [Reason] LoggedOffMsg Reason
         */

        /**
         * Constructs a new LoggedOffMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a LoggedOffMsg.
         * @implements ILoggedOffMsg
         * @constructor
         * @param {PropTradingProtocol.ILoggedOffMsg=} [properties] Properties to set
         */
        function LoggedOffMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoggedOffMsg Reason.
         * @member {string} Reason
         * @memberof PropTradingProtocol.LoggedOffMsg
         * @instance
         */
        LoggedOffMsg.prototype.Reason = "";

        /**
         * Creates a new LoggedOffMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.LoggedOffMsg
         * @static
         * @param {PropTradingProtocol.ILoggedOffMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.LoggedOffMsg} LoggedOffMsg instance
         */
        LoggedOffMsg.create = function create(properties) {
            return new LoggedOffMsg(properties);
        };

        /**
         * Encodes the specified LoggedOffMsg message. Does not implicitly {@link PropTradingProtocol.LoggedOffMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.LoggedOffMsg
         * @static
         * @param {PropTradingProtocol.ILoggedOffMsg} message LoggedOffMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoggedOffMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Reason != null && Object.hasOwnProperty.call(message, "Reason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Reason);
            return writer;
        };

        /**
         * Encodes the specified LoggedOffMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.LoggedOffMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.LoggedOffMsg
         * @static
         * @param {PropTradingProtocol.ILoggedOffMsg} message LoggedOffMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoggedOffMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoggedOffMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.LoggedOffMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.LoggedOffMsg} LoggedOffMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoggedOffMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.LoggedOffMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.Reason = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoggedOffMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.LoggedOffMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.LoggedOffMsg} LoggedOffMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoggedOffMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoggedOffMsg message.
         * @function verify
         * @memberof PropTradingProtocol.LoggedOffMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoggedOffMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                if (!$util.isString(message.Reason))
                    return "Reason: string expected";
            return null;
        };

        /**
         * Creates a LoggedOffMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.LoggedOffMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.LoggedOffMsg} LoggedOffMsg
         */
        LoggedOffMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.LoggedOffMsg)
                return object;
            let message = new $root.PropTradingProtocol.LoggedOffMsg();
            if (object.Reason != null)
                message.Reason = String(object.Reason);
            return message;
        };

        /**
         * Creates a plain object from a LoggedOffMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.LoggedOffMsg
         * @static
         * @param {PropTradingProtocol.LoggedOffMsg} message LoggedOffMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LoggedOffMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.Reason = "";
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                object.Reason = message.Reason;
            return object;
        };

        /**
         * Converts this LoggedOffMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.LoggedOffMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LoggedOffMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LoggedOffMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.LoggedOffMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LoggedOffMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.LoggedOffMsg";
        };

        return LoggedOffMsg;
    })();

    PropTradingProtocol.PingMsg = (function() {

        /**
         * Properties of a PingMsg.
         * @memberof PropTradingProtocol
         * @interface IPingMsg
         * @property {boolean|null} [Connected] PingMsg Connected
         * @property {number|Long|null} [AckValue] PingMsg AckValue
         */

        /**
         * Constructs a new PingMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a PingMsg.
         * @implements IPingMsg
         * @constructor
         * @param {PropTradingProtocol.IPingMsg=} [properties] Properties to set
         */
        function PingMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PingMsg Connected.
         * @member {boolean} Connected
         * @memberof PropTradingProtocol.PingMsg
         * @instance
         */
        PingMsg.prototype.Connected = false;

        /**
         * PingMsg AckValue.
         * @member {number|Long} AckValue
         * @memberof PropTradingProtocol.PingMsg
         * @instance
         */
        PingMsg.prototype.AckValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PingMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.PingMsg
         * @static
         * @param {PropTradingProtocol.IPingMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.PingMsg} PingMsg instance
         */
        PingMsg.create = function create(properties) {
            return new PingMsg(properties);
        };

        /**
         * Encodes the specified PingMsg message. Does not implicitly {@link PropTradingProtocol.PingMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.PingMsg
         * @static
         * @param {PropTradingProtocol.IPingMsg} message PingMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Connected != null && Object.hasOwnProperty.call(message, "Connected"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.Connected);
            if (message.AckValue != null && Object.hasOwnProperty.call(message, "AckValue"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AckValue);
            return writer;
        };

        /**
         * Encodes the specified PingMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.PingMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.PingMsg
         * @static
         * @param {PropTradingProtocol.IPingMsg} message PingMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PingMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PingMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.PingMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.PingMsg} PingMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.PingMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.Connected = reader.bool();
                        break;
                    }
                case 2: {
                        message.AckValue = reader.sint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PingMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.PingMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.PingMsg} PingMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PingMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PingMsg message.
         * @function verify
         * @memberof PropTradingProtocol.PingMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PingMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Connected != null && message.hasOwnProperty("Connected"))
                if (typeof message.Connected !== "boolean")
                    return "Connected: boolean expected";
            if (message.AckValue != null && message.hasOwnProperty("AckValue"))
                if (!$util.isInteger(message.AckValue) && !(message.AckValue && $util.isInteger(message.AckValue.low) && $util.isInteger(message.AckValue.high)))
                    return "AckValue: integer|Long expected";
            return null;
        };

        /**
         * Creates a PingMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.PingMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.PingMsg} PingMsg
         */
        PingMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.PingMsg)
                return object;
            let message = new $root.PropTradingProtocol.PingMsg();
            if (object.Connected != null)
                message.Connected = Boolean(object.Connected);
            if (object.AckValue != null)
                if ($util.Long)
                    (message.AckValue = $util.Long.fromValue(object.AckValue)).unsigned = false;
                else if (typeof object.AckValue === "string")
                    message.AckValue = parseInt(object.AckValue, 10);
                else if (typeof object.AckValue === "number")
                    message.AckValue = object.AckValue;
                else if (typeof object.AckValue === "object")
                    message.AckValue = new $util.LongBits(object.AckValue.low >>> 0, object.AckValue.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PingMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.PingMsg
         * @static
         * @param {PropTradingProtocol.PingMsg} message PingMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PingMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.Connected = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AckValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AckValue = options.longs === String ? "0" : 0;
            }
            if (message.Connected != null && message.hasOwnProperty("Connected"))
                object.Connected = message.Connected;
            if (message.AckValue != null && message.hasOwnProperty("AckValue"))
                if (typeof message.AckValue === "number")
                    object.AckValue = options.longs === String ? String(message.AckValue) : message.AckValue;
                else
                    object.AckValue = options.longs === String ? $util.Long.prototype.toString.call(message.AckValue) : options.longs === Number ? new $util.LongBits(message.AckValue.low >>> 0, message.AckValue.high >>> 0).toNumber() : message.AckValue;
            return object;
        };

        /**
         * Converts this PingMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.PingMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PingMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PingMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.PingMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PingMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.PingMsg";
        };

        return PingMsg;
    })();

    PropTradingProtocol.PongMsg = (function() {

        /**
         * Properties of a PongMsg.
         * @memberof PropTradingProtocol
         * @interface IPongMsg
         * @property {boolean|null} [Connected] PongMsg Connected
         * @property {number|Long|null} [AckValue] PongMsg AckValue
         */

        /**
         * Constructs a new PongMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a PongMsg.
         * @implements IPongMsg
         * @constructor
         * @param {PropTradingProtocol.IPongMsg=} [properties] Properties to set
         */
        function PongMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PongMsg Connected.
         * @member {boolean} Connected
         * @memberof PropTradingProtocol.PongMsg
         * @instance
         */
        PongMsg.prototype.Connected = false;

        /**
         * PongMsg AckValue.
         * @member {number|Long} AckValue
         * @memberof PropTradingProtocol.PongMsg
         * @instance
         */
        PongMsg.prototype.AckValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PongMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.PongMsg
         * @static
         * @param {PropTradingProtocol.IPongMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.PongMsg} PongMsg instance
         */
        PongMsg.create = function create(properties) {
            return new PongMsg(properties);
        };

        /**
         * Encodes the specified PongMsg message. Does not implicitly {@link PropTradingProtocol.PongMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.PongMsg
         * @static
         * @param {PropTradingProtocol.IPongMsg} message PongMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PongMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Connected != null && Object.hasOwnProperty.call(message, "Connected"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.Connected);
            if (message.AckValue != null && Object.hasOwnProperty.call(message, "AckValue"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AckValue);
            return writer;
        };

        /**
         * Encodes the specified PongMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.PongMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.PongMsg
         * @static
         * @param {PropTradingProtocol.IPongMsg} message PongMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PongMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PongMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.PongMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.PongMsg} PongMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PongMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.PongMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.Connected = reader.bool();
                        break;
                    }
                case 2: {
                        message.AckValue = reader.sint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PongMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.PongMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.PongMsg} PongMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PongMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PongMsg message.
         * @function verify
         * @memberof PropTradingProtocol.PongMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PongMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Connected != null && message.hasOwnProperty("Connected"))
                if (typeof message.Connected !== "boolean")
                    return "Connected: boolean expected";
            if (message.AckValue != null && message.hasOwnProperty("AckValue"))
                if (!$util.isInteger(message.AckValue) && !(message.AckValue && $util.isInteger(message.AckValue.low) && $util.isInteger(message.AckValue.high)))
                    return "AckValue: integer|Long expected";
            return null;
        };

        /**
         * Creates a PongMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.PongMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.PongMsg} PongMsg
         */
        PongMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.PongMsg)
                return object;
            let message = new $root.PropTradingProtocol.PongMsg();
            if (object.Connected != null)
                message.Connected = Boolean(object.Connected);
            if (object.AckValue != null)
                if ($util.Long)
                    (message.AckValue = $util.Long.fromValue(object.AckValue)).unsigned = false;
                else if (typeof object.AckValue === "string")
                    message.AckValue = parseInt(object.AckValue, 10);
                else if (typeof object.AckValue === "number")
                    message.AckValue = object.AckValue;
                else if (typeof object.AckValue === "object")
                    message.AckValue = new $util.LongBits(object.AckValue.low >>> 0, object.AckValue.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PongMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.PongMsg
         * @static
         * @param {PropTradingProtocol.PongMsg} message PongMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PongMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.Connected = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AckValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AckValue = options.longs === String ? "0" : 0;
            }
            if (message.Connected != null && message.hasOwnProperty("Connected"))
                object.Connected = message.Connected;
            if (message.AckValue != null && message.hasOwnProperty("AckValue"))
                if (typeof message.AckValue === "number")
                    object.AckValue = options.longs === String ? String(message.AckValue) : message.AckValue;
                else
                    object.AckValue = options.longs === String ? $util.Long.prototype.toString.call(message.AckValue) : options.longs === Number ? new $util.LongBits(message.AckValue.low >>> 0, message.AckValue.high >>> 0).toNumber() : message.AckValue;
            return object;
        };

        /**
         * Converts this PongMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.PongMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PongMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PongMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.PongMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PongMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.PongMsg";
        };

        return PongMsg;
    })();

    /**
     * SymbolCategoryEnum enum.
     * @name PropTradingProtocol.SymbolCategoryEnum
     * @enum {number}
     * @property {number} Future=1 Future value
     * @property {number} Forex=2 Forex value
     * @property {number} Index=3 Index value
     * @property {number} Option=4 Option value
     * @property {number} Stock=5 Stock value
     * @property {number} CryptoPerpetual=6 CryptoPerpetual value
     * @property {number} Spot=7 Spot value
     * @property {number} Etf=8 Etf value
     */
    PropTradingProtocol.SymbolCategoryEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "Future"] = 1;
        values[valuesById[2] = "Forex"] = 2;
        values[valuesById[3] = "Index"] = 3;
        values[valuesById[4] = "Option"] = 4;
        values[valuesById[5] = "Stock"] = 5;
        values[valuesById[6] = "CryptoPerpetual"] = 6;
        values[valuesById[7] = "Spot"] = 7;
        values[valuesById[8] = "Etf"] = 8;
        return values;
    })();

    /**
     * SymbolSpreadTypeEnum enum.
     * @name PropTradingProtocol.SymbolSpreadTypeEnum
     * @enum {number}
     * @property {number} Native=0 Native value
     * @property {number} BidDifference=1 BidDifference value
     * @property {number} AskDifference=2 AskDifference value
     * @property {number} PercentualSpread=3 PercentualSpread value
     */
    PropTradingProtocol.SymbolSpreadTypeEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Native"] = 0;
        values[valuesById[1] = "BidDifference"] = 1;
        values[valuesById[2] = "AskDifference"] = 2;
        values[valuesById[3] = "PercentualSpread"] = 3;
        return values;
    })();

    PropTradingProtocol.ContractRequestWrapperMsg = (function() {

        /**
         * Properties of a ContractRequestWrapperMsg.
         * @memberof PropTradingProtocol
         * @interface IContractRequestWrapperMsg
         * @property {number|Long|null} [RequestId] ContractRequestWrapperMsg RequestId
         * @property {Array.<PropTradingProtocol.IContractReqMsg>|null} [Contracts] ContractRequestWrapperMsg Contracts
         */

        /**
         * Constructs a new ContractRequestWrapperMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a ContractRequestWrapperMsg.
         * @implements IContractRequestWrapperMsg
         * @constructor
         * @param {PropTradingProtocol.IContractRequestWrapperMsg=} [properties] Properties to set
         */
        function ContractRequestWrapperMsg(properties) {
            this.Contracts = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContractRequestWrapperMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.ContractRequestWrapperMsg
         * @instance
         */
        ContractRequestWrapperMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractRequestWrapperMsg Contracts.
         * @member {Array.<PropTradingProtocol.IContractReqMsg>} Contracts
         * @memberof PropTradingProtocol.ContractRequestWrapperMsg
         * @instance
         */
        ContractRequestWrapperMsg.prototype.Contracts = $util.emptyArray;

        /**
         * Creates a new ContractRequestWrapperMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.ContractRequestWrapperMsg
         * @static
         * @param {PropTradingProtocol.IContractRequestWrapperMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.ContractRequestWrapperMsg} ContractRequestWrapperMsg instance
         */
        ContractRequestWrapperMsg.create = function create(properties) {
            return new ContractRequestWrapperMsg(properties);
        };

        /**
         * Encodes the specified ContractRequestWrapperMsg message. Does not implicitly {@link PropTradingProtocol.ContractRequestWrapperMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.ContractRequestWrapperMsg
         * @static
         * @param {PropTradingProtocol.IContractRequestWrapperMsg} message ContractRequestWrapperMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractRequestWrapperMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Contracts != null && message.Contracts.length)
                for (let i = 0; i < message.Contracts.length; ++i)
                    $root.PropTradingProtocol.ContractReqMsg.encode(message.Contracts[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ContractRequestWrapperMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.ContractRequestWrapperMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.ContractRequestWrapperMsg
         * @static
         * @param {PropTradingProtocol.IContractRequestWrapperMsg} message ContractRequestWrapperMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractRequestWrapperMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContractRequestWrapperMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.ContractRequestWrapperMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.ContractRequestWrapperMsg} ContractRequestWrapperMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractRequestWrapperMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.ContractRequestWrapperMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        if (!(message.Contracts && message.Contracts.length))
                            message.Contracts = [];
                        message.Contracts.push($root.PropTradingProtocol.ContractReqMsg.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContractRequestWrapperMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.ContractRequestWrapperMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.ContractRequestWrapperMsg} ContractRequestWrapperMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractRequestWrapperMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContractRequestWrapperMsg message.
         * @function verify
         * @memberof PropTradingProtocol.ContractRequestWrapperMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContractRequestWrapperMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Contracts != null && message.hasOwnProperty("Contracts")) {
                if (!Array.isArray(message.Contracts))
                    return "Contracts: array expected";
                for (let i = 0; i < message.Contracts.length; ++i) {
                    let error = $root.PropTradingProtocol.ContractReqMsg.verify(message.Contracts[i]);
                    if (error)
                        return "Contracts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ContractRequestWrapperMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.ContractRequestWrapperMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.ContractRequestWrapperMsg} ContractRequestWrapperMsg
         */
        ContractRequestWrapperMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.ContractRequestWrapperMsg)
                return object;
            let message = new $root.PropTradingProtocol.ContractRequestWrapperMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Contracts) {
                if (!Array.isArray(object.Contracts))
                    throw TypeError(".PropTradingProtocol.ContractRequestWrapperMsg.Contracts: array expected");
                message.Contracts = [];
                for (let i = 0; i < object.Contracts.length; ++i) {
                    if (typeof object.Contracts[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ContractRequestWrapperMsg.Contracts: object expected");
                    message.Contracts[i] = $root.PropTradingProtocol.ContractReqMsg.fromObject(object.Contracts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ContractRequestWrapperMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.ContractRequestWrapperMsg
         * @static
         * @param {PropTradingProtocol.ContractRequestWrapperMsg} message ContractRequestWrapperMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContractRequestWrapperMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.Contracts = [];
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Contracts && message.Contracts.length) {
                object.Contracts = [];
                for (let j = 0; j < message.Contracts.length; ++j)
                    object.Contracts[j] = $root.PropTradingProtocol.ContractReqMsg.toObject(message.Contracts[j], options);
            }
            return object;
        };

        /**
         * Converts this ContractRequestWrapperMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.ContractRequestWrapperMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContractRequestWrapperMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ContractRequestWrapperMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.ContractRequestWrapperMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractRequestWrapperMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.ContractRequestWrapperMsg";
        };

        return ContractRequestWrapperMsg;
    })();

    PropTradingProtocol.ContractReqMsg = (function() {

        /**
         * Properties of a ContractReqMsg.
         * @memberof PropTradingProtocol
         * @interface IContractReqMsg
         * @property {string|null} [FeedSymbol] ContractReqMsg FeedSymbol
         * @property {PropTradingProtocol.SymbolCategoryEnum|null} [Category] ContractReqMsg Category
         * @property {number|Long|null} [ContractId] ContractReqMsg ContractId
         * @property {string|null} [Isin] ContractReqMsg Isin
         * @property {number|Long|null} [RequestId] ContractReqMsg RequestId
         */

        /**
         * Constructs a new ContractReqMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a ContractReqMsg.
         * @implements IContractReqMsg
         * @constructor
         * @param {PropTradingProtocol.IContractReqMsg=} [properties] Properties to set
         */
        function ContractReqMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContractReqMsg FeedSymbol.
         * @member {string} FeedSymbol
         * @memberof PropTradingProtocol.ContractReqMsg
         * @instance
         */
        ContractReqMsg.prototype.FeedSymbol = "";

        /**
         * ContractReqMsg Category.
         * @member {PropTradingProtocol.SymbolCategoryEnum} Category
         * @memberof PropTradingProtocol.ContractReqMsg
         * @instance
         */
        ContractReqMsg.prototype.Category = 1;

        /**
         * ContractReqMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.ContractReqMsg
         * @instance
         */
        ContractReqMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractReqMsg Isin.
         * @member {string} Isin
         * @memberof PropTradingProtocol.ContractReqMsg
         * @instance
         */
        ContractReqMsg.prototype.Isin = "";

        /**
         * ContractReqMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.ContractReqMsg
         * @instance
         */
        ContractReqMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new ContractReqMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.ContractReqMsg
         * @static
         * @param {PropTradingProtocol.IContractReqMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.ContractReqMsg} ContractReqMsg instance
         */
        ContractReqMsg.create = function create(properties) {
            return new ContractReqMsg(properties);
        };

        /**
         * Encodes the specified ContractReqMsg message. Does not implicitly {@link PropTradingProtocol.ContractReqMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.ContractReqMsg
         * @static
         * @param {PropTradingProtocol.IContractReqMsg} message ContractReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractReqMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.FeedSymbol != null && Object.hasOwnProperty.call(message, "FeedSymbol"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.FeedSymbol);
            if (message.Category != null && Object.hasOwnProperty.call(message, "Category"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Category);
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint64(message.ContractId);
            if (message.Isin != null && Object.hasOwnProperty.call(message, "Isin"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.Isin);
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 5, wireType 0 =*/40).sint64(message.RequestId);
            return writer;
        };

        /**
         * Encodes the specified ContractReqMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.ContractReqMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.ContractReqMsg
         * @static
         * @param {PropTradingProtocol.IContractReqMsg} message ContractReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractReqMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContractReqMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.ContractReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.ContractReqMsg} ContractReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractReqMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.ContractReqMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.FeedSymbol = reader.string();
                        break;
                    }
                case 2: {
                        message.Category = reader.int32();
                        break;
                    }
                case 3: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 4: {
                        message.Isin = reader.string();
                        break;
                    }
                case 5: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContractReqMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.ContractReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.ContractReqMsg} ContractReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractReqMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContractReqMsg message.
         * @function verify
         * @memberof PropTradingProtocol.ContractReqMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContractReqMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                if (!$util.isString(message.FeedSymbol))
                    return "FeedSymbol: string expected";
            if (message.Category != null && message.hasOwnProperty("Category"))
                switch (message.Category) {
                default:
                    return "Category: enum value expected";
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.Isin != null && message.hasOwnProperty("Isin"))
                if (!$util.isString(message.Isin))
                    return "Isin: string expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            return null;
        };

        /**
         * Creates a ContractReqMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.ContractReqMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.ContractReqMsg} ContractReqMsg
         */
        ContractReqMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.ContractReqMsg)
                return object;
            let message = new $root.PropTradingProtocol.ContractReqMsg();
            if (object.FeedSymbol != null)
                message.FeedSymbol = String(object.FeedSymbol);
            switch (object.Category) {
            default:
                if (typeof object.Category === "number") {
                    message.Category = object.Category;
                    break;
                }
                break;
            case "Future":
            case 1:
                message.Category = 1;
                break;
            case "Forex":
            case 2:
                message.Category = 2;
                break;
            case "Index":
            case 3:
                message.Category = 3;
                break;
            case "Option":
            case 4:
                message.Category = 4;
                break;
            case "Stock":
            case 5:
                message.Category = 5;
                break;
            case "CryptoPerpetual":
            case 6:
                message.Category = 6;
                break;
            case "Spot":
            case 7:
                message.Category = 7;
                break;
            case "Etf":
            case 8:
                message.Category = 8;
                break;
            }
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.Isin != null)
                message.Isin = String(object.Isin);
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a ContractReqMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.ContractReqMsg
         * @static
         * @param {PropTradingProtocol.ContractReqMsg} message ContractReqMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContractReqMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.FeedSymbol = "";
                object.Category = options.enums === String ? "Future" : 1;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                object.Isin = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
            }
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                object.FeedSymbol = message.FeedSymbol;
            if (message.Category != null && message.hasOwnProperty("Category"))
                object.Category = options.enums === String ? $root.PropTradingProtocol.SymbolCategoryEnum[message.Category] === undefined ? message.Category : $root.PropTradingProtocol.SymbolCategoryEnum[message.Category] : message.Category;
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.Isin != null && message.hasOwnProperty("Isin"))
                object.Isin = message.Isin;
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            return object;
        };

        /**
         * Converts this ContractReqMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.ContractReqMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContractReqMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ContractReqMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.ContractReqMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractReqMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.ContractReqMsg";
        };

        return ContractReqMsg;
    })();

    PropTradingProtocol.ContractResponseWrapperMsg = (function() {

        /**
         * Properties of a ContractResponseWrapperMsg.
         * @memberof PropTradingProtocol
         * @interface IContractResponseWrapperMsg
         * @property {number|Long|null} [RequestId] ContractResponseWrapperMsg RequestId
         * @property {Array.<PropTradingProtocol.IContractRespMsg>|null} [Contracts] ContractResponseWrapperMsg Contracts
         */

        /**
         * Constructs a new ContractResponseWrapperMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a ContractResponseWrapperMsg.
         * @implements IContractResponseWrapperMsg
         * @constructor
         * @param {PropTradingProtocol.IContractResponseWrapperMsg=} [properties] Properties to set
         */
        function ContractResponseWrapperMsg(properties) {
            this.Contracts = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContractResponseWrapperMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.ContractResponseWrapperMsg
         * @instance
         */
        ContractResponseWrapperMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractResponseWrapperMsg Contracts.
         * @member {Array.<PropTradingProtocol.IContractRespMsg>} Contracts
         * @memberof PropTradingProtocol.ContractResponseWrapperMsg
         * @instance
         */
        ContractResponseWrapperMsg.prototype.Contracts = $util.emptyArray;

        /**
         * Creates a new ContractResponseWrapperMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.ContractResponseWrapperMsg
         * @static
         * @param {PropTradingProtocol.IContractResponseWrapperMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.ContractResponseWrapperMsg} ContractResponseWrapperMsg instance
         */
        ContractResponseWrapperMsg.create = function create(properties) {
            return new ContractResponseWrapperMsg(properties);
        };

        /**
         * Encodes the specified ContractResponseWrapperMsg message. Does not implicitly {@link PropTradingProtocol.ContractResponseWrapperMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.ContractResponseWrapperMsg
         * @static
         * @param {PropTradingProtocol.IContractResponseWrapperMsg} message ContractResponseWrapperMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractResponseWrapperMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Contracts != null && message.Contracts.length)
                for (let i = 0; i < message.Contracts.length; ++i)
                    $root.PropTradingProtocol.ContractRespMsg.encode(message.Contracts[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ContractResponseWrapperMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.ContractResponseWrapperMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.ContractResponseWrapperMsg
         * @static
         * @param {PropTradingProtocol.IContractResponseWrapperMsg} message ContractResponseWrapperMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractResponseWrapperMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContractResponseWrapperMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.ContractResponseWrapperMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.ContractResponseWrapperMsg} ContractResponseWrapperMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractResponseWrapperMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.ContractResponseWrapperMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        if (!(message.Contracts && message.Contracts.length))
                            message.Contracts = [];
                        message.Contracts.push($root.PropTradingProtocol.ContractRespMsg.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContractResponseWrapperMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.ContractResponseWrapperMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.ContractResponseWrapperMsg} ContractResponseWrapperMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractResponseWrapperMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContractResponseWrapperMsg message.
         * @function verify
         * @memberof PropTradingProtocol.ContractResponseWrapperMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContractResponseWrapperMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Contracts != null && message.hasOwnProperty("Contracts")) {
                if (!Array.isArray(message.Contracts))
                    return "Contracts: array expected";
                for (let i = 0; i < message.Contracts.length; ++i) {
                    let error = $root.PropTradingProtocol.ContractRespMsg.verify(message.Contracts[i]);
                    if (error)
                        return "Contracts." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ContractResponseWrapperMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.ContractResponseWrapperMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.ContractResponseWrapperMsg} ContractResponseWrapperMsg
         */
        ContractResponseWrapperMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.ContractResponseWrapperMsg)
                return object;
            let message = new $root.PropTradingProtocol.ContractResponseWrapperMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Contracts) {
                if (!Array.isArray(object.Contracts))
                    throw TypeError(".PropTradingProtocol.ContractResponseWrapperMsg.Contracts: array expected");
                message.Contracts = [];
                for (let i = 0; i < object.Contracts.length; ++i) {
                    if (typeof object.Contracts[i] !== "object")
                        throw TypeError(".PropTradingProtocol.ContractResponseWrapperMsg.Contracts: object expected");
                    message.Contracts[i] = $root.PropTradingProtocol.ContractRespMsg.fromObject(object.Contracts[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ContractResponseWrapperMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.ContractResponseWrapperMsg
         * @static
         * @param {PropTradingProtocol.ContractResponseWrapperMsg} message ContractResponseWrapperMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContractResponseWrapperMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.Contracts = [];
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Contracts && message.Contracts.length) {
                object.Contracts = [];
                for (let j = 0; j < message.Contracts.length; ++j)
                    object.Contracts[j] = $root.PropTradingProtocol.ContractRespMsg.toObject(message.Contracts[j], options);
            }
            return object;
        };

        /**
         * Converts this ContractResponseWrapperMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.ContractResponseWrapperMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContractResponseWrapperMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ContractResponseWrapperMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.ContractResponseWrapperMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractResponseWrapperMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.ContractResponseWrapperMsg";
        };

        return ContractResponseWrapperMsg;
    })();

    PropTradingProtocol.ContractRespMsg = (function() {

        /**
         * Properties of a ContractRespMsg.
         * @memberof PropTradingProtocol
         * @interface IContractRespMsg
         * @property {string|null} [FeedSymbol] ContractRespMsg FeedSymbol
         * @property {PropTradingProtocol.SymbolCategoryEnum|null} [Category] ContractRespMsg Category
         * @property {number|Long|null} [ContractId] ContractRespMsg ContractId
         * @property {PropTradingProtocol.IContractInfoMsg|null} [contractInfo] ContractRespMsg contractInfo
         * @property {number|Long|null} [RequestId] ContractRespMsg RequestId
         * @property {boolean|null} [IsFinal] ContractRespMsg IsFinal
         */

        /**
         * Constructs a new ContractRespMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a ContractRespMsg.
         * @implements IContractRespMsg
         * @constructor
         * @param {PropTradingProtocol.IContractRespMsg=} [properties] Properties to set
         */
        function ContractRespMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContractRespMsg FeedSymbol.
         * @member {string} FeedSymbol
         * @memberof PropTradingProtocol.ContractRespMsg
         * @instance
         */
        ContractRespMsg.prototype.FeedSymbol = "";

        /**
         * ContractRespMsg Category.
         * @member {PropTradingProtocol.SymbolCategoryEnum} Category
         * @memberof PropTradingProtocol.ContractRespMsg
         * @instance
         */
        ContractRespMsg.prototype.Category = 1;

        /**
         * ContractRespMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.ContractRespMsg
         * @instance
         */
        ContractRespMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractRespMsg contractInfo.
         * @member {PropTradingProtocol.IContractInfoMsg|null|undefined} contractInfo
         * @memberof PropTradingProtocol.ContractRespMsg
         * @instance
         */
        ContractRespMsg.prototype.contractInfo = null;

        /**
         * ContractRespMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.ContractRespMsg
         * @instance
         */
        ContractRespMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractRespMsg IsFinal.
         * @member {boolean} IsFinal
         * @memberof PropTradingProtocol.ContractRespMsg
         * @instance
         */
        ContractRespMsg.prototype.IsFinal = false;

        /**
         * Creates a new ContractRespMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.ContractRespMsg
         * @static
         * @param {PropTradingProtocol.IContractRespMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.ContractRespMsg} ContractRespMsg instance
         */
        ContractRespMsg.create = function create(properties) {
            return new ContractRespMsg(properties);
        };

        /**
         * Encodes the specified ContractRespMsg message. Does not implicitly {@link PropTradingProtocol.ContractRespMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.ContractRespMsg
         * @static
         * @param {PropTradingProtocol.IContractRespMsg} message ContractRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractRespMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.FeedSymbol != null && Object.hasOwnProperty.call(message, "FeedSymbol"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.FeedSymbol);
            if (message.Category != null && Object.hasOwnProperty.call(message, "Category"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Category);
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint64(message.ContractId);
            if (message.contractInfo != null && Object.hasOwnProperty.call(message, "contractInfo"))
                $root.PropTradingProtocol.ContractInfoMsg.encode(message.contractInfo, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 5, wireType 0 =*/40).sint64(message.RequestId);
            if (message.IsFinal != null && Object.hasOwnProperty.call(message, "IsFinal"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.IsFinal);
            return writer;
        };

        /**
         * Encodes the specified ContractRespMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.ContractRespMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.ContractRespMsg
         * @static
         * @param {PropTradingProtocol.IContractRespMsg} message ContractRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractRespMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContractRespMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.ContractRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.ContractRespMsg} ContractRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractRespMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.ContractRespMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.FeedSymbol = reader.string();
                        break;
                    }
                case 2: {
                        message.Category = reader.int32();
                        break;
                    }
                case 3: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 4: {
                        message.contractInfo = $root.PropTradingProtocol.ContractInfoMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 6: {
                        message.IsFinal = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContractRespMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.ContractRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.ContractRespMsg} ContractRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractRespMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContractRespMsg message.
         * @function verify
         * @memberof PropTradingProtocol.ContractRespMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContractRespMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                if (!$util.isString(message.FeedSymbol))
                    return "FeedSymbol: string expected";
            if (message.Category != null && message.hasOwnProperty("Category"))
                switch (message.Category) {
                default:
                    return "Category: enum value expected";
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.contractInfo != null && message.hasOwnProperty("contractInfo")) {
                let error = $root.PropTradingProtocol.ContractInfoMsg.verify(message.contractInfo);
                if (error)
                    return "contractInfo." + error;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.IsFinal != null && message.hasOwnProperty("IsFinal"))
                if (typeof message.IsFinal !== "boolean")
                    return "IsFinal: boolean expected";
            return null;
        };

        /**
         * Creates a ContractRespMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.ContractRespMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.ContractRespMsg} ContractRespMsg
         */
        ContractRespMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.ContractRespMsg)
                return object;
            let message = new $root.PropTradingProtocol.ContractRespMsg();
            if (object.FeedSymbol != null)
                message.FeedSymbol = String(object.FeedSymbol);
            switch (object.Category) {
            default:
                if (typeof object.Category === "number") {
                    message.Category = object.Category;
                    break;
                }
                break;
            case "Future":
            case 1:
                message.Category = 1;
                break;
            case "Forex":
            case 2:
                message.Category = 2;
                break;
            case "Index":
            case 3:
                message.Category = 3;
                break;
            case "Option":
            case 4:
                message.Category = 4;
                break;
            case "Stock":
            case 5:
                message.Category = 5;
                break;
            case "CryptoPerpetual":
            case 6:
                message.Category = 6;
                break;
            case "Spot":
            case 7:
                message.Category = 7;
                break;
            case "Etf":
            case 8:
                message.Category = 8;
                break;
            }
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.contractInfo != null) {
                if (typeof object.contractInfo !== "object")
                    throw TypeError(".PropTradingProtocol.ContractRespMsg.contractInfo: object expected");
                message.contractInfo = $root.PropTradingProtocol.ContractInfoMsg.fromObject(object.contractInfo);
            }
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.IsFinal != null)
                message.IsFinal = Boolean(object.IsFinal);
            return message;
        };

        /**
         * Creates a plain object from a ContractRespMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.ContractRespMsg
         * @static
         * @param {PropTradingProtocol.ContractRespMsg} message ContractRespMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContractRespMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.FeedSymbol = "";
                object.Category = options.enums === String ? "Future" : 1;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                object.contractInfo = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.IsFinal = false;
            }
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                object.FeedSymbol = message.FeedSymbol;
            if (message.Category != null && message.hasOwnProperty("Category"))
                object.Category = options.enums === String ? $root.PropTradingProtocol.SymbolCategoryEnum[message.Category] === undefined ? message.Category : $root.PropTradingProtocol.SymbolCategoryEnum[message.Category] : message.Category;
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.contractInfo != null && message.hasOwnProperty("contractInfo"))
                object.contractInfo = $root.PropTradingProtocol.ContractInfoMsg.toObject(message.contractInfo, options);
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.IsFinal != null && message.hasOwnProperty("IsFinal"))
                object.IsFinal = message.IsFinal;
            return object;
        };

        /**
         * Converts this ContractRespMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.ContractRespMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContractRespMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ContractRespMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.ContractRespMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractRespMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.ContractRespMsg";
        };

        return ContractRespMsg;
    })();

    PropTradingProtocol.ContractInfoMsg = (function() {

        /**
         * Properties of a ContractInfoMsg.
         * @memberof PropTradingProtocol
         * @interface IContractInfoMsg
         * @property {string|null} [ContractName] ContractInfoMsg ContractName
         * @property {string|null} [Symbol] ContractInfoMsg Symbol
         * @property {string|null} [Exchange] ContractInfoMsg Exchange
         * @property {string|null} [Description] ContractInfoMsg Description
         * @property {number|null} [TickSize] ContractInfoMsg TickSize
         * @property {number|null} [TickValue] ContractInfoMsg TickValue
         * @property {boolean|null} [IsStock] ContractInfoMsg IsStock
         * @property {string|null} [FeedSymbol] ContractInfoMsg FeedSymbol
         * @property {number|null} [TradableQuantityFractionable] ContractInfoMsg TradableQuantityFractionable
         * @property {number|null} [TradableQuantityMultiplier] ContractInfoMsg TradableQuantityMultiplier
         * @property {number|Long|null} [ContractId] ContractInfoMsg ContractId
         * @property {number|Long|null} [SymbolId] ContractInfoMsg SymbolId
         * @property {string|null} [QuoteCurrency] ContractInfoMsg QuoteCurrency
         * @property {string|null} [BaseCurrency] ContractInfoMsg BaseCurrency
         * @property {number|null} [TradableQuantityMinimum] ContractInfoMsg TradableQuantityMinimum
         * @property {number|null} [TradableQuantityMultiple] ContractInfoMsg TradableQuantityMultiple
         */

        /**
         * Constructs a new ContractInfoMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a ContractInfoMsg.
         * @implements IContractInfoMsg
         * @constructor
         * @param {PropTradingProtocol.IContractInfoMsg=} [properties] Properties to set
         */
        function ContractInfoMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContractInfoMsg ContractName.
         * @member {string} ContractName
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.ContractName = "";

        /**
         * ContractInfoMsg Symbol.
         * @member {string} Symbol
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.Symbol = "";

        /**
         * ContractInfoMsg Exchange.
         * @member {string} Exchange
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.Exchange = "";

        /**
         * ContractInfoMsg Description.
         * @member {string} Description
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.Description = "";

        /**
         * ContractInfoMsg TickSize.
         * @member {number} TickSize
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.TickSize = 0;

        /**
         * ContractInfoMsg TickValue.
         * @member {number} TickValue
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.TickValue = 0;

        /**
         * ContractInfoMsg IsStock.
         * @member {boolean} IsStock
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.IsStock = false;

        /**
         * ContractInfoMsg FeedSymbol.
         * @member {string} FeedSymbol
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.FeedSymbol = "";

        /**
         * ContractInfoMsg TradableQuantityFractionable.
         * @member {number} TradableQuantityFractionable
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.TradableQuantityFractionable = 0;

        /**
         * ContractInfoMsg TradableQuantityMultiplier.
         * @member {number} TradableQuantityMultiplier
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.TradableQuantityMultiplier = 0;

        /**
         * ContractInfoMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractInfoMsg SymbolId.
         * @member {number|Long} SymbolId
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.SymbolId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ContractInfoMsg QuoteCurrency.
         * @member {string} QuoteCurrency
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.QuoteCurrency = "";

        /**
         * ContractInfoMsg BaseCurrency.
         * @member {string} BaseCurrency
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.BaseCurrency = "";

        /**
         * ContractInfoMsg TradableQuantityMinimum.
         * @member {number} TradableQuantityMinimum
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.TradableQuantityMinimum = 0;

        /**
         * ContractInfoMsg TradableQuantityMultiple.
         * @member {number} TradableQuantityMultiple
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         */
        ContractInfoMsg.prototype.TradableQuantityMultiple = 0;

        /**
         * Creates a new ContractInfoMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @static
         * @param {PropTradingProtocol.IContractInfoMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.ContractInfoMsg} ContractInfoMsg instance
         */
        ContractInfoMsg.create = function create(properties) {
            return new ContractInfoMsg(properties);
        };

        /**
         * Encodes the specified ContractInfoMsg message. Does not implicitly {@link PropTradingProtocol.ContractInfoMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @static
         * @param {PropTradingProtocol.IContractInfoMsg} message ContractInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractInfoMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ContractName != null && Object.hasOwnProperty.call(message, "ContractName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ContractName);
            if (message.Symbol != null && Object.hasOwnProperty.call(message, "Symbol"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Symbol);
            if (message.Exchange != null && Object.hasOwnProperty.call(message, "Exchange"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Exchange);
            if (message.Description != null && Object.hasOwnProperty.call(message, "Description"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.Description);
            if (message.TickSize != null && Object.hasOwnProperty.call(message, "TickSize"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.TickSize);
            if (message.TickValue != null && Object.hasOwnProperty.call(message, "TickValue"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.TickValue);
            if (message.IsStock != null && Object.hasOwnProperty.call(message, "IsStock"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.IsStock);
            if (message.FeedSymbol != null && Object.hasOwnProperty.call(message, "FeedSymbol"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.FeedSymbol);
            if (message.TradableQuantityFractionable != null && Object.hasOwnProperty.call(message, "TradableQuantityFractionable"))
                writer.uint32(/* id 12, wireType 0 =*/96).sint32(message.TradableQuantityFractionable);
            if (message.TradableQuantityMultiplier != null && Object.hasOwnProperty.call(message, "TradableQuantityMultiplier"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.TradableQuantityMultiplier);
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 14, wireType 0 =*/112).sint64(message.ContractId);
            if (message.SymbolId != null && Object.hasOwnProperty.call(message, "SymbolId"))
                writer.uint32(/* id 15, wireType 0 =*/120).sint64(message.SymbolId);
            if (message.QuoteCurrency != null && Object.hasOwnProperty.call(message, "QuoteCurrency"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.QuoteCurrency);
            if (message.BaseCurrency != null && Object.hasOwnProperty.call(message, "BaseCurrency"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.BaseCurrency);
            if (message.TradableQuantityMinimum != null && Object.hasOwnProperty.call(message, "TradableQuantityMinimum"))
                writer.uint32(/* id 18, wireType 0 =*/144).sint32(message.TradableQuantityMinimum);
            if (message.TradableQuantityMultiple != null && Object.hasOwnProperty.call(message, "TradableQuantityMultiple"))
                writer.uint32(/* id 19, wireType 0 =*/152).sint32(message.TradableQuantityMultiple);
            return writer;
        };

        /**
         * Encodes the specified ContractInfoMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.ContractInfoMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @static
         * @param {PropTradingProtocol.IContractInfoMsg} message ContractInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContractInfoMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContractInfoMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.ContractInfoMsg} ContractInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractInfoMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.ContractInfoMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.ContractName = reader.string();
                        break;
                    }
                case 2: {
                        message.Symbol = reader.string();
                        break;
                    }
                case 3: {
                        message.Exchange = reader.string();
                        break;
                    }
                case 4: {
                        message.Description = reader.string();
                        break;
                    }
                case 5: {
                        message.TickSize = reader.double();
                        break;
                    }
                case 6: {
                        message.TickValue = reader.double();
                        break;
                    }
                case 10: {
                        message.IsStock = reader.bool();
                        break;
                    }
                case 11: {
                        message.FeedSymbol = reader.string();
                        break;
                    }
                case 12: {
                        message.TradableQuantityFractionable = reader.sint32();
                        break;
                    }
                case 13: {
                        message.TradableQuantityMultiplier = reader.double();
                        break;
                    }
                case 14: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 15: {
                        message.SymbolId = reader.sint64();
                        break;
                    }
                case 16: {
                        message.QuoteCurrency = reader.string();
                        break;
                    }
                case 17: {
                        message.BaseCurrency = reader.string();
                        break;
                    }
                case 18: {
                        message.TradableQuantityMinimum = reader.sint32();
                        break;
                    }
                case 19: {
                        message.TradableQuantityMultiple = reader.sint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContractInfoMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.ContractInfoMsg} ContractInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContractInfoMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContractInfoMsg message.
         * @function verify
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContractInfoMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ContractName != null && message.hasOwnProperty("ContractName"))
                if (!$util.isString(message.ContractName))
                    return "ContractName: string expected";
            if (message.Symbol != null && message.hasOwnProperty("Symbol"))
                if (!$util.isString(message.Symbol))
                    return "Symbol: string expected";
            if (message.Exchange != null && message.hasOwnProperty("Exchange"))
                if (!$util.isString(message.Exchange))
                    return "Exchange: string expected";
            if (message.Description != null && message.hasOwnProperty("Description"))
                if (!$util.isString(message.Description))
                    return "Description: string expected";
            if (message.TickSize != null && message.hasOwnProperty("TickSize"))
                if (typeof message.TickSize !== "number")
                    return "TickSize: number expected";
            if (message.TickValue != null && message.hasOwnProperty("TickValue"))
                if (typeof message.TickValue !== "number")
                    return "TickValue: number expected";
            if (message.IsStock != null && message.hasOwnProperty("IsStock"))
                if (typeof message.IsStock !== "boolean")
                    return "IsStock: boolean expected";
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                if (!$util.isString(message.FeedSymbol))
                    return "FeedSymbol: string expected";
            if (message.TradableQuantityFractionable != null && message.hasOwnProperty("TradableQuantityFractionable"))
                if (!$util.isInteger(message.TradableQuantityFractionable))
                    return "TradableQuantityFractionable: integer expected";
            if (message.TradableQuantityMultiplier != null && message.hasOwnProperty("TradableQuantityMultiplier"))
                if (typeof message.TradableQuantityMultiplier !== "number")
                    return "TradableQuantityMultiplier: number expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.SymbolId != null && message.hasOwnProperty("SymbolId"))
                if (!$util.isInteger(message.SymbolId) && !(message.SymbolId && $util.isInteger(message.SymbolId.low) && $util.isInteger(message.SymbolId.high)))
                    return "SymbolId: integer|Long expected";
            if (message.QuoteCurrency != null && message.hasOwnProperty("QuoteCurrency"))
                if (!$util.isString(message.QuoteCurrency))
                    return "QuoteCurrency: string expected";
            if (message.BaseCurrency != null && message.hasOwnProperty("BaseCurrency"))
                if (!$util.isString(message.BaseCurrency))
                    return "BaseCurrency: string expected";
            if (message.TradableQuantityMinimum != null && message.hasOwnProperty("TradableQuantityMinimum"))
                if (!$util.isInteger(message.TradableQuantityMinimum))
                    return "TradableQuantityMinimum: integer expected";
            if (message.TradableQuantityMultiple != null && message.hasOwnProperty("TradableQuantityMultiple"))
                if (!$util.isInteger(message.TradableQuantityMultiple))
                    return "TradableQuantityMultiple: integer expected";
            return null;
        };

        /**
         * Creates a ContractInfoMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.ContractInfoMsg} ContractInfoMsg
         */
        ContractInfoMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.ContractInfoMsg)
                return object;
            let message = new $root.PropTradingProtocol.ContractInfoMsg();
            if (object.ContractName != null)
                message.ContractName = String(object.ContractName);
            if (object.Symbol != null)
                message.Symbol = String(object.Symbol);
            if (object.Exchange != null)
                message.Exchange = String(object.Exchange);
            if (object.Description != null)
                message.Description = String(object.Description);
            if (object.TickSize != null)
                message.TickSize = Number(object.TickSize);
            if (object.TickValue != null)
                message.TickValue = Number(object.TickValue);
            if (object.IsStock != null)
                message.IsStock = Boolean(object.IsStock);
            if (object.FeedSymbol != null)
                message.FeedSymbol = String(object.FeedSymbol);
            if (object.TradableQuantityFractionable != null)
                message.TradableQuantityFractionable = object.TradableQuantityFractionable | 0;
            if (object.TradableQuantityMultiplier != null)
                message.TradableQuantityMultiplier = Number(object.TradableQuantityMultiplier);
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.SymbolId != null)
                if ($util.Long)
                    (message.SymbolId = $util.Long.fromValue(object.SymbolId)).unsigned = false;
                else if (typeof object.SymbolId === "string")
                    message.SymbolId = parseInt(object.SymbolId, 10);
                else if (typeof object.SymbolId === "number")
                    message.SymbolId = object.SymbolId;
                else if (typeof object.SymbolId === "object")
                    message.SymbolId = new $util.LongBits(object.SymbolId.low >>> 0, object.SymbolId.high >>> 0).toNumber();
            if (object.QuoteCurrency != null)
                message.QuoteCurrency = String(object.QuoteCurrency);
            if (object.BaseCurrency != null)
                message.BaseCurrency = String(object.BaseCurrency);
            if (object.TradableQuantityMinimum != null)
                message.TradableQuantityMinimum = object.TradableQuantityMinimum | 0;
            if (object.TradableQuantityMultiple != null)
                message.TradableQuantityMultiple = object.TradableQuantityMultiple | 0;
            return message;
        };

        /**
         * Creates a plain object from a ContractInfoMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @static
         * @param {PropTradingProtocol.ContractInfoMsg} message ContractInfoMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContractInfoMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.ContractName = "";
                object.Symbol = "";
                object.Exchange = "";
                object.Description = "";
                object.TickSize = 0;
                object.TickValue = 0;
                object.IsStock = false;
                object.FeedSymbol = "";
                object.TradableQuantityFractionable = 0;
                object.TradableQuantityMultiplier = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.SymbolId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.SymbolId = options.longs === String ? "0" : 0;
                object.QuoteCurrency = "";
                object.BaseCurrency = "";
                object.TradableQuantityMinimum = 0;
                object.TradableQuantityMultiple = 0;
            }
            if (message.ContractName != null && message.hasOwnProperty("ContractName"))
                object.ContractName = message.ContractName;
            if (message.Symbol != null && message.hasOwnProperty("Symbol"))
                object.Symbol = message.Symbol;
            if (message.Exchange != null && message.hasOwnProperty("Exchange"))
                object.Exchange = message.Exchange;
            if (message.Description != null && message.hasOwnProperty("Description"))
                object.Description = message.Description;
            if (message.TickSize != null && message.hasOwnProperty("TickSize"))
                object.TickSize = options.json && !isFinite(message.TickSize) ? String(message.TickSize) : message.TickSize;
            if (message.TickValue != null && message.hasOwnProperty("TickValue"))
                object.TickValue = options.json && !isFinite(message.TickValue) ? String(message.TickValue) : message.TickValue;
            if (message.IsStock != null && message.hasOwnProperty("IsStock"))
                object.IsStock = message.IsStock;
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                object.FeedSymbol = message.FeedSymbol;
            if (message.TradableQuantityFractionable != null && message.hasOwnProperty("TradableQuantityFractionable"))
                object.TradableQuantityFractionable = message.TradableQuantityFractionable;
            if (message.TradableQuantityMultiplier != null && message.hasOwnProperty("TradableQuantityMultiplier"))
                object.TradableQuantityMultiplier = options.json && !isFinite(message.TradableQuantityMultiplier) ? String(message.TradableQuantityMultiplier) : message.TradableQuantityMultiplier;
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.SymbolId != null && message.hasOwnProperty("SymbolId"))
                if (typeof message.SymbolId === "number")
                    object.SymbolId = options.longs === String ? String(message.SymbolId) : message.SymbolId;
                else
                    object.SymbolId = options.longs === String ? $util.Long.prototype.toString.call(message.SymbolId) : options.longs === Number ? new $util.LongBits(message.SymbolId.low >>> 0, message.SymbolId.high >>> 0).toNumber() : message.SymbolId;
            if (message.QuoteCurrency != null && message.hasOwnProperty("QuoteCurrency"))
                object.QuoteCurrency = message.QuoteCurrency;
            if (message.BaseCurrency != null && message.hasOwnProperty("BaseCurrency"))
                object.BaseCurrency = message.BaseCurrency;
            if (message.TradableQuantityMinimum != null && message.hasOwnProperty("TradableQuantityMinimum"))
                object.TradableQuantityMinimum = message.TradableQuantityMinimum;
            if (message.TradableQuantityMultiple != null && message.hasOwnProperty("TradableQuantityMultiple"))
                object.TradableQuantityMultiple = message.TradableQuantityMultiple;
            return object;
        };

        /**
         * Converts this ContractInfoMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContractInfoMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ContractInfoMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.ContractInfoMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContractInfoMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.ContractInfoMsg";
        };

        return ContractInfoMsg;
    })();

    PropTradingProtocol.AccountTradingSymbolMultiReqMsg = (function() {

        /**
         * Properties of an AccountTradingSymbolMultiReqMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountTradingSymbolMultiReqMsg
         * @property {number|Long|null} [RequestId] AccountTradingSymbolMultiReqMsg RequestId
         * @property {number|Long|null} [AccountId] AccountTradingSymbolMultiReqMsg AccountId
         * @property {Array.<PropTradingProtocol.ITradingSymbolParamReqMsg>|null} [Symbols] AccountTradingSymbolMultiReqMsg Symbols
         */

        /**
         * Constructs a new AccountTradingSymbolMultiReqMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountTradingSymbolMultiReqMsg.
         * @implements IAccountTradingSymbolMultiReqMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountTradingSymbolMultiReqMsg=} [properties] Properties to set
         */
        function AccountTradingSymbolMultiReqMsg(properties) {
            this.Symbols = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountTradingSymbolMultiReqMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiReqMsg
         * @instance
         */
        AccountTradingSymbolMultiReqMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountTradingSymbolMultiReqMsg AccountId.
         * @member {number|Long} AccountId
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiReqMsg
         * @instance
         */
        AccountTradingSymbolMultiReqMsg.prototype.AccountId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountTradingSymbolMultiReqMsg Symbols.
         * @member {Array.<PropTradingProtocol.ITradingSymbolParamReqMsg>} Symbols
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiReqMsg
         * @instance
         */
        AccountTradingSymbolMultiReqMsg.prototype.Symbols = $util.emptyArray;

        /**
         * Creates a new AccountTradingSymbolMultiReqMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountTradingSymbolMultiReqMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountTradingSymbolMultiReqMsg} AccountTradingSymbolMultiReqMsg instance
         */
        AccountTradingSymbolMultiReqMsg.create = function create(properties) {
            return new AccountTradingSymbolMultiReqMsg(properties);
        };

        /**
         * Encodes the specified AccountTradingSymbolMultiReqMsg message. Does not implicitly {@link PropTradingProtocol.AccountTradingSymbolMultiReqMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountTradingSymbolMultiReqMsg} message AccountTradingSymbolMultiReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountTradingSymbolMultiReqMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.AccountId != null && Object.hasOwnProperty.call(message, "AccountId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccountId);
            if (message.Symbols != null && message.Symbols.length)
                for (let i = 0; i < message.Symbols.length; ++i)
                    $root.PropTradingProtocol.TradingSymbolParamReqMsg.encode(message.Symbols[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccountTradingSymbolMultiReqMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountTradingSymbolMultiReqMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountTradingSymbolMultiReqMsg} message AccountTradingSymbolMultiReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountTradingSymbolMultiReqMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountTradingSymbolMultiReqMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountTradingSymbolMultiReqMsg} AccountTradingSymbolMultiReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountTradingSymbolMultiReqMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountTradingSymbolMultiReqMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.AccountId = reader.sint64();
                        break;
                    }
                case 3: {
                        if (!(message.Symbols && message.Symbols.length))
                            message.Symbols = [];
                        message.Symbols.push($root.PropTradingProtocol.TradingSymbolParamReqMsg.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountTradingSymbolMultiReqMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountTradingSymbolMultiReqMsg} AccountTradingSymbolMultiReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountTradingSymbolMultiReqMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountTradingSymbolMultiReqMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiReqMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountTradingSymbolMultiReqMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (!$util.isInteger(message.AccountId) && !(message.AccountId && $util.isInteger(message.AccountId.low) && $util.isInteger(message.AccountId.high)))
                    return "AccountId: integer|Long expected";
            if (message.Symbols != null && message.hasOwnProperty("Symbols")) {
                if (!Array.isArray(message.Symbols))
                    return "Symbols: array expected";
                for (let i = 0; i < message.Symbols.length; ++i) {
                    let error = $root.PropTradingProtocol.TradingSymbolParamReqMsg.verify(message.Symbols[i]);
                    if (error)
                        return "Symbols." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AccountTradingSymbolMultiReqMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiReqMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountTradingSymbolMultiReqMsg} AccountTradingSymbolMultiReqMsg
         */
        AccountTradingSymbolMultiReqMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountTradingSymbolMultiReqMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountTradingSymbolMultiReqMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.AccountId != null)
                if ($util.Long)
                    (message.AccountId = $util.Long.fromValue(object.AccountId)).unsigned = false;
                else if (typeof object.AccountId === "string")
                    message.AccountId = parseInt(object.AccountId, 10);
                else if (typeof object.AccountId === "number")
                    message.AccountId = object.AccountId;
                else if (typeof object.AccountId === "object")
                    message.AccountId = new $util.LongBits(object.AccountId.low >>> 0, object.AccountId.high >>> 0).toNumber();
            if (object.Symbols) {
                if (!Array.isArray(object.Symbols))
                    throw TypeError(".PropTradingProtocol.AccountTradingSymbolMultiReqMsg.Symbols: array expected");
                message.Symbols = [];
                for (let i = 0; i < object.Symbols.length; ++i) {
                    if (typeof object.Symbols[i] !== "object")
                        throw TypeError(".PropTradingProtocol.AccountTradingSymbolMultiReqMsg.Symbols: object expected");
                    message.Symbols[i] = $root.PropTradingProtocol.TradingSymbolParamReqMsg.fromObject(object.Symbols[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountTradingSymbolMultiReqMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiReqMsg
         * @static
         * @param {PropTradingProtocol.AccountTradingSymbolMultiReqMsg} message AccountTradingSymbolMultiReqMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountTradingSymbolMultiReqMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.Symbols = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccountId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccountId = options.longs === String ? "0" : 0;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (typeof message.AccountId === "number")
                    object.AccountId = options.longs === String ? String(message.AccountId) : message.AccountId;
                else
                    object.AccountId = options.longs === String ? $util.Long.prototype.toString.call(message.AccountId) : options.longs === Number ? new $util.LongBits(message.AccountId.low >>> 0, message.AccountId.high >>> 0).toNumber() : message.AccountId;
            if (message.Symbols && message.Symbols.length) {
                object.Symbols = [];
                for (let j = 0; j < message.Symbols.length; ++j)
                    object.Symbols[j] = $root.PropTradingProtocol.TradingSymbolParamReqMsg.toObject(message.Symbols[j], options);
            }
            return object;
        };

        /**
         * Converts this AccountTradingSymbolMultiReqMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiReqMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountTradingSymbolMultiReqMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountTradingSymbolMultiReqMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiReqMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountTradingSymbolMultiReqMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountTradingSymbolMultiReqMsg";
        };

        return AccountTradingSymbolMultiReqMsg;
    })();

    PropTradingProtocol.TradingSymbolParamReqMsg = (function() {

        /**
         * Properties of a TradingSymbolParamReqMsg.
         * @memberof PropTradingProtocol
         * @interface ITradingSymbolParamReqMsg
         * @property {string|null} [FeedSymbol] TradingSymbolParamReqMsg FeedSymbol
         * @property {number|Long|null} [ContractId] TradingSymbolParamReqMsg ContractId
         */

        /**
         * Constructs a new TradingSymbolParamReqMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a TradingSymbolParamReqMsg.
         * @implements ITradingSymbolParamReqMsg
         * @constructor
         * @param {PropTradingProtocol.ITradingSymbolParamReqMsg=} [properties] Properties to set
         */
        function TradingSymbolParamReqMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradingSymbolParamReqMsg FeedSymbol.
         * @member {string} FeedSymbol
         * @memberof PropTradingProtocol.TradingSymbolParamReqMsg
         * @instance
         */
        TradingSymbolParamReqMsg.prototype.FeedSymbol = "";

        /**
         * TradingSymbolParamReqMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.TradingSymbolParamReqMsg
         * @instance
         */
        TradingSymbolParamReqMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TradingSymbolParamReqMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.TradingSymbolParamReqMsg
         * @static
         * @param {PropTradingProtocol.ITradingSymbolParamReqMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.TradingSymbolParamReqMsg} TradingSymbolParamReqMsg instance
         */
        TradingSymbolParamReqMsg.create = function create(properties) {
            return new TradingSymbolParamReqMsg(properties);
        };

        /**
         * Encodes the specified TradingSymbolParamReqMsg message. Does not implicitly {@link PropTradingProtocol.TradingSymbolParamReqMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.TradingSymbolParamReqMsg
         * @static
         * @param {PropTradingProtocol.ITradingSymbolParamReqMsg} message TradingSymbolParamReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradingSymbolParamReqMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.FeedSymbol != null && Object.hasOwnProperty.call(message, "FeedSymbol"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.FeedSymbol);
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 4, wireType 0 =*/32).sint64(message.ContractId);
            return writer;
        };

        /**
         * Encodes the specified TradingSymbolParamReqMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.TradingSymbolParamReqMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.TradingSymbolParamReqMsg
         * @static
         * @param {PropTradingProtocol.ITradingSymbolParamReqMsg} message TradingSymbolParamReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradingSymbolParamReqMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradingSymbolParamReqMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.TradingSymbolParamReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.TradingSymbolParamReqMsg} TradingSymbolParamReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradingSymbolParamReqMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.TradingSymbolParamReqMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 3: {
                        message.FeedSymbol = reader.string();
                        break;
                    }
                case 4: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TradingSymbolParamReqMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.TradingSymbolParamReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.TradingSymbolParamReqMsg} TradingSymbolParamReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradingSymbolParamReqMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradingSymbolParamReqMsg message.
         * @function verify
         * @memberof PropTradingProtocol.TradingSymbolParamReqMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradingSymbolParamReqMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                if (!$util.isString(message.FeedSymbol))
                    return "FeedSymbol: string expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            return null;
        };

        /**
         * Creates a TradingSymbolParamReqMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.TradingSymbolParamReqMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.TradingSymbolParamReqMsg} TradingSymbolParamReqMsg
         */
        TradingSymbolParamReqMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.TradingSymbolParamReqMsg)
                return object;
            let message = new $root.PropTradingProtocol.TradingSymbolParamReqMsg();
            if (object.FeedSymbol != null)
                message.FeedSymbol = String(object.FeedSymbol);
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TradingSymbolParamReqMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.TradingSymbolParamReqMsg
         * @static
         * @param {PropTradingProtocol.TradingSymbolParamReqMsg} message TradingSymbolParamReqMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradingSymbolParamReqMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.FeedSymbol = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
            }
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                object.FeedSymbol = message.FeedSymbol;
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            return object;
        };

        /**
         * Converts this TradingSymbolParamReqMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.TradingSymbolParamReqMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradingSymbolParamReqMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TradingSymbolParamReqMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.TradingSymbolParamReqMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TradingSymbolParamReqMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.TradingSymbolParamReqMsg";
        };

        return TradingSymbolParamReqMsg;
    })();

    PropTradingProtocol.AccountTradingSymbolMultiRespMsg = (function() {

        /**
         * Properties of an AccountTradingSymbolMultiRespMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountTradingSymbolMultiRespMsg
         * @property {number|Long|null} [RequestId] AccountTradingSymbolMultiRespMsg RequestId
         * @property {boolean|null} [Success] AccountTradingSymbolMultiRespMsg Success
         * @property {string|null} [Reason] AccountTradingSymbolMultiRespMsg Reason
         * @property {Array.<PropTradingProtocol.IAccountTradingSymbolInfoMsg>|null} [Infos] AccountTradingSymbolMultiRespMsg Infos
         */

        /**
         * Constructs a new AccountTradingSymbolMultiRespMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountTradingSymbolMultiRespMsg.
         * @implements IAccountTradingSymbolMultiRespMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountTradingSymbolMultiRespMsg=} [properties] Properties to set
         */
        function AccountTradingSymbolMultiRespMsg(properties) {
            this.Infos = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountTradingSymbolMultiRespMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiRespMsg
         * @instance
         */
        AccountTradingSymbolMultiRespMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountTradingSymbolMultiRespMsg Success.
         * @member {boolean} Success
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiRespMsg
         * @instance
         */
        AccountTradingSymbolMultiRespMsg.prototype.Success = false;

        /**
         * AccountTradingSymbolMultiRespMsg Reason.
         * @member {string} Reason
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiRespMsg
         * @instance
         */
        AccountTradingSymbolMultiRespMsg.prototype.Reason = "";

        /**
         * AccountTradingSymbolMultiRespMsg Infos.
         * @member {Array.<PropTradingProtocol.IAccountTradingSymbolInfoMsg>} Infos
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiRespMsg
         * @instance
         */
        AccountTradingSymbolMultiRespMsg.prototype.Infos = $util.emptyArray;

        /**
         * Creates a new AccountTradingSymbolMultiRespMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountTradingSymbolMultiRespMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountTradingSymbolMultiRespMsg} AccountTradingSymbolMultiRespMsg instance
         */
        AccountTradingSymbolMultiRespMsg.create = function create(properties) {
            return new AccountTradingSymbolMultiRespMsg(properties);
        };

        /**
         * Encodes the specified AccountTradingSymbolMultiRespMsg message. Does not implicitly {@link PropTradingProtocol.AccountTradingSymbolMultiRespMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountTradingSymbolMultiRespMsg} message AccountTradingSymbolMultiRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountTradingSymbolMultiRespMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Success != null && Object.hasOwnProperty.call(message, "Success"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.Success);
            if (message.Reason != null && Object.hasOwnProperty.call(message, "Reason"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Reason);
            if (message.Infos != null && message.Infos.length)
                for (let i = 0; i < message.Infos.length; ++i)
                    $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.encode(message.Infos[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccountTradingSymbolMultiRespMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountTradingSymbolMultiRespMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountTradingSymbolMultiRespMsg} message AccountTradingSymbolMultiRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountTradingSymbolMultiRespMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountTradingSymbolMultiRespMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountTradingSymbolMultiRespMsg} AccountTradingSymbolMultiRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountTradingSymbolMultiRespMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountTradingSymbolMultiRespMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.Success = reader.bool();
                        break;
                    }
                case 3: {
                        message.Reason = reader.string();
                        break;
                    }
                case 4: {
                        if (!(message.Infos && message.Infos.length))
                            message.Infos = [];
                        message.Infos.push($root.PropTradingProtocol.AccountTradingSymbolInfoMsg.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountTradingSymbolMultiRespMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountTradingSymbolMultiRespMsg} AccountTradingSymbolMultiRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountTradingSymbolMultiRespMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountTradingSymbolMultiRespMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiRespMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountTradingSymbolMultiRespMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Success != null && message.hasOwnProperty("Success"))
                if (typeof message.Success !== "boolean")
                    return "Success: boolean expected";
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                if (!$util.isString(message.Reason))
                    return "Reason: string expected";
            if (message.Infos != null && message.hasOwnProperty("Infos")) {
                if (!Array.isArray(message.Infos))
                    return "Infos: array expected";
                for (let i = 0; i < message.Infos.length; ++i) {
                    let error = $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.verify(message.Infos[i]);
                    if (error)
                        return "Infos." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AccountTradingSymbolMultiRespMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiRespMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountTradingSymbolMultiRespMsg} AccountTradingSymbolMultiRespMsg
         */
        AccountTradingSymbolMultiRespMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountTradingSymbolMultiRespMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountTradingSymbolMultiRespMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Success != null)
                message.Success = Boolean(object.Success);
            if (object.Reason != null)
                message.Reason = String(object.Reason);
            if (object.Infos) {
                if (!Array.isArray(object.Infos))
                    throw TypeError(".PropTradingProtocol.AccountTradingSymbolMultiRespMsg.Infos: array expected");
                message.Infos = [];
                for (let i = 0; i < object.Infos.length; ++i) {
                    if (typeof object.Infos[i] !== "object")
                        throw TypeError(".PropTradingProtocol.AccountTradingSymbolMultiRespMsg.Infos: object expected");
                    message.Infos[i] = $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.fromObject(object.Infos[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountTradingSymbolMultiRespMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiRespMsg
         * @static
         * @param {PropTradingProtocol.AccountTradingSymbolMultiRespMsg} message AccountTradingSymbolMultiRespMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountTradingSymbolMultiRespMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.Infos = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.Success = false;
                object.Reason = "";
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Success != null && message.hasOwnProperty("Success"))
                object.Success = message.Success;
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                object.Reason = message.Reason;
            if (message.Infos && message.Infos.length) {
                object.Infos = [];
                for (let j = 0; j < message.Infos.length; ++j)
                    object.Infos[j] = $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.toObject(message.Infos[j], options);
            }
            return object;
        };

        /**
         * Converts this AccountTradingSymbolMultiRespMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiRespMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountTradingSymbolMultiRespMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountTradingSymbolMultiRespMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountTradingSymbolMultiRespMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountTradingSymbolMultiRespMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountTradingSymbolMultiRespMsg";
        };

        return AccountTradingSymbolMultiRespMsg;
    })();

    PropTradingProtocol.AccountTradingSymbolInfoReqMsg = (function() {

        /**
         * Properties of an AccountTradingSymbolInfoReqMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountTradingSymbolInfoReqMsg
         * @property {number|Long|null} [RequestId] AccountTradingSymbolInfoReqMsg RequestId
         * @property {number|Long|null} [AccountId] AccountTradingSymbolInfoReqMsg AccountId
         * @property {string|null} [FeedSymbol] AccountTradingSymbolInfoReqMsg FeedSymbol
         * @property {number|Long|null} [ContractId] AccountTradingSymbolInfoReqMsg ContractId
         */

        /**
         * Constructs a new AccountTradingSymbolInfoReqMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountTradingSymbolInfoReqMsg.
         * @implements IAccountTradingSymbolInfoReqMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountTradingSymbolInfoReqMsg=} [properties] Properties to set
         */
        function AccountTradingSymbolInfoReqMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountTradingSymbolInfoReqMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoReqMsg
         * @instance
         */
        AccountTradingSymbolInfoReqMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountTradingSymbolInfoReqMsg AccountId.
         * @member {number|Long} AccountId
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoReqMsg
         * @instance
         */
        AccountTradingSymbolInfoReqMsg.prototype.AccountId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountTradingSymbolInfoReqMsg FeedSymbol.
         * @member {string} FeedSymbol
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoReqMsg
         * @instance
         */
        AccountTradingSymbolInfoReqMsg.prototype.FeedSymbol = "";

        /**
         * AccountTradingSymbolInfoReqMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoReqMsg
         * @instance
         */
        AccountTradingSymbolInfoReqMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AccountTradingSymbolInfoReqMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountTradingSymbolInfoReqMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountTradingSymbolInfoReqMsg} AccountTradingSymbolInfoReqMsg instance
         */
        AccountTradingSymbolInfoReqMsg.create = function create(properties) {
            return new AccountTradingSymbolInfoReqMsg(properties);
        };

        /**
         * Encodes the specified AccountTradingSymbolInfoReqMsg message. Does not implicitly {@link PropTradingProtocol.AccountTradingSymbolInfoReqMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountTradingSymbolInfoReqMsg} message AccountTradingSymbolInfoReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountTradingSymbolInfoReqMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.AccountId != null && Object.hasOwnProperty.call(message, "AccountId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccountId);
            if (message.FeedSymbol != null && Object.hasOwnProperty.call(message, "FeedSymbol"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.FeedSymbol);
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 4, wireType 0 =*/32).sint64(message.ContractId);
            return writer;
        };

        /**
         * Encodes the specified AccountTradingSymbolInfoReqMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountTradingSymbolInfoReqMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountTradingSymbolInfoReqMsg} message AccountTradingSymbolInfoReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountTradingSymbolInfoReqMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountTradingSymbolInfoReqMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountTradingSymbolInfoReqMsg} AccountTradingSymbolInfoReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountTradingSymbolInfoReqMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountTradingSymbolInfoReqMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.AccountId = reader.sint64();
                        break;
                    }
                case 3: {
                        message.FeedSymbol = reader.string();
                        break;
                    }
                case 4: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountTradingSymbolInfoReqMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountTradingSymbolInfoReqMsg} AccountTradingSymbolInfoReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountTradingSymbolInfoReqMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountTradingSymbolInfoReqMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoReqMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountTradingSymbolInfoReqMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (!$util.isInteger(message.AccountId) && !(message.AccountId && $util.isInteger(message.AccountId.low) && $util.isInteger(message.AccountId.high)))
                    return "AccountId: integer|Long expected";
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                if (!$util.isString(message.FeedSymbol))
                    return "FeedSymbol: string expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            return null;
        };

        /**
         * Creates an AccountTradingSymbolInfoReqMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoReqMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountTradingSymbolInfoReqMsg} AccountTradingSymbolInfoReqMsg
         */
        AccountTradingSymbolInfoReqMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountTradingSymbolInfoReqMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountTradingSymbolInfoReqMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.AccountId != null)
                if ($util.Long)
                    (message.AccountId = $util.Long.fromValue(object.AccountId)).unsigned = false;
                else if (typeof object.AccountId === "string")
                    message.AccountId = parseInt(object.AccountId, 10);
                else if (typeof object.AccountId === "number")
                    message.AccountId = object.AccountId;
                else if (typeof object.AccountId === "object")
                    message.AccountId = new $util.LongBits(object.AccountId.low >>> 0, object.AccountId.high >>> 0).toNumber();
            if (object.FeedSymbol != null)
                message.FeedSymbol = String(object.FeedSymbol);
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an AccountTradingSymbolInfoReqMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoReqMsg
         * @static
         * @param {PropTradingProtocol.AccountTradingSymbolInfoReqMsg} message AccountTradingSymbolInfoReqMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountTradingSymbolInfoReqMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccountId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccountId = options.longs === String ? "0" : 0;
                object.FeedSymbol = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (typeof message.AccountId === "number")
                    object.AccountId = options.longs === String ? String(message.AccountId) : message.AccountId;
                else
                    object.AccountId = options.longs === String ? $util.Long.prototype.toString.call(message.AccountId) : options.longs === Number ? new $util.LongBits(message.AccountId.low >>> 0, message.AccountId.high >>> 0).toNumber() : message.AccountId;
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                object.FeedSymbol = message.FeedSymbol;
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            return object;
        };

        /**
         * Converts this AccountTradingSymbolInfoReqMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoReqMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountTradingSymbolInfoReqMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountTradingSymbolInfoReqMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoReqMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountTradingSymbolInfoReqMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountTradingSymbolInfoReqMsg";
        };

        return AccountTradingSymbolInfoReqMsg;
    })();

    PropTradingProtocol.AccountTradingSymbolInfoRespMsg = (function() {

        /**
         * Properties of an AccountTradingSymbolInfoRespMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountTradingSymbolInfoRespMsg
         * @property {number|Long|null} [RequestId] AccountTradingSymbolInfoRespMsg RequestId
         * @property {boolean|null} [Success] AccountTradingSymbolInfoRespMsg Success
         * @property {string|null} [Reason] AccountTradingSymbolInfoRespMsg Reason
         * @property {PropTradingProtocol.IAccountTradingSymbolInfoMsg|null} [Info] AccountTradingSymbolInfoRespMsg Info
         */

        /**
         * Constructs a new AccountTradingSymbolInfoRespMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountTradingSymbolInfoRespMsg.
         * @implements IAccountTradingSymbolInfoRespMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountTradingSymbolInfoRespMsg=} [properties] Properties to set
         */
        function AccountTradingSymbolInfoRespMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountTradingSymbolInfoRespMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoRespMsg
         * @instance
         */
        AccountTradingSymbolInfoRespMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountTradingSymbolInfoRespMsg Success.
         * @member {boolean} Success
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoRespMsg
         * @instance
         */
        AccountTradingSymbolInfoRespMsg.prototype.Success = false;

        /**
         * AccountTradingSymbolInfoRespMsg Reason.
         * @member {string} Reason
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoRespMsg
         * @instance
         */
        AccountTradingSymbolInfoRespMsg.prototype.Reason = "";

        /**
         * AccountTradingSymbolInfoRespMsg Info.
         * @member {PropTradingProtocol.IAccountTradingSymbolInfoMsg|null|undefined} Info
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoRespMsg
         * @instance
         */
        AccountTradingSymbolInfoRespMsg.prototype.Info = null;

        /**
         * Creates a new AccountTradingSymbolInfoRespMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountTradingSymbolInfoRespMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountTradingSymbolInfoRespMsg} AccountTradingSymbolInfoRespMsg instance
         */
        AccountTradingSymbolInfoRespMsg.create = function create(properties) {
            return new AccountTradingSymbolInfoRespMsg(properties);
        };

        /**
         * Encodes the specified AccountTradingSymbolInfoRespMsg message. Does not implicitly {@link PropTradingProtocol.AccountTradingSymbolInfoRespMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountTradingSymbolInfoRespMsg} message AccountTradingSymbolInfoRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountTradingSymbolInfoRespMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Success != null && Object.hasOwnProperty.call(message, "Success"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.Success);
            if (message.Reason != null && Object.hasOwnProperty.call(message, "Reason"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Reason);
            if (message.Info != null && Object.hasOwnProperty.call(message, "Info"))
                $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.encode(message.Info, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccountTradingSymbolInfoRespMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountTradingSymbolInfoRespMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountTradingSymbolInfoRespMsg} message AccountTradingSymbolInfoRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountTradingSymbolInfoRespMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountTradingSymbolInfoRespMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountTradingSymbolInfoRespMsg} AccountTradingSymbolInfoRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountTradingSymbolInfoRespMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountTradingSymbolInfoRespMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.Success = reader.bool();
                        break;
                    }
                case 3: {
                        message.Reason = reader.string();
                        break;
                    }
                case 4: {
                        message.Info = $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountTradingSymbolInfoRespMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountTradingSymbolInfoRespMsg} AccountTradingSymbolInfoRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountTradingSymbolInfoRespMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountTradingSymbolInfoRespMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoRespMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountTradingSymbolInfoRespMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Success != null && message.hasOwnProperty("Success"))
                if (typeof message.Success !== "boolean")
                    return "Success: boolean expected";
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                if (!$util.isString(message.Reason))
                    return "Reason: string expected";
            if (message.Info != null && message.hasOwnProperty("Info")) {
                let error = $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.verify(message.Info);
                if (error)
                    return "Info." + error;
            }
            return null;
        };

        /**
         * Creates an AccountTradingSymbolInfoRespMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoRespMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountTradingSymbolInfoRespMsg} AccountTradingSymbolInfoRespMsg
         */
        AccountTradingSymbolInfoRespMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountTradingSymbolInfoRespMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountTradingSymbolInfoRespMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Success != null)
                message.Success = Boolean(object.Success);
            if (object.Reason != null)
                message.Reason = String(object.Reason);
            if (object.Info != null) {
                if (typeof object.Info !== "object")
                    throw TypeError(".PropTradingProtocol.AccountTradingSymbolInfoRespMsg.Info: object expected");
                message.Info = $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.fromObject(object.Info);
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountTradingSymbolInfoRespMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoRespMsg
         * @static
         * @param {PropTradingProtocol.AccountTradingSymbolInfoRespMsg} message AccountTradingSymbolInfoRespMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountTradingSymbolInfoRespMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.Success = false;
                object.Reason = "";
                object.Info = null;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Success != null && message.hasOwnProperty("Success"))
                object.Success = message.Success;
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                object.Reason = message.Reason;
            if (message.Info != null && message.hasOwnProperty("Info"))
                object.Info = $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.toObject(message.Info, options);
            return object;
        };

        /**
         * Converts this AccountTradingSymbolInfoRespMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoRespMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountTradingSymbolInfoRespMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountTradingSymbolInfoRespMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoRespMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountTradingSymbolInfoRespMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountTradingSymbolInfoRespMsg";
        };

        return AccountTradingSymbolInfoRespMsg;
    })();

    PropTradingProtocol.AccountTradingSymbolInfoMsg = (function() {

        /**
         * Properties of an AccountTradingSymbolInfoMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountTradingSymbolInfoMsg
         * @property {number|Long|null} [AccountId] AccountTradingSymbolInfoMsg AccountId
         * @property {number|Long|null} [SymbolId] AccountTradingSymbolInfoMsg SymbolId
         * @property {number|null} [Commissions] AccountTradingSymbolInfoMsg Commissions
         * @property {number|null} [Margin] AccountTradingSymbolInfoMsg Margin
         * @property {number|null} [Leverage] AccountTradingSymbolInfoMsg Leverage
         * @property {PropTradingProtocol.SymbolSpreadTypeEnum|null} [SpreadType] AccountTradingSymbolInfoMsg SpreadType
         * @property {number|null} [SpreadTickValue] AccountTradingSymbolInfoMsg SpreadTickValue
         * @property {number|null} [TradableQuantityFractionable] AccountTradingSymbolInfoMsg TradableQuantityFractionable
         * @property {number|null} [TradableQuantityMultiplier] AccountTradingSymbolInfoMsg TradableQuantityMultiplier
         * @property {string|null} [QuoteCurrency] AccountTradingSymbolInfoMsg QuoteCurrency
         * @property {string|null} [BaseCurrency] AccountTradingSymbolInfoMsg BaseCurrency
         * @property {number|Long|null} [ContractId] AccountTradingSymbolInfoMsg ContractId
         * @property {string|null} [FeedSymbol] AccountTradingSymbolInfoMsg FeedSymbol
         */

        /**
         * Constructs a new AccountTradingSymbolInfoMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountTradingSymbolInfoMsg.
         * @implements IAccountTradingSymbolInfoMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountTradingSymbolInfoMsg=} [properties] Properties to set
         */
        function AccountTradingSymbolInfoMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountTradingSymbolInfoMsg AccountId.
         * @member {number|Long} AccountId
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @instance
         */
        AccountTradingSymbolInfoMsg.prototype.AccountId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountTradingSymbolInfoMsg SymbolId.
         * @member {number|Long} SymbolId
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @instance
         */
        AccountTradingSymbolInfoMsg.prototype.SymbolId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountTradingSymbolInfoMsg Commissions.
         * @member {number} Commissions
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @instance
         */
        AccountTradingSymbolInfoMsg.prototype.Commissions = 0;

        /**
         * AccountTradingSymbolInfoMsg Margin.
         * @member {number} Margin
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @instance
         */
        AccountTradingSymbolInfoMsg.prototype.Margin = 0;

        /**
         * AccountTradingSymbolInfoMsg Leverage.
         * @member {number} Leverage
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @instance
         */
        AccountTradingSymbolInfoMsg.prototype.Leverage = 0;

        /**
         * AccountTradingSymbolInfoMsg SpreadType.
         * @member {PropTradingProtocol.SymbolSpreadTypeEnum} SpreadType
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @instance
         */
        AccountTradingSymbolInfoMsg.prototype.SpreadType = 0;

        /**
         * AccountTradingSymbolInfoMsg SpreadTickValue.
         * @member {number} SpreadTickValue
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @instance
         */
        AccountTradingSymbolInfoMsg.prototype.SpreadTickValue = 0;

        /**
         * AccountTradingSymbolInfoMsg TradableQuantityFractionable.
         * @member {number} TradableQuantityFractionable
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @instance
         */
        AccountTradingSymbolInfoMsg.prototype.TradableQuantityFractionable = 0;

        /**
         * AccountTradingSymbolInfoMsg TradableQuantityMultiplier.
         * @member {number} TradableQuantityMultiplier
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @instance
         */
        AccountTradingSymbolInfoMsg.prototype.TradableQuantityMultiplier = 0;

        /**
         * AccountTradingSymbolInfoMsg QuoteCurrency.
         * @member {string} QuoteCurrency
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @instance
         */
        AccountTradingSymbolInfoMsg.prototype.QuoteCurrency = "";

        /**
         * AccountTradingSymbolInfoMsg BaseCurrency.
         * @member {string} BaseCurrency
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @instance
         */
        AccountTradingSymbolInfoMsg.prototype.BaseCurrency = "";

        /**
         * AccountTradingSymbolInfoMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @instance
         */
        AccountTradingSymbolInfoMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountTradingSymbolInfoMsg FeedSymbol.
         * @member {string} FeedSymbol
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @instance
         */
        AccountTradingSymbolInfoMsg.prototype.FeedSymbol = "";

        /**
         * Creates a new AccountTradingSymbolInfoMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @static
         * @param {PropTradingProtocol.IAccountTradingSymbolInfoMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountTradingSymbolInfoMsg} AccountTradingSymbolInfoMsg instance
         */
        AccountTradingSymbolInfoMsg.create = function create(properties) {
            return new AccountTradingSymbolInfoMsg(properties);
        };

        /**
         * Encodes the specified AccountTradingSymbolInfoMsg message. Does not implicitly {@link PropTradingProtocol.AccountTradingSymbolInfoMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @static
         * @param {PropTradingProtocol.IAccountTradingSymbolInfoMsg} message AccountTradingSymbolInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountTradingSymbolInfoMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AccountId != null && Object.hasOwnProperty.call(message, "AccountId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.AccountId);
            if (message.SymbolId != null && Object.hasOwnProperty.call(message, "SymbolId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.SymbolId);
            if (message.Commissions != null && Object.hasOwnProperty.call(message, "Commissions"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.Commissions);
            if (message.Margin != null && Object.hasOwnProperty.call(message, "Margin"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.Margin);
            if (message.Leverage != null && Object.hasOwnProperty.call(message, "Leverage"))
                writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.Leverage);
            if (message.SpreadType != null && Object.hasOwnProperty.call(message, "SpreadType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.SpreadType);
            if (message.SpreadTickValue != null && Object.hasOwnProperty.call(message, "SpreadTickValue"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.SpreadTickValue);
            if (message.TradableQuantityFractionable != null && Object.hasOwnProperty.call(message, "TradableQuantityFractionable"))
                writer.uint32(/* id 8, wireType 0 =*/64).sint32(message.TradableQuantityFractionable);
            if (message.TradableQuantityMultiplier != null && Object.hasOwnProperty.call(message, "TradableQuantityMultiplier"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.TradableQuantityMultiplier);
            if (message.QuoteCurrency != null && Object.hasOwnProperty.call(message, "QuoteCurrency"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.QuoteCurrency);
            if (message.BaseCurrency != null && Object.hasOwnProperty.call(message, "BaseCurrency"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.BaseCurrency);
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 12, wireType 0 =*/96).sint64(message.ContractId);
            if (message.FeedSymbol != null && Object.hasOwnProperty.call(message, "FeedSymbol"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.FeedSymbol);
            return writer;
        };

        /**
         * Encodes the specified AccountTradingSymbolInfoMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountTradingSymbolInfoMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @static
         * @param {PropTradingProtocol.IAccountTradingSymbolInfoMsg} message AccountTradingSymbolInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountTradingSymbolInfoMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountTradingSymbolInfoMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountTradingSymbolInfoMsg} AccountTradingSymbolInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountTradingSymbolInfoMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountTradingSymbolInfoMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.AccountId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.SymbolId = reader.sint64();
                        break;
                    }
                case 3: {
                        message.Commissions = reader.double();
                        break;
                    }
                case 4: {
                        message.Margin = reader.double();
                        break;
                    }
                case 5: {
                        message.Leverage = reader.sint32();
                        break;
                    }
                case 6: {
                        message.SpreadType = reader.int32();
                        break;
                    }
                case 7: {
                        message.SpreadTickValue = reader.int32();
                        break;
                    }
                case 8: {
                        message.TradableQuantityFractionable = reader.sint32();
                        break;
                    }
                case 9: {
                        message.TradableQuantityMultiplier = reader.double();
                        break;
                    }
                case 10: {
                        message.QuoteCurrency = reader.string();
                        break;
                    }
                case 11: {
                        message.BaseCurrency = reader.string();
                        break;
                    }
                case 12: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 13: {
                        message.FeedSymbol = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountTradingSymbolInfoMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountTradingSymbolInfoMsg} AccountTradingSymbolInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountTradingSymbolInfoMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountTradingSymbolInfoMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountTradingSymbolInfoMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (!$util.isInteger(message.AccountId) && !(message.AccountId && $util.isInteger(message.AccountId.low) && $util.isInteger(message.AccountId.high)))
                    return "AccountId: integer|Long expected";
            if (message.SymbolId != null && message.hasOwnProperty("SymbolId"))
                if (!$util.isInteger(message.SymbolId) && !(message.SymbolId && $util.isInteger(message.SymbolId.low) && $util.isInteger(message.SymbolId.high)))
                    return "SymbolId: integer|Long expected";
            if (message.Commissions != null && message.hasOwnProperty("Commissions"))
                if (typeof message.Commissions !== "number")
                    return "Commissions: number expected";
            if (message.Margin != null && message.hasOwnProperty("Margin"))
                if (typeof message.Margin !== "number")
                    return "Margin: number expected";
            if (message.Leverage != null && message.hasOwnProperty("Leverage"))
                if (!$util.isInteger(message.Leverage))
                    return "Leverage: integer expected";
            if (message.SpreadType != null && message.hasOwnProperty("SpreadType"))
                switch (message.SpreadType) {
                default:
                    return "SpreadType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.SpreadTickValue != null && message.hasOwnProperty("SpreadTickValue"))
                if (!$util.isInteger(message.SpreadTickValue))
                    return "SpreadTickValue: integer expected";
            if (message.TradableQuantityFractionable != null && message.hasOwnProperty("TradableQuantityFractionable"))
                if (!$util.isInteger(message.TradableQuantityFractionable))
                    return "TradableQuantityFractionable: integer expected";
            if (message.TradableQuantityMultiplier != null && message.hasOwnProperty("TradableQuantityMultiplier"))
                if (typeof message.TradableQuantityMultiplier !== "number")
                    return "TradableQuantityMultiplier: number expected";
            if (message.QuoteCurrency != null && message.hasOwnProperty("QuoteCurrency"))
                if (!$util.isString(message.QuoteCurrency))
                    return "QuoteCurrency: string expected";
            if (message.BaseCurrency != null && message.hasOwnProperty("BaseCurrency"))
                if (!$util.isString(message.BaseCurrency))
                    return "BaseCurrency: string expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                if (!$util.isString(message.FeedSymbol))
                    return "FeedSymbol: string expected";
            return null;
        };

        /**
         * Creates an AccountTradingSymbolInfoMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountTradingSymbolInfoMsg} AccountTradingSymbolInfoMsg
         */
        AccountTradingSymbolInfoMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountTradingSymbolInfoMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountTradingSymbolInfoMsg();
            if (object.AccountId != null)
                if ($util.Long)
                    (message.AccountId = $util.Long.fromValue(object.AccountId)).unsigned = false;
                else if (typeof object.AccountId === "string")
                    message.AccountId = parseInt(object.AccountId, 10);
                else if (typeof object.AccountId === "number")
                    message.AccountId = object.AccountId;
                else if (typeof object.AccountId === "object")
                    message.AccountId = new $util.LongBits(object.AccountId.low >>> 0, object.AccountId.high >>> 0).toNumber();
            if (object.SymbolId != null)
                if ($util.Long)
                    (message.SymbolId = $util.Long.fromValue(object.SymbolId)).unsigned = false;
                else if (typeof object.SymbolId === "string")
                    message.SymbolId = parseInt(object.SymbolId, 10);
                else if (typeof object.SymbolId === "number")
                    message.SymbolId = object.SymbolId;
                else if (typeof object.SymbolId === "object")
                    message.SymbolId = new $util.LongBits(object.SymbolId.low >>> 0, object.SymbolId.high >>> 0).toNumber();
            if (object.Commissions != null)
                message.Commissions = Number(object.Commissions);
            if (object.Margin != null)
                message.Margin = Number(object.Margin);
            if (object.Leverage != null)
                message.Leverage = object.Leverage | 0;
            switch (object.SpreadType) {
            default:
                if (typeof object.SpreadType === "number") {
                    message.SpreadType = object.SpreadType;
                    break;
                }
                break;
            case "Native":
            case 0:
                message.SpreadType = 0;
                break;
            case "BidDifference":
            case 1:
                message.SpreadType = 1;
                break;
            case "AskDifference":
            case 2:
                message.SpreadType = 2;
                break;
            case "PercentualSpread":
            case 3:
                message.SpreadType = 3;
                break;
            }
            if (object.SpreadTickValue != null)
                message.SpreadTickValue = object.SpreadTickValue | 0;
            if (object.TradableQuantityFractionable != null)
                message.TradableQuantityFractionable = object.TradableQuantityFractionable | 0;
            if (object.TradableQuantityMultiplier != null)
                message.TradableQuantityMultiplier = Number(object.TradableQuantityMultiplier);
            if (object.QuoteCurrency != null)
                message.QuoteCurrency = String(object.QuoteCurrency);
            if (object.BaseCurrency != null)
                message.BaseCurrency = String(object.BaseCurrency);
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.FeedSymbol != null)
                message.FeedSymbol = String(object.FeedSymbol);
            return message;
        };

        /**
         * Creates a plain object from an AccountTradingSymbolInfoMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @static
         * @param {PropTradingProtocol.AccountTradingSymbolInfoMsg} message AccountTradingSymbolInfoMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountTradingSymbolInfoMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccountId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccountId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.SymbolId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.SymbolId = options.longs === String ? "0" : 0;
                object.Commissions = 0;
                object.Margin = 0;
                object.Leverage = 0;
                object.SpreadType = options.enums === String ? "Native" : 0;
                object.SpreadTickValue = 0;
                object.TradableQuantityFractionable = 0;
                object.TradableQuantityMultiplier = 0;
                object.QuoteCurrency = "";
                object.BaseCurrency = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                object.FeedSymbol = "";
            }
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (typeof message.AccountId === "number")
                    object.AccountId = options.longs === String ? String(message.AccountId) : message.AccountId;
                else
                    object.AccountId = options.longs === String ? $util.Long.prototype.toString.call(message.AccountId) : options.longs === Number ? new $util.LongBits(message.AccountId.low >>> 0, message.AccountId.high >>> 0).toNumber() : message.AccountId;
            if (message.SymbolId != null && message.hasOwnProperty("SymbolId"))
                if (typeof message.SymbolId === "number")
                    object.SymbolId = options.longs === String ? String(message.SymbolId) : message.SymbolId;
                else
                    object.SymbolId = options.longs === String ? $util.Long.prototype.toString.call(message.SymbolId) : options.longs === Number ? new $util.LongBits(message.SymbolId.low >>> 0, message.SymbolId.high >>> 0).toNumber() : message.SymbolId;
            if (message.Commissions != null && message.hasOwnProperty("Commissions"))
                object.Commissions = options.json && !isFinite(message.Commissions) ? String(message.Commissions) : message.Commissions;
            if (message.Margin != null && message.hasOwnProperty("Margin"))
                object.Margin = options.json && !isFinite(message.Margin) ? String(message.Margin) : message.Margin;
            if (message.Leverage != null && message.hasOwnProperty("Leverage"))
                object.Leverage = message.Leverage;
            if (message.SpreadType != null && message.hasOwnProperty("SpreadType"))
                object.SpreadType = options.enums === String ? $root.PropTradingProtocol.SymbolSpreadTypeEnum[message.SpreadType] === undefined ? message.SpreadType : $root.PropTradingProtocol.SymbolSpreadTypeEnum[message.SpreadType] : message.SpreadType;
            if (message.SpreadTickValue != null && message.hasOwnProperty("SpreadTickValue"))
                object.SpreadTickValue = message.SpreadTickValue;
            if (message.TradableQuantityFractionable != null && message.hasOwnProperty("TradableQuantityFractionable"))
                object.TradableQuantityFractionable = message.TradableQuantityFractionable;
            if (message.TradableQuantityMultiplier != null && message.hasOwnProperty("TradableQuantityMultiplier"))
                object.TradableQuantityMultiplier = options.json && !isFinite(message.TradableQuantityMultiplier) ? String(message.TradableQuantityMultiplier) : message.TradableQuantityMultiplier;
            if (message.QuoteCurrency != null && message.hasOwnProperty("QuoteCurrency"))
                object.QuoteCurrency = message.QuoteCurrency;
            if (message.BaseCurrency != null && message.hasOwnProperty("BaseCurrency"))
                object.BaseCurrency = message.BaseCurrency;
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                object.FeedSymbol = message.FeedSymbol;
            return object;
        };

        /**
         * Converts this AccountTradingSymbolInfoMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountTradingSymbolInfoMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountTradingSymbolInfoMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountTradingSymbolInfoMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountTradingSymbolInfoMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountTradingSymbolInfoMsg";
        };

        return AccountTradingSymbolInfoMsg;
    })();

    PropTradingProtocol.DailyPlReqMsg = (function() {

        /**
         * Properties of a DailyPlReqMsg.
         * @memberof PropTradingProtocol
         * @interface IDailyPlReqMsg
         * @property {number|Long|null} [ContractId] DailyPlReqMsg ContractId
         * @property {number|Long|null} [AccNumber] DailyPlReqMsg AccNumber
         * @property {number|Long|null} [RequestId] DailyPlReqMsg RequestId
         */

        /**
         * Constructs a new DailyPlReqMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a DailyPlReqMsg.
         * @implements IDailyPlReqMsg
         * @constructor
         * @param {PropTradingProtocol.IDailyPlReqMsg=} [properties] Properties to set
         */
        function DailyPlReqMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DailyPlReqMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.DailyPlReqMsg
         * @instance
         */
        DailyPlReqMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DailyPlReqMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.DailyPlReqMsg
         * @instance
         */
        DailyPlReqMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DailyPlReqMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.DailyPlReqMsg
         * @instance
         */
        DailyPlReqMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DailyPlReqMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.DailyPlReqMsg
         * @static
         * @param {PropTradingProtocol.IDailyPlReqMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.DailyPlReqMsg} DailyPlReqMsg instance
         */
        DailyPlReqMsg.create = function create(properties) {
            return new DailyPlReqMsg(properties);
        };

        /**
         * Encodes the specified DailyPlReqMsg message. Does not implicitly {@link PropTradingProtocol.DailyPlReqMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.DailyPlReqMsg
         * @static
         * @param {PropTradingProtocol.IDailyPlReqMsg} message DailyPlReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DailyPlReqMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.ContractId);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccNumber);
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint64(message.RequestId);
            return writer;
        };

        /**
         * Encodes the specified DailyPlReqMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.DailyPlReqMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.DailyPlReqMsg
         * @static
         * @param {PropTradingProtocol.IDailyPlReqMsg} message DailyPlReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DailyPlReqMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DailyPlReqMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.DailyPlReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.DailyPlReqMsg} DailyPlReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DailyPlReqMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.DailyPlReqMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 3: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DailyPlReqMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.DailyPlReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.DailyPlReqMsg} DailyPlReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DailyPlReqMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DailyPlReqMsg message.
         * @function verify
         * @memberof PropTradingProtocol.DailyPlReqMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DailyPlReqMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            return null;
        };

        /**
         * Creates a DailyPlReqMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.DailyPlReqMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.DailyPlReqMsg} DailyPlReqMsg
         */
        DailyPlReqMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.DailyPlReqMsg)
                return object;
            let message = new $root.PropTradingProtocol.DailyPlReqMsg();
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a DailyPlReqMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.DailyPlReqMsg
         * @static
         * @param {PropTradingProtocol.DailyPlReqMsg} message DailyPlReqMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DailyPlReqMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
            }
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            return object;
        };

        /**
         * Converts this DailyPlReqMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.DailyPlReqMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DailyPlReqMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DailyPlReqMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.DailyPlReqMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DailyPlReqMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.DailyPlReqMsg";
        };

        return DailyPlReqMsg;
    })();

    PropTradingProtocol.DailyPlRespMsg = (function() {

        /**
         * Properties of a DailyPlRespMsg.
         * @memberof PropTradingProtocol
         * @interface IDailyPlRespMsg
         * @property {number|Long|null} [ContractId] DailyPlRespMsg ContractId
         * @property {number|Long|null} [AccNumber] DailyPlRespMsg AccNumber
         * @property {number|null} [DailyPl] DailyPlRespMsg DailyPl
         * @property {string|null} [FeedSymbol] DailyPlRespMsg FeedSymbol
         * @property {number|Long|null} [RequestId] DailyPlRespMsg RequestId
         * @property {number|null} [DailyNetPl] DailyPlRespMsg DailyNetPl
         * @property {string|null} [Isin] DailyPlRespMsg Isin
         * @property {number|null} [ConvertedDailyPl] DailyPlRespMsg ConvertedDailyPl
         * @property {number|null} [ConvertedDailyNetPl] DailyPlRespMsg ConvertedDailyNetPl
         */

        /**
         * Constructs a new DailyPlRespMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a DailyPlRespMsg.
         * @implements IDailyPlRespMsg
         * @constructor
         * @param {PropTradingProtocol.IDailyPlRespMsg=} [properties] Properties to set
         */
        function DailyPlRespMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DailyPlRespMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @instance
         */
        DailyPlRespMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DailyPlRespMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @instance
         */
        DailyPlRespMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DailyPlRespMsg DailyPl.
         * @member {number} DailyPl
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @instance
         */
        DailyPlRespMsg.prototype.DailyPl = 0;

        /**
         * DailyPlRespMsg FeedSymbol.
         * @member {string} FeedSymbol
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @instance
         */
        DailyPlRespMsg.prototype.FeedSymbol = "";

        /**
         * DailyPlRespMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @instance
         */
        DailyPlRespMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * DailyPlRespMsg DailyNetPl.
         * @member {number} DailyNetPl
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @instance
         */
        DailyPlRespMsg.prototype.DailyNetPl = 0;

        /**
         * DailyPlRespMsg Isin.
         * @member {string} Isin
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @instance
         */
        DailyPlRespMsg.prototype.Isin = "";

        /**
         * DailyPlRespMsg ConvertedDailyPl.
         * @member {number} ConvertedDailyPl
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @instance
         */
        DailyPlRespMsg.prototype.ConvertedDailyPl = 0;

        /**
         * DailyPlRespMsg ConvertedDailyNetPl.
         * @member {number} ConvertedDailyNetPl
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @instance
         */
        DailyPlRespMsg.prototype.ConvertedDailyNetPl = 0;

        /**
         * Creates a new DailyPlRespMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @static
         * @param {PropTradingProtocol.IDailyPlRespMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.DailyPlRespMsg} DailyPlRespMsg instance
         */
        DailyPlRespMsg.create = function create(properties) {
            return new DailyPlRespMsg(properties);
        };

        /**
         * Encodes the specified DailyPlRespMsg message. Does not implicitly {@link PropTradingProtocol.DailyPlRespMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @static
         * @param {PropTradingProtocol.IDailyPlRespMsg} message DailyPlRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DailyPlRespMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.ContractId);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccNumber);
            if (message.DailyPl != null && Object.hasOwnProperty.call(message, "DailyPl"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.DailyPl);
            if (message.FeedSymbol != null && Object.hasOwnProperty.call(message, "FeedSymbol"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.FeedSymbol);
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 5, wireType 0 =*/40).sint64(message.RequestId);
            if (message.DailyNetPl != null && Object.hasOwnProperty.call(message, "DailyNetPl"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.DailyNetPl);
            if (message.Isin != null && Object.hasOwnProperty.call(message, "Isin"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.Isin);
            if (message.ConvertedDailyPl != null && Object.hasOwnProperty.call(message, "ConvertedDailyPl"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.ConvertedDailyPl);
            if (message.ConvertedDailyNetPl != null && Object.hasOwnProperty.call(message, "ConvertedDailyNetPl"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.ConvertedDailyNetPl);
            return writer;
        };

        /**
         * Encodes the specified DailyPlRespMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.DailyPlRespMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @static
         * @param {PropTradingProtocol.IDailyPlRespMsg} message DailyPlRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DailyPlRespMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DailyPlRespMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.DailyPlRespMsg} DailyPlRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DailyPlRespMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.DailyPlRespMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 3: {
                        message.DailyPl = reader.double();
                        break;
                    }
                case 4: {
                        message.FeedSymbol = reader.string();
                        break;
                    }
                case 5: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 6: {
                        message.DailyNetPl = reader.double();
                        break;
                    }
                case 7: {
                        message.Isin = reader.string();
                        break;
                    }
                case 8: {
                        message.ConvertedDailyPl = reader.double();
                        break;
                    }
                case 9: {
                        message.ConvertedDailyNetPl = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DailyPlRespMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.DailyPlRespMsg} DailyPlRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DailyPlRespMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DailyPlRespMsg message.
         * @function verify
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DailyPlRespMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.DailyPl != null && message.hasOwnProperty("DailyPl"))
                if (typeof message.DailyPl !== "number")
                    return "DailyPl: number expected";
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                if (!$util.isString(message.FeedSymbol))
                    return "FeedSymbol: string expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.DailyNetPl != null && message.hasOwnProperty("DailyNetPl"))
                if (typeof message.DailyNetPl !== "number")
                    return "DailyNetPl: number expected";
            if (message.Isin != null && message.hasOwnProperty("Isin"))
                if (!$util.isString(message.Isin))
                    return "Isin: string expected";
            if (message.ConvertedDailyPl != null && message.hasOwnProperty("ConvertedDailyPl"))
                if (typeof message.ConvertedDailyPl !== "number")
                    return "ConvertedDailyPl: number expected";
            if (message.ConvertedDailyNetPl != null && message.hasOwnProperty("ConvertedDailyNetPl"))
                if (typeof message.ConvertedDailyNetPl !== "number")
                    return "ConvertedDailyNetPl: number expected";
            return null;
        };

        /**
         * Creates a DailyPlRespMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.DailyPlRespMsg} DailyPlRespMsg
         */
        DailyPlRespMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.DailyPlRespMsg)
                return object;
            let message = new $root.PropTradingProtocol.DailyPlRespMsg();
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            if (object.DailyPl != null)
                message.DailyPl = Number(object.DailyPl);
            if (object.FeedSymbol != null)
                message.FeedSymbol = String(object.FeedSymbol);
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.DailyNetPl != null)
                message.DailyNetPl = Number(object.DailyNetPl);
            if (object.Isin != null)
                message.Isin = String(object.Isin);
            if (object.ConvertedDailyPl != null)
                message.ConvertedDailyPl = Number(object.ConvertedDailyPl);
            if (object.ConvertedDailyNetPl != null)
                message.ConvertedDailyNetPl = Number(object.ConvertedDailyNetPl);
            return message;
        };

        /**
         * Creates a plain object from a DailyPlRespMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @static
         * @param {PropTradingProtocol.DailyPlRespMsg} message DailyPlRespMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DailyPlRespMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                object.DailyPl = 0;
                object.FeedSymbol = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.DailyNetPl = 0;
                object.Isin = "";
                object.ConvertedDailyPl = 0;
                object.ConvertedDailyNetPl = 0;
            }
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.DailyPl != null && message.hasOwnProperty("DailyPl"))
                object.DailyPl = options.json && !isFinite(message.DailyPl) ? String(message.DailyPl) : message.DailyPl;
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                object.FeedSymbol = message.FeedSymbol;
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.DailyNetPl != null && message.hasOwnProperty("DailyNetPl"))
                object.DailyNetPl = options.json && !isFinite(message.DailyNetPl) ? String(message.DailyNetPl) : message.DailyNetPl;
            if (message.Isin != null && message.hasOwnProperty("Isin"))
                object.Isin = message.Isin;
            if (message.ConvertedDailyPl != null && message.hasOwnProperty("ConvertedDailyPl"))
                object.ConvertedDailyPl = options.json && !isFinite(message.ConvertedDailyPl) ? String(message.ConvertedDailyPl) : message.ConvertedDailyPl;
            if (message.ConvertedDailyNetPl != null && message.hasOwnProperty("ConvertedDailyNetPl"))
                object.ConvertedDailyNetPl = options.json && !isFinite(message.ConvertedDailyNetPl) ? String(message.ConvertedDailyNetPl) : message.ConvertedDailyNetPl;
            return object;
        };

        /**
         * Converts this DailyPlRespMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DailyPlRespMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DailyPlRespMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.DailyPlRespMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DailyPlRespMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.DailyPlRespMsg";
        };

        return DailyPlRespMsg;
    })();

    /**
     * InfoModeEnum enum.
     * @name PropTradingProtocol.InfoModeEnum
     * @enum {number}
     * @property {number} Account=1 Account value
     * @property {number} OrdAndPos=2 OrdAndPos value
     * @property {number} Positions=3 Positions value
     * @property {number} AccountTradingSymbols=4 AccountTradingSymbols value
     */
    PropTradingProtocol.InfoModeEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "Account"] = 1;
        values[valuesById[2] = "OrdAndPos"] = 2;
        values[valuesById[3] = "Positions"] = 3;
        values[valuesById[4] = "AccountTradingSymbols"] = 4;
        return values;
    })();

    /**
     * AccountModeEnum enum.
     * @name PropTradingProtocol.AccountModeEnum
     * @enum {number}
     * @property {number} EVALUATION=0 EVALUATION value
     * @property {number} SIM_FUNDED=1 SIM_FUNDED value
     * @property {number} FUNDED=2 FUNDED value
     * @property {number} LIVE=3 LIVE value
     * @property {number} TRIAL=4 TRIAL value
     * @property {number} CONTEST=5 CONTEST value
     * @property {number} TRAINING=100 TRAINING value
     */
    PropTradingProtocol.AccountModeEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EVALUATION"] = 0;
        values[valuesById[1] = "SIM_FUNDED"] = 1;
        values[valuesById[2] = "FUNDED"] = 2;
        values[valuesById[3] = "LIVE"] = 3;
        values[valuesById[4] = "TRIAL"] = 4;
        values[valuesById[5] = "CONTEST"] = 5;
        values[valuesById[100] = "TRAINING"] = 100;
        return values;
    })();

    /**
     * AccountStatusEnum enum.
     * @name PropTradingProtocol.AccountStatusEnum
     * @enum {number}
     * @property {number} ALL=-1 ALL value
     * @property {number} INITIALIZED=0 INITIALIZED value
     * @property {number} ENABLED=1 ENABLED value
     * @property {number} SUCCESS=2 SUCCESS value
     * @property {number} FAILED=4 FAILED value
     * @property {number} DISABLED=8 DISABLED value
     */
    PropTradingProtocol.AccountStatusEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[-1] = "ALL"] = -1;
        values[valuesById[0] = "INITIALIZED"] = 0;
        values[valuesById[1] = "ENABLED"] = 1;
        values[valuesById[2] = "SUCCESS"] = 2;
        values[valuesById[4] = "FAILED"] = 4;
        values[valuesById[8] = "DISABLED"] = 8;
        return values;
    })();

    /**
     * AccountPermissionEnum enum.
     * @name PropTradingProtocol.AccountPermissionEnum
     * @enum {number}
     * @property {number} Trading=0 Trading value
     * @property {number} ReadOnly=1 ReadOnly value
     * @property {number} RiskPause=2 RiskPause value
     * @property {number} LiquidateOnly=3 LiquidateOnly value
     */
    PropTradingProtocol.AccountPermissionEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Trading"] = 0;
        values[valuesById[1] = "ReadOnly"] = 1;
        values[valuesById[2] = "RiskPause"] = 2;
        values[valuesById[3] = "LiquidateOnly"] = 3;
        return values;
    })();

    PropTradingProtocol.InfoReqMsg = (function() {

        /**
         * Properties of an InfoReqMsg.
         * @memberof PropTradingProtocol
         * @interface IInfoReqMsg
         * @property {PropTradingProtocol.InfoModeEnum|null} [Mode] InfoReqMsg Mode
         * @property {number|Long|null} [RequestId] InfoReqMsg RequestId
         * @property {PropTradingProtocol.AccountStatusEnum|null} [AccountListFilterStatus] InfoReqMsg AccountListFilterStatus
         * @property {Array.<number|Long>|null} [Accounts] InfoReqMsg Accounts
         * @property {Array.<PropTradingProtocol.InfoModeEnum>|null} [Modes] InfoReqMsg Modes
         */

        /**
         * Constructs a new InfoReqMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an InfoReqMsg.
         * @implements IInfoReqMsg
         * @constructor
         * @param {PropTradingProtocol.IInfoReqMsg=} [properties] Properties to set
         */
        function InfoReqMsg(properties) {
            this.Accounts = [];
            this.Modes = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InfoReqMsg Mode.
         * @member {PropTradingProtocol.InfoModeEnum} Mode
         * @memberof PropTradingProtocol.InfoReqMsg
         * @instance
         */
        InfoReqMsg.prototype.Mode = 1;

        /**
         * InfoReqMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.InfoReqMsg
         * @instance
         */
        InfoReqMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * InfoReqMsg AccountListFilterStatus.
         * @member {PropTradingProtocol.AccountStatusEnum} AccountListFilterStatus
         * @memberof PropTradingProtocol.InfoReqMsg
         * @instance
         */
        InfoReqMsg.prototype.AccountListFilterStatus = -1;

        /**
         * InfoReqMsg Accounts.
         * @member {Array.<number|Long>} Accounts
         * @memberof PropTradingProtocol.InfoReqMsg
         * @instance
         */
        InfoReqMsg.prototype.Accounts = $util.emptyArray;

        /**
         * InfoReqMsg Modes.
         * @member {Array.<PropTradingProtocol.InfoModeEnum>} Modes
         * @memberof PropTradingProtocol.InfoReqMsg
         * @instance
         */
        InfoReqMsg.prototype.Modes = $util.emptyArray;

        /**
         * Creates a new InfoReqMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.InfoReqMsg
         * @static
         * @param {PropTradingProtocol.IInfoReqMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.InfoReqMsg} InfoReqMsg instance
         */
        InfoReqMsg.create = function create(properties) {
            return new InfoReqMsg(properties);
        };

        /**
         * Encodes the specified InfoReqMsg message. Does not implicitly {@link PropTradingProtocol.InfoReqMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.InfoReqMsg
         * @static
         * @param {PropTradingProtocol.IInfoReqMsg} message InfoReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InfoReqMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Mode != null && Object.hasOwnProperty.call(message, "Mode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Mode);
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.RequestId);
            if (message.AccountListFilterStatus != null && Object.hasOwnProperty.call(message, "AccountListFilterStatus"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.AccountListFilterStatus);
            if (message.Accounts != null && message.Accounts.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.Accounts.length; ++i)
                    writer.sint64(message.Accounts[i]);
                writer.ldelim();
            }
            if (message.Modes != null && message.Modes.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.Modes.length; ++i)
                    writer.int32(message.Modes[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified InfoReqMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.InfoReqMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.InfoReqMsg
         * @static
         * @param {PropTradingProtocol.IInfoReqMsg} message InfoReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InfoReqMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InfoReqMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.InfoReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.InfoReqMsg} InfoReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InfoReqMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.InfoReqMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.Mode = reader.int32();
                        break;
                    }
                case 2: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 3: {
                        message.AccountListFilterStatus = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.Accounts && message.Accounts.length))
                            message.Accounts = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.Accounts.push(reader.sint64());
                        } else
                            message.Accounts.push(reader.sint64());
                        break;
                    }
                case 5: {
                        if (!(message.Modes && message.Modes.length))
                            message.Modes = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.Modes.push(reader.int32());
                        } else
                            message.Modes.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InfoReqMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.InfoReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.InfoReqMsg} InfoReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InfoReqMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InfoReqMsg message.
         * @function verify
         * @memberof PropTradingProtocol.InfoReqMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InfoReqMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Mode != null && message.hasOwnProperty("Mode"))
                switch (message.Mode) {
                default:
                    return "Mode: enum value expected";
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.AccountListFilterStatus != null && message.hasOwnProperty("AccountListFilterStatus"))
                switch (message.AccountListFilterStatus) {
                default:
                    return "AccountListFilterStatus: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 4:
                case 8:
                    break;
                }
            if (message.Accounts != null && message.hasOwnProperty("Accounts")) {
                if (!Array.isArray(message.Accounts))
                    return "Accounts: array expected";
                for (let i = 0; i < message.Accounts.length; ++i)
                    if (!$util.isInteger(message.Accounts[i]) && !(message.Accounts[i] && $util.isInteger(message.Accounts[i].low) && $util.isInteger(message.Accounts[i].high)))
                        return "Accounts: integer|Long[] expected";
            }
            if (message.Modes != null && message.hasOwnProperty("Modes")) {
                if (!Array.isArray(message.Modes))
                    return "Modes: array expected";
                for (let i = 0; i < message.Modes.length; ++i)
                    switch (message.Modes[i]) {
                    default:
                        return "Modes: enum value[] expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates an InfoReqMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.InfoReqMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.InfoReqMsg} InfoReqMsg
         */
        InfoReqMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.InfoReqMsg)
                return object;
            let message = new $root.PropTradingProtocol.InfoReqMsg();
            switch (object.Mode) {
            default:
                if (typeof object.Mode === "number") {
                    message.Mode = object.Mode;
                    break;
                }
                break;
            case "Account":
            case 1:
                message.Mode = 1;
                break;
            case "OrdAndPos":
            case 2:
                message.Mode = 2;
                break;
            case "Positions":
            case 3:
                message.Mode = 3;
                break;
            case "AccountTradingSymbols":
            case 4:
                message.Mode = 4;
                break;
            }
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            switch (object.AccountListFilterStatus) {
            default:
                if (typeof object.AccountListFilterStatus === "number") {
                    message.AccountListFilterStatus = object.AccountListFilterStatus;
                    break;
                }
                break;
            case "ALL":
            case -1:
                message.AccountListFilterStatus = -1;
                break;
            case "INITIALIZED":
            case 0:
                message.AccountListFilterStatus = 0;
                break;
            case "ENABLED":
            case 1:
                message.AccountListFilterStatus = 1;
                break;
            case "SUCCESS":
            case 2:
                message.AccountListFilterStatus = 2;
                break;
            case "FAILED":
            case 4:
                message.AccountListFilterStatus = 4;
                break;
            case "DISABLED":
            case 8:
                message.AccountListFilterStatus = 8;
                break;
            }
            if (object.Accounts) {
                if (!Array.isArray(object.Accounts))
                    throw TypeError(".PropTradingProtocol.InfoReqMsg.Accounts: array expected");
                message.Accounts = [];
                for (let i = 0; i < object.Accounts.length; ++i)
                    if ($util.Long)
                        (message.Accounts[i] = $util.Long.fromValue(object.Accounts[i])).unsigned = false;
                    else if (typeof object.Accounts[i] === "string")
                        message.Accounts[i] = parseInt(object.Accounts[i], 10);
                    else if (typeof object.Accounts[i] === "number")
                        message.Accounts[i] = object.Accounts[i];
                    else if (typeof object.Accounts[i] === "object")
                        message.Accounts[i] = new $util.LongBits(object.Accounts[i].low >>> 0, object.Accounts[i].high >>> 0).toNumber();
            }
            if (object.Modes) {
                if (!Array.isArray(object.Modes))
                    throw TypeError(".PropTradingProtocol.InfoReqMsg.Modes: array expected");
                message.Modes = [];
                for (let i = 0; i < object.Modes.length; ++i)
                    switch (object.Modes[i]) {
                    default:
                        if (typeof object.Modes[i] === "number") {
                            message.Modes[i] = object.Modes[i];
                            break;
                        }
                    case "Account":
                    case 1:
                        message.Modes[i] = 1;
                        break;
                    case "OrdAndPos":
                    case 2:
                        message.Modes[i] = 2;
                        break;
                    case "Positions":
                    case 3:
                        message.Modes[i] = 3;
                        break;
                    case "AccountTradingSymbols":
                    case 4:
                        message.Modes[i] = 4;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from an InfoReqMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.InfoReqMsg
         * @static
         * @param {PropTradingProtocol.InfoReqMsg} message InfoReqMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InfoReqMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.Accounts = [];
                object.Modes = [];
            }
            if (options.defaults) {
                object.Mode = options.enums === String ? "Account" : 1;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.AccountListFilterStatus = options.enums === String ? "ALL" : -1;
            }
            if (message.Mode != null && message.hasOwnProperty("Mode"))
                object.Mode = options.enums === String ? $root.PropTradingProtocol.InfoModeEnum[message.Mode] === undefined ? message.Mode : $root.PropTradingProtocol.InfoModeEnum[message.Mode] : message.Mode;
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.AccountListFilterStatus != null && message.hasOwnProperty("AccountListFilterStatus"))
                object.AccountListFilterStatus = options.enums === String ? $root.PropTradingProtocol.AccountStatusEnum[message.AccountListFilterStatus] === undefined ? message.AccountListFilterStatus : $root.PropTradingProtocol.AccountStatusEnum[message.AccountListFilterStatus] : message.AccountListFilterStatus;
            if (message.Accounts && message.Accounts.length) {
                object.Accounts = [];
                for (let j = 0; j < message.Accounts.length; ++j)
                    if (typeof message.Accounts[j] === "number")
                        object.Accounts[j] = options.longs === String ? String(message.Accounts[j]) : message.Accounts[j];
                    else
                        object.Accounts[j] = options.longs === String ? $util.Long.prototype.toString.call(message.Accounts[j]) : options.longs === Number ? new $util.LongBits(message.Accounts[j].low >>> 0, message.Accounts[j].high >>> 0).toNumber() : message.Accounts[j];
            }
            if (message.Modes && message.Modes.length) {
                object.Modes = [];
                for (let j = 0; j < message.Modes.length; ++j)
                    object.Modes[j] = options.enums === String ? $root.PropTradingProtocol.InfoModeEnum[message.Modes[j]] === undefined ? message.Modes[j] : $root.PropTradingProtocol.InfoModeEnum[message.Modes[j]] : message.Modes[j];
            }
            return object;
        };

        /**
         * Converts this InfoReqMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.InfoReqMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InfoReqMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for InfoReqMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.InfoReqMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        InfoReqMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.InfoReqMsg";
        };

        return InfoReqMsg;
    })();

    PropTradingProtocol.InfoRespMsg = (function() {

        /**
         * Properties of an InfoRespMsg.
         * @memberof PropTradingProtocol
         * @interface IInfoRespMsg
         * @property {Array.<PropTradingProtocol.IAccountHeaderMsg>|null} [AccountList] InfoRespMsg AccountList
         * @property {Array.<PropTradingProtocol.IOrderInfoMsg>|null} [OrderList] InfoRespMsg OrderList
         * @property {number|Long|null} [RequestId] InfoRespMsg RequestId
         * @property {Array.<PropTradingProtocol.IPositionInfoMsg>|null} [PositionList] InfoRespMsg PositionList
         * @property {Array.<PropTradingProtocol.IBracketInfoMsg>|null} [BracketList] InfoRespMsg BracketList
         * @property {Array.<PropTradingProtocol.IAccountTradingSymbolInfoMsg>|null} [AccountTradingSymbolList] InfoRespMsg AccountTradingSymbolList
         */

        /**
         * Constructs a new InfoRespMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an InfoRespMsg.
         * @implements IInfoRespMsg
         * @constructor
         * @param {PropTradingProtocol.IInfoRespMsg=} [properties] Properties to set
         */
        function InfoRespMsg(properties) {
            this.AccountList = [];
            this.OrderList = [];
            this.PositionList = [];
            this.BracketList = [];
            this.AccountTradingSymbolList = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InfoRespMsg AccountList.
         * @member {Array.<PropTradingProtocol.IAccountHeaderMsg>} AccountList
         * @memberof PropTradingProtocol.InfoRespMsg
         * @instance
         */
        InfoRespMsg.prototype.AccountList = $util.emptyArray;

        /**
         * InfoRespMsg OrderList.
         * @member {Array.<PropTradingProtocol.IOrderInfoMsg>} OrderList
         * @memberof PropTradingProtocol.InfoRespMsg
         * @instance
         */
        InfoRespMsg.prototype.OrderList = $util.emptyArray;

        /**
         * InfoRespMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.InfoRespMsg
         * @instance
         */
        InfoRespMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * InfoRespMsg PositionList.
         * @member {Array.<PropTradingProtocol.IPositionInfoMsg>} PositionList
         * @memberof PropTradingProtocol.InfoRespMsg
         * @instance
         */
        InfoRespMsg.prototype.PositionList = $util.emptyArray;

        /**
         * InfoRespMsg BracketList.
         * @member {Array.<PropTradingProtocol.IBracketInfoMsg>} BracketList
         * @memberof PropTradingProtocol.InfoRespMsg
         * @instance
         */
        InfoRespMsg.prototype.BracketList = $util.emptyArray;

        /**
         * InfoRespMsg AccountTradingSymbolList.
         * @member {Array.<PropTradingProtocol.IAccountTradingSymbolInfoMsg>} AccountTradingSymbolList
         * @memberof PropTradingProtocol.InfoRespMsg
         * @instance
         */
        InfoRespMsg.prototype.AccountTradingSymbolList = $util.emptyArray;

        /**
         * Creates a new InfoRespMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.InfoRespMsg
         * @static
         * @param {PropTradingProtocol.IInfoRespMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.InfoRespMsg} InfoRespMsg instance
         */
        InfoRespMsg.create = function create(properties) {
            return new InfoRespMsg(properties);
        };

        /**
         * Encodes the specified InfoRespMsg message. Does not implicitly {@link PropTradingProtocol.InfoRespMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.InfoRespMsg
         * @static
         * @param {PropTradingProtocol.IInfoRespMsg} message InfoRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InfoRespMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AccountList != null && message.AccountList.length)
                for (let i = 0; i < message.AccountList.length; ++i)
                    $root.PropTradingProtocol.AccountHeaderMsg.encode(message.AccountList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.OrderList != null && message.OrderList.length)
                for (let i = 0; i < message.OrderList.length; ++i)
                    $root.PropTradingProtocol.OrderInfoMsg.encode(message.OrderList[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint64(message.RequestId);
            if (message.PositionList != null && message.PositionList.length)
                for (let i = 0; i < message.PositionList.length; ++i)
                    $root.PropTradingProtocol.PositionInfoMsg.encode(message.PositionList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.BracketList != null && message.BracketList.length)
                for (let i = 0; i < message.BracketList.length; ++i)
                    $root.PropTradingProtocol.BracketInfoMsg.encode(message.BracketList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.AccountTradingSymbolList != null && message.AccountTradingSymbolList.length)
                for (let i = 0; i < message.AccountTradingSymbolList.length; ++i)
                    $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.encode(message.AccountTradingSymbolList[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InfoRespMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.InfoRespMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.InfoRespMsg
         * @static
         * @param {PropTradingProtocol.IInfoRespMsg} message InfoRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InfoRespMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InfoRespMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.InfoRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.InfoRespMsg} InfoRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InfoRespMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.InfoRespMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.AccountList && message.AccountList.length))
                            message.AccountList = [];
                        message.AccountList.push($root.PropTradingProtocol.AccountHeaderMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.OrderList && message.OrderList.length))
                            message.OrderList = [];
                        message.OrderList.push($root.PropTradingProtocol.OrderInfoMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 4: {
                        if (!(message.PositionList && message.PositionList.length))
                            message.PositionList = [];
                        message.PositionList.push($root.PropTradingProtocol.PositionInfoMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        if (!(message.BracketList && message.BracketList.length))
                            message.BracketList = [];
                        message.BracketList.push($root.PropTradingProtocol.BracketInfoMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        if (!(message.AccountTradingSymbolList && message.AccountTradingSymbolList.length))
                            message.AccountTradingSymbolList = [];
                        message.AccountTradingSymbolList.push($root.PropTradingProtocol.AccountTradingSymbolInfoMsg.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InfoRespMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.InfoRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.InfoRespMsg} InfoRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InfoRespMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InfoRespMsg message.
         * @function verify
         * @memberof PropTradingProtocol.InfoRespMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InfoRespMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AccountList != null && message.hasOwnProperty("AccountList")) {
                if (!Array.isArray(message.AccountList))
                    return "AccountList: array expected";
                for (let i = 0; i < message.AccountList.length; ++i) {
                    let error = $root.PropTradingProtocol.AccountHeaderMsg.verify(message.AccountList[i]);
                    if (error)
                        return "AccountList." + error;
                }
            }
            if (message.OrderList != null && message.hasOwnProperty("OrderList")) {
                if (!Array.isArray(message.OrderList))
                    return "OrderList: array expected";
                for (let i = 0; i < message.OrderList.length; ++i) {
                    let error = $root.PropTradingProtocol.OrderInfoMsg.verify(message.OrderList[i]);
                    if (error)
                        return "OrderList." + error;
                }
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.PositionList != null && message.hasOwnProperty("PositionList")) {
                if (!Array.isArray(message.PositionList))
                    return "PositionList: array expected";
                for (let i = 0; i < message.PositionList.length; ++i) {
                    let error = $root.PropTradingProtocol.PositionInfoMsg.verify(message.PositionList[i]);
                    if (error)
                        return "PositionList." + error;
                }
            }
            if (message.BracketList != null && message.hasOwnProperty("BracketList")) {
                if (!Array.isArray(message.BracketList))
                    return "BracketList: array expected";
                for (let i = 0; i < message.BracketList.length; ++i) {
                    let error = $root.PropTradingProtocol.BracketInfoMsg.verify(message.BracketList[i]);
                    if (error)
                        return "BracketList." + error;
                }
            }
            if (message.AccountTradingSymbolList != null && message.hasOwnProperty("AccountTradingSymbolList")) {
                if (!Array.isArray(message.AccountTradingSymbolList))
                    return "AccountTradingSymbolList: array expected";
                for (let i = 0; i < message.AccountTradingSymbolList.length; ++i) {
                    let error = $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.verify(message.AccountTradingSymbolList[i]);
                    if (error)
                        return "AccountTradingSymbolList." + error;
                }
            }
            return null;
        };

        /**
         * Creates an InfoRespMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.InfoRespMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.InfoRespMsg} InfoRespMsg
         */
        InfoRespMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.InfoRespMsg)
                return object;
            let message = new $root.PropTradingProtocol.InfoRespMsg();
            if (object.AccountList) {
                if (!Array.isArray(object.AccountList))
                    throw TypeError(".PropTradingProtocol.InfoRespMsg.AccountList: array expected");
                message.AccountList = [];
                for (let i = 0; i < object.AccountList.length; ++i) {
                    if (typeof object.AccountList[i] !== "object")
                        throw TypeError(".PropTradingProtocol.InfoRespMsg.AccountList: object expected");
                    message.AccountList[i] = $root.PropTradingProtocol.AccountHeaderMsg.fromObject(object.AccountList[i]);
                }
            }
            if (object.OrderList) {
                if (!Array.isArray(object.OrderList))
                    throw TypeError(".PropTradingProtocol.InfoRespMsg.OrderList: array expected");
                message.OrderList = [];
                for (let i = 0; i < object.OrderList.length; ++i) {
                    if (typeof object.OrderList[i] !== "object")
                        throw TypeError(".PropTradingProtocol.InfoRespMsg.OrderList: object expected");
                    message.OrderList[i] = $root.PropTradingProtocol.OrderInfoMsg.fromObject(object.OrderList[i]);
                }
            }
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.PositionList) {
                if (!Array.isArray(object.PositionList))
                    throw TypeError(".PropTradingProtocol.InfoRespMsg.PositionList: array expected");
                message.PositionList = [];
                for (let i = 0; i < object.PositionList.length; ++i) {
                    if (typeof object.PositionList[i] !== "object")
                        throw TypeError(".PropTradingProtocol.InfoRespMsg.PositionList: object expected");
                    message.PositionList[i] = $root.PropTradingProtocol.PositionInfoMsg.fromObject(object.PositionList[i]);
                }
            }
            if (object.BracketList) {
                if (!Array.isArray(object.BracketList))
                    throw TypeError(".PropTradingProtocol.InfoRespMsg.BracketList: array expected");
                message.BracketList = [];
                for (let i = 0; i < object.BracketList.length; ++i) {
                    if (typeof object.BracketList[i] !== "object")
                        throw TypeError(".PropTradingProtocol.InfoRespMsg.BracketList: object expected");
                    message.BracketList[i] = $root.PropTradingProtocol.BracketInfoMsg.fromObject(object.BracketList[i]);
                }
            }
            if (object.AccountTradingSymbolList) {
                if (!Array.isArray(object.AccountTradingSymbolList))
                    throw TypeError(".PropTradingProtocol.InfoRespMsg.AccountTradingSymbolList: array expected");
                message.AccountTradingSymbolList = [];
                for (let i = 0; i < object.AccountTradingSymbolList.length; ++i) {
                    if (typeof object.AccountTradingSymbolList[i] !== "object")
                        throw TypeError(".PropTradingProtocol.InfoRespMsg.AccountTradingSymbolList: object expected");
                    message.AccountTradingSymbolList[i] = $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.fromObject(object.AccountTradingSymbolList[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an InfoRespMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.InfoRespMsg
         * @static
         * @param {PropTradingProtocol.InfoRespMsg} message InfoRespMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        InfoRespMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.AccountList = [];
                object.OrderList = [];
                object.PositionList = [];
                object.BracketList = [];
                object.AccountTradingSymbolList = [];
            }
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
            if (message.AccountList && message.AccountList.length) {
                object.AccountList = [];
                for (let j = 0; j < message.AccountList.length; ++j)
                    object.AccountList[j] = $root.PropTradingProtocol.AccountHeaderMsg.toObject(message.AccountList[j], options);
            }
            if (message.OrderList && message.OrderList.length) {
                object.OrderList = [];
                for (let j = 0; j < message.OrderList.length; ++j)
                    object.OrderList[j] = $root.PropTradingProtocol.OrderInfoMsg.toObject(message.OrderList[j], options);
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.PositionList && message.PositionList.length) {
                object.PositionList = [];
                for (let j = 0; j < message.PositionList.length; ++j)
                    object.PositionList[j] = $root.PropTradingProtocol.PositionInfoMsg.toObject(message.PositionList[j], options);
            }
            if (message.BracketList && message.BracketList.length) {
                object.BracketList = [];
                for (let j = 0; j < message.BracketList.length; ++j)
                    object.BracketList[j] = $root.PropTradingProtocol.BracketInfoMsg.toObject(message.BracketList[j], options);
            }
            if (message.AccountTradingSymbolList && message.AccountTradingSymbolList.length) {
                object.AccountTradingSymbolList = [];
                for (let j = 0; j < message.AccountTradingSymbolList.length; ++j)
                    object.AccountTradingSymbolList[j] = $root.PropTradingProtocol.AccountTradingSymbolInfoMsg.toObject(message.AccountTradingSymbolList[j], options);
            }
            return object;
        };

        /**
         * Converts this InfoRespMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.InfoRespMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        InfoRespMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for InfoRespMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.InfoRespMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        InfoRespMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.InfoRespMsg";
        };

        return InfoRespMsg;
    })();

    PropTradingProtocol.AccountHeaderMsg = (function() {

        /**
         * Properties of an AccountHeaderMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountHeaderMsg
         * @property {number|Long|null} [accountNumber] AccountHeaderMsg accountNumber
         * @property {string|null} [accountHeader] AccountHeaderMsg accountHeader
         * @property {string|null} [accountDescription] AccountHeaderMsg accountDescription
         * @property {PropTradingProtocol.IBalanceMsg|null} [Balance] AccountHeaderMsg Balance
         * @property {boolean|null} [IsEnabled] AccountHeaderMsg IsEnabled
         * @property {PropTradingProtocol.AccountStatusEnum|null} [Status] AccountHeaderMsg Status
         * @property {boolean|null} [IsTradingEnabled] AccountHeaderMsg IsTradingEnabled
         * @property {boolean|null} [IsHedging] AccountHeaderMsg IsHedging
         * @property {string|null} [AccountReferenceId] AccountHeaderMsg AccountReferenceId
         * @property {PropTradingProtocol.AccountPermissionEnum|null} [Permission] AccountHeaderMsg Permission
         * @property {string|null} [Currency] AccountHeaderMsg Currency
         * @property {boolean|null} [Archived] AccountHeaderMsg Archived
         * @property {boolean|null} [UserRiskRuleEnabled] AccountHeaderMsg UserRiskRuleEnabled
         * @property {boolean|null} [UserDailyLockoutEnabled] AccountHeaderMsg UserDailyLockoutEnabled
         * @property {boolean|null} [IsTradeCopierAllowed] AccountHeaderMsg IsTradeCopierAllowed
         * @property {number|Long|null} [OrganizationId] AccountHeaderMsg OrganizationId
         * @property {string|null} [OrganizationName] AccountHeaderMsg OrganizationName
         * @property {PropTradingProtocol.AccountModeEnum|null} [Mode] AccountHeaderMsg Mode
         */

        /**
         * Constructs a new AccountHeaderMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountHeaderMsg.
         * @implements IAccountHeaderMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountHeaderMsg=} [properties] Properties to set
         */
        function AccountHeaderMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountHeaderMsg accountNumber.
         * @member {number|Long} accountNumber
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.accountNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountHeaderMsg accountHeader.
         * @member {string} accountHeader
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.accountHeader = "";

        /**
         * AccountHeaderMsg accountDescription.
         * @member {string} accountDescription
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.accountDescription = "";

        /**
         * AccountHeaderMsg Balance.
         * @member {PropTradingProtocol.IBalanceMsg|null|undefined} Balance
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.Balance = null;

        /**
         * AccountHeaderMsg IsEnabled.
         * @member {boolean} IsEnabled
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.IsEnabled = false;

        /**
         * AccountHeaderMsg Status.
         * @member {PropTradingProtocol.AccountStatusEnum} Status
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.Status = -1;

        /**
         * AccountHeaderMsg IsTradingEnabled.
         * @member {boolean} IsTradingEnabled
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.IsTradingEnabled = false;

        /**
         * AccountHeaderMsg IsHedging.
         * @member {boolean} IsHedging
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.IsHedging = false;

        /**
         * AccountHeaderMsg AccountReferenceId.
         * @member {string} AccountReferenceId
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.AccountReferenceId = "";

        /**
         * AccountHeaderMsg Permission.
         * @member {PropTradingProtocol.AccountPermissionEnum} Permission
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.Permission = 0;

        /**
         * AccountHeaderMsg Currency.
         * @member {string} Currency
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.Currency = "";

        /**
         * AccountHeaderMsg Archived.
         * @member {boolean} Archived
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.Archived = false;

        /**
         * AccountHeaderMsg UserRiskRuleEnabled.
         * @member {boolean} UserRiskRuleEnabled
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.UserRiskRuleEnabled = false;

        /**
         * AccountHeaderMsg UserDailyLockoutEnabled.
         * @member {boolean} UserDailyLockoutEnabled
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.UserDailyLockoutEnabled = false;

        /**
         * AccountHeaderMsg IsTradeCopierAllowed.
         * @member {boolean} IsTradeCopierAllowed
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.IsTradeCopierAllowed = false;

        /**
         * AccountHeaderMsg OrganizationId.
         * @member {number|Long} OrganizationId
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.OrganizationId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountHeaderMsg OrganizationName.
         * @member {string} OrganizationName
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.OrganizationName = "";

        /**
         * AccountHeaderMsg Mode.
         * @member {PropTradingProtocol.AccountModeEnum} Mode
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         */
        AccountHeaderMsg.prototype.Mode = 0;

        /**
         * Creates a new AccountHeaderMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @static
         * @param {PropTradingProtocol.IAccountHeaderMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountHeaderMsg} AccountHeaderMsg instance
         */
        AccountHeaderMsg.create = function create(properties) {
            return new AccountHeaderMsg(properties);
        };

        /**
         * Encodes the specified AccountHeaderMsg message. Does not implicitly {@link PropTradingProtocol.AccountHeaderMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @static
         * @param {PropTradingProtocol.IAccountHeaderMsg} message AccountHeaderMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountHeaderMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.accountNumber != null && Object.hasOwnProperty.call(message, "accountNumber"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.accountNumber);
            if (message.accountHeader != null && Object.hasOwnProperty.call(message, "accountHeader"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.accountHeader);
            if (message.accountDescription != null && Object.hasOwnProperty.call(message, "accountDescription"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.accountDescription);
            if (message.Balance != null && Object.hasOwnProperty.call(message, "Balance"))
                $root.PropTradingProtocol.BalanceMsg.encode(message.Balance, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.IsEnabled != null && Object.hasOwnProperty.call(message, "IsEnabled"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.IsEnabled);
            if (message.Status != null && Object.hasOwnProperty.call(message, "Status"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Status);
            if (message.IsTradingEnabled != null && Object.hasOwnProperty.call(message, "IsTradingEnabled"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.IsTradingEnabled);
            if (message.IsHedging != null && Object.hasOwnProperty.call(message, "IsHedging"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.IsHedging);
            if (message.AccountReferenceId != null && Object.hasOwnProperty.call(message, "AccountReferenceId"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.AccountReferenceId);
            if (message.Permission != null && Object.hasOwnProperty.call(message, "Permission"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.Permission);
            if (message.Currency != null && Object.hasOwnProperty.call(message, "Currency"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.Currency);
            if (message.Archived != null && Object.hasOwnProperty.call(message, "Archived"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.Archived);
            if (message.UserRiskRuleEnabled != null && Object.hasOwnProperty.call(message, "UserRiskRuleEnabled"))
                writer.uint32(/* id 13, wireType 0 =*/104).bool(message.UserRiskRuleEnabled);
            if (message.UserDailyLockoutEnabled != null && Object.hasOwnProperty.call(message, "UserDailyLockoutEnabled"))
                writer.uint32(/* id 14, wireType 0 =*/112).bool(message.UserDailyLockoutEnabled);
            if (message.IsTradeCopierAllowed != null && Object.hasOwnProperty.call(message, "IsTradeCopierAllowed"))
                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.IsTradeCopierAllowed);
            if (message.OrganizationId != null && Object.hasOwnProperty.call(message, "OrganizationId"))
                writer.uint32(/* id 16, wireType 0 =*/128).sint64(message.OrganizationId);
            if (message.OrganizationName != null && Object.hasOwnProperty.call(message, "OrganizationName"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.OrganizationName);
            if (message.Mode != null && Object.hasOwnProperty.call(message, "Mode"))
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.Mode);
            return writer;
        };

        /**
         * Encodes the specified AccountHeaderMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountHeaderMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @static
         * @param {PropTradingProtocol.IAccountHeaderMsg} message AccountHeaderMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountHeaderMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountHeaderMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountHeaderMsg} AccountHeaderMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountHeaderMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountHeaderMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.accountNumber = reader.sint64();
                        break;
                    }
                case 2: {
                        message.accountHeader = reader.string();
                        break;
                    }
                case 3: {
                        message.accountDescription = reader.string();
                        break;
                    }
                case 4: {
                        message.Balance = $root.PropTradingProtocol.BalanceMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.IsEnabled = reader.bool();
                        break;
                    }
                case 6: {
                        message.Status = reader.int32();
                        break;
                    }
                case 7: {
                        message.IsTradingEnabled = reader.bool();
                        break;
                    }
                case 8: {
                        message.IsHedging = reader.bool();
                        break;
                    }
                case 9: {
                        message.AccountReferenceId = reader.string();
                        break;
                    }
                case 10: {
                        message.Permission = reader.int32();
                        break;
                    }
                case 11: {
                        message.Currency = reader.string();
                        break;
                    }
                case 12: {
                        message.Archived = reader.bool();
                        break;
                    }
                case 13: {
                        message.UserRiskRuleEnabled = reader.bool();
                        break;
                    }
                case 14: {
                        message.UserDailyLockoutEnabled = reader.bool();
                        break;
                    }
                case 15: {
                        message.IsTradeCopierAllowed = reader.bool();
                        break;
                    }
                case 16: {
                        message.OrganizationId = reader.sint64();
                        break;
                    }
                case 17: {
                        message.OrganizationName = reader.string();
                        break;
                    }
                case 18: {
                        message.Mode = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountHeaderMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountHeaderMsg} AccountHeaderMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountHeaderMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountHeaderMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountHeaderMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                if (!$util.isInteger(message.accountNumber) && !(message.accountNumber && $util.isInteger(message.accountNumber.low) && $util.isInteger(message.accountNumber.high)))
                    return "accountNumber: integer|Long expected";
            if (message.accountHeader != null && message.hasOwnProperty("accountHeader"))
                if (!$util.isString(message.accountHeader))
                    return "accountHeader: string expected";
            if (message.accountDescription != null && message.hasOwnProperty("accountDescription"))
                if (!$util.isString(message.accountDescription))
                    return "accountDescription: string expected";
            if (message.Balance != null && message.hasOwnProperty("Balance")) {
                let error = $root.PropTradingProtocol.BalanceMsg.verify(message.Balance);
                if (error)
                    return "Balance." + error;
            }
            if (message.IsEnabled != null && message.hasOwnProperty("IsEnabled"))
                if (typeof message.IsEnabled !== "boolean")
                    return "IsEnabled: boolean expected";
            if (message.Status != null && message.hasOwnProperty("Status"))
                switch (message.Status) {
                default:
                    return "Status: enum value expected";
                case -1:
                case 0:
                case 1:
                case 2:
                case 4:
                case 8:
                    break;
                }
            if (message.IsTradingEnabled != null && message.hasOwnProperty("IsTradingEnabled"))
                if (typeof message.IsTradingEnabled !== "boolean")
                    return "IsTradingEnabled: boolean expected";
            if (message.IsHedging != null && message.hasOwnProperty("IsHedging"))
                if (typeof message.IsHedging !== "boolean")
                    return "IsHedging: boolean expected";
            if (message.AccountReferenceId != null && message.hasOwnProperty("AccountReferenceId"))
                if (!$util.isString(message.AccountReferenceId))
                    return "AccountReferenceId: string expected";
            if (message.Permission != null && message.hasOwnProperty("Permission"))
                switch (message.Permission) {
                default:
                    return "Permission: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.Currency != null && message.hasOwnProperty("Currency"))
                if (!$util.isString(message.Currency))
                    return "Currency: string expected";
            if (message.Archived != null && message.hasOwnProperty("Archived"))
                if (typeof message.Archived !== "boolean")
                    return "Archived: boolean expected";
            if (message.UserRiskRuleEnabled != null && message.hasOwnProperty("UserRiskRuleEnabled"))
                if (typeof message.UserRiskRuleEnabled !== "boolean")
                    return "UserRiskRuleEnabled: boolean expected";
            if (message.UserDailyLockoutEnabled != null && message.hasOwnProperty("UserDailyLockoutEnabled"))
                if (typeof message.UserDailyLockoutEnabled !== "boolean")
                    return "UserDailyLockoutEnabled: boolean expected";
            if (message.IsTradeCopierAllowed != null && message.hasOwnProperty("IsTradeCopierAllowed"))
                if (typeof message.IsTradeCopierAllowed !== "boolean")
                    return "IsTradeCopierAllowed: boolean expected";
            if (message.OrganizationId != null && message.hasOwnProperty("OrganizationId"))
                if (!$util.isInteger(message.OrganizationId) && !(message.OrganizationId && $util.isInteger(message.OrganizationId.low) && $util.isInteger(message.OrganizationId.high)))
                    return "OrganizationId: integer|Long expected";
            if (message.OrganizationName != null && message.hasOwnProperty("OrganizationName"))
                if (!$util.isString(message.OrganizationName))
                    return "OrganizationName: string expected";
            if (message.Mode != null && message.hasOwnProperty("Mode"))
                switch (message.Mode) {
                default:
                    return "Mode: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 100:
                    break;
                }
            return null;
        };

        /**
         * Creates an AccountHeaderMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountHeaderMsg} AccountHeaderMsg
         */
        AccountHeaderMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountHeaderMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountHeaderMsg();
            if (object.accountNumber != null)
                if ($util.Long)
                    (message.accountNumber = $util.Long.fromValue(object.accountNumber)).unsigned = false;
                else if (typeof object.accountNumber === "string")
                    message.accountNumber = parseInt(object.accountNumber, 10);
                else if (typeof object.accountNumber === "number")
                    message.accountNumber = object.accountNumber;
                else if (typeof object.accountNumber === "object")
                    message.accountNumber = new $util.LongBits(object.accountNumber.low >>> 0, object.accountNumber.high >>> 0).toNumber();
            if (object.accountHeader != null)
                message.accountHeader = String(object.accountHeader);
            if (object.accountDescription != null)
                message.accountDescription = String(object.accountDescription);
            if (object.Balance != null) {
                if (typeof object.Balance !== "object")
                    throw TypeError(".PropTradingProtocol.AccountHeaderMsg.Balance: object expected");
                message.Balance = $root.PropTradingProtocol.BalanceMsg.fromObject(object.Balance);
            }
            if (object.IsEnabled != null)
                message.IsEnabled = Boolean(object.IsEnabled);
            switch (object.Status) {
            default:
                if (typeof object.Status === "number") {
                    message.Status = object.Status;
                    break;
                }
                break;
            case "ALL":
            case -1:
                message.Status = -1;
                break;
            case "INITIALIZED":
            case 0:
                message.Status = 0;
                break;
            case "ENABLED":
            case 1:
                message.Status = 1;
                break;
            case "SUCCESS":
            case 2:
                message.Status = 2;
                break;
            case "FAILED":
            case 4:
                message.Status = 4;
                break;
            case "DISABLED":
            case 8:
                message.Status = 8;
                break;
            }
            if (object.IsTradingEnabled != null)
                message.IsTradingEnabled = Boolean(object.IsTradingEnabled);
            if (object.IsHedging != null)
                message.IsHedging = Boolean(object.IsHedging);
            if (object.AccountReferenceId != null)
                message.AccountReferenceId = String(object.AccountReferenceId);
            switch (object.Permission) {
            default:
                if (typeof object.Permission === "number") {
                    message.Permission = object.Permission;
                    break;
                }
                break;
            case "Trading":
            case 0:
                message.Permission = 0;
                break;
            case "ReadOnly":
            case 1:
                message.Permission = 1;
                break;
            case "RiskPause":
            case 2:
                message.Permission = 2;
                break;
            case "LiquidateOnly":
            case 3:
                message.Permission = 3;
                break;
            }
            if (object.Currency != null)
                message.Currency = String(object.Currency);
            if (object.Archived != null)
                message.Archived = Boolean(object.Archived);
            if (object.UserRiskRuleEnabled != null)
                message.UserRiskRuleEnabled = Boolean(object.UserRiskRuleEnabled);
            if (object.UserDailyLockoutEnabled != null)
                message.UserDailyLockoutEnabled = Boolean(object.UserDailyLockoutEnabled);
            if (object.IsTradeCopierAllowed != null)
                message.IsTradeCopierAllowed = Boolean(object.IsTradeCopierAllowed);
            if (object.OrganizationId != null)
                if ($util.Long)
                    (message.OrganizationId = $util.Long.fromValue(object.OrganizationId)).unsigned = false;
                else if (typeof object.OrganizationId === "string")
                    message.OrganizationId = parseInt(object.OrganizationId, 10);
                else if (typeof object.OrganizationId === "number")
                    message.OrganizationId = object.OrganizationId;
                else if (typeof object.OrganizationId === "object")
                    message.OrganizationId = new $util.LongBits(object.OrganizationId.low >>> 0, object.OrganizationId.high >>> 0).toNumber();
            if (object.OrganizationName != null)
                message.OrganizationName = String(object.OrganizationName);
            switch (object.Mode) {
            default:
                if (typeof object.Mode === "number") {
                    message.Mode = object.Mode;
                    break;
                }
                break;
            case "EVALUATION":
            case 0:
                message.Mode = 0;
                break;
            case "SIM_FUNDED":
            case 1:
                message.Mode = 1;
                break;
            case "FUNDED":
            case 2:
                message.Mode = 2;
                break;
            case "LIVE":
            case 3:
                message.Mode = 3;
                break;
            case "TRIAL":
            case 4:
                message.Mode = 4;
                break;
            case "CONTEST":
            case 5:
                message.Mode = 5;
                break;
            case "TRAINING":
            case 100:
                message.Mode = 100;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountHeaderMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @static
         * @param {PropTradingProtocol.AccountHeaderMsg} message AccountHeaderMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountHeaderMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.accountNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.accountNumber = options.longs === String ? "0" : 0;
                object.accountHeader = "";
                object.accountDescription = "";
                object.Balance = null;
                object.IsEnabled = false;
                object.Status = options.enums === String ? "ALL" : -1;
                object.IsTradingEnabled = false;
                object.IsHedging = false;
                object.AccountReferenceId = "";
                object.Permission = options.enums === String ? "Trading" : 0;
                object.Currency = "";
                object.Archived = false;
                object.UserRiskRuleEnabled = false;
                object.UserDailyLockoutEnabled = false;
                object.IsTradeCopierAllowed = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OrganizationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OrganizationId = options.longs === String ? "0" : 0;
                object.OrganizationName = "";
                object.Mode = options.enums === String ? "EVALUATION" : 0;
            }
            if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                if (typeof message.accountNumber === "number")
                    object.accountNumber = options.longs === String ? String(message.accountNumber) : message.accountNumber;
                else
                    object.accountNumber = options.longs === String ? $util.Long.prototype.toString.call(message.accountNumber) : options.longs === Number ? new $util.LongBits(message.accountNumber.low >>> 0, message.accountNumber.high >>> 0).toNumber() : message.accountNumber;
            if (message.accountHeader != null && message.hasOwnProperty("accountHeader"))
                object.accountHeader = message.accountHeader;
            if (message.accountDescription != null && message.hasOwnProperty("accountDescription"))
                object.accountDescription = message.accountDescription;
            if (message.Balance != null && message.hasOwnProperty("Balance"))
                object.Balance = $root.PropTradingProtocol.BalanceMsg.toObject(message.Balance, options);
            if (message.IsEnabled != null && message.hasOwnProperty("IsEnabled"))
                object.IsEnabled = message.IsEnabled;
            if (message.Status != null && message.hasOwnProperty("Status"))
                object.Status = options.enums === String ? $root.PropTradingProtocol.AccountStatusEnum[message.Status] === undefined ? message.Status : $root.PropTradingProtocol.AccountStatusEnum[message.Status] : message.Status;
            if (message.IsTradingEnabled != null && message.hasOwnProperty("IsTradingEnabled"))
                object.IsTradingEnabled = message.IsTradingEnabled;
            if (message.IsHedging != null && message.hasOwnProperty("IsHedging"))
                object.IsHedging = message.IsHedging;
            if (message.AccountReferenceId != null && message.hasOwnProperty("AccountReferenceId"))
                object.AccountReferenceId = message.AccountReferenceId;
            if (message.Permission != null && message.hasOwnProperty("Permission"))
                object.Permission = options.enums === String ? $root.PropTradingProtocol.AccountPermissionEnum[message.Permission] === undefined ? message.Permission : $root.PropTradingProtocol.AccountPermissionEnum[message.Permission] : message.Permission;
            if (message.Currency != null && message.hasOwnProperty("Currency"))
                object.Currency = message.Currency;
            if (message.Archived != null && message.hasOwnProperty("Archived"))
                object.Archived = message.Archived;
            if (message.UserRiskRuleEnabled != null && message.hasOwnProperty("UserRiskRuleEnabled"))
                object.UserRiskRuleEnabled = message.UserRiskRuleEnabled;
            if (message.UserDailyLockoutEnabled != null && message.hasOwnProperty("UserDailyLockoutEnabled"))
                object.UserDailyLockoutEnabled = message.UserDailyLockoutEnabled;
            if (message.IsTradeCopierAllowed != null && message.hasOwnProperty("IsTradeCopierAllowed"))
                object.IsTradeCopierAllowed = message.IsTradeCopierAllowed;
            if (message.OrganizationId != null && message.hasOwnProperty("OrganizationId"))
                if (typeof message.OrganizationId === "number")
                    object.OrganizationId = options.longs === String ? String(message.OrganizationId) : message.OrganizationId;
                else
                    object.OrganizationId = options.longs === String ? $util.Long.prototype.toString.call(message.OrganizationId) : options.longs === Number ? new $util.LongBits(message.OrganizationId.low >>> 0, message.OrganizationId.high >>> 0).toNumber() : message.OrganizationId;
            if (message.OrganizationName != null && message.hasOwnProperty("OrganizationName"))
                object.OrganizationName = message.OrganizationName;
            if (message.Mode != null && message.hasOwnProperty("Mode"))
                object.Mode = options.enums === String ? $root.PropTradingProtocol.AccountModeEnum[message.Mode] === undefined ? message.Mode : $root.PropTradingProtocol.AccountModeEnum[message.Mode] : message.Mode;
            return object;
        };

        /**
         * Converts this AccountHeaderMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountHeaderMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountHeaderMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountHeaderMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountHeaderMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountHeaderMsg";
        };

        return AccountHeaderMsg;
    })();

    PropTradingProtocol.AccountSubscribeReqMsg = (function() {

        /**
         * Properties of an AccountSubscribeReqMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountSubscribeReqMsg
         * @property {number|Long|null} [RequestId] AccountSubscribeReqMsg RequestId
         * @property {Array.<number|Long>|null} [Accounts] AccountSubscribeReqMsg Accounts
         */

        /**
         * Constructs a new AccountSubscribeReqMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountSubscribeReqMsg.
         * @implements IAccountSubscribeReqMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountSubscribeReqMsg=} [properties] Properties to set
         */
        function AccountSubscribeReqMsg(properties) {
            this.Accounts = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountSubscribeReqMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.AccountSubscribeReqMsg
         * @instance
         */
        AccountSubscribeReqMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountSubscribeReqMsg Accounts.
         * @member {Array.<number|Long>} Accounts
         * @memberof PropTradingProtocol.AccountSubscribeReqMsg
         * @instance
         */
        AccountSubscribeReqMsg.prototype.Accounts = $util.emptyArray;

        /**
         * Creates a new AccountSubscribeReqMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountSubscribeReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountSubscribeReqMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountSubscribeReqMsg} AccountSubscribeReqMsg instance
         */
        AccountSubscribeReqMsg.create = function create(properties) {
            return new AccountSubscribeReqMsg(properties);
        };

        /**
         * Encodes the specified AccountSubscribeReqMsg message. Does not implicitly {@link PropTradingProtocol.AccountSubscribeReqMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountSubscribeReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountSubscribeReqMsg} message AccountSubscribeReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountSubscribeReqMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Accounts != null && message.Accounts.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (let i = 0; i < message.Accounts.length; ++i)
                    writer.sint64(message.Accounts[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified AccountSubscribeReqMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountSubscribeReqMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountSubscribeReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountSubscribeReqMsg} message AccountSubscribeReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountSubscribeReqMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountSubscribeReqMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountSubscribeReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountSubscribeReqMsg} AccountSubscribeReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountSubscribeReqMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountSubscribeReqMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        if (!(message.Accounts && message.Accounts.length))
                            message.Accounts = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.Accounts.push(reader.sint64());
                        } else
                            message.Accounts.push(reader.sint64());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountSubscribeReqMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountSubscribeReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountSubscribeReqMsg} AccountSubscribeReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountSubscribeReqMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountSubscribeReqMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountSubscribeReqMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountSubscribeReqMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Accounts != null && message.hasOwnProperty("Accounts")) {
                if (!Array.isArray(message.Accounts))
                    return "Accounts: array expected";
                for (let i = 0; i < message.Accounts.length; ++i)
                    if (!$util.isInteger(message.Accounts[i]) && !(message.Accounts[i] && $util.isInteger(message.Accounts[i].low) && $util.isInteger(message.Accounts[i].high)))
                        return "Accounts: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates an AccountSubscribeReqMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountSubscribeReqMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountSubscribeReqMsg} AccountSubscribeReqMsg
         */
        AccountSubscribeReqMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountSubscribeReqMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountSubscribeReqMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Accounts) {
                if (!Array.isArray(object.Accounts))
                    throw TypeError(".PropTradingProtocol.AccountSubscribeReqMsg.Accounts: array expected");
                message.Accounts = [];
                for (let i = 0; i < object.Accounts.length; ++i)
                    if ($util.Long)
                        (message.Accounts[i] = $util.Long.fromValue(object.Accounts[i])).unsigned = false;
                    else if (typeof object.Accounts[i] === "string")
                        message.Accounts[i] = parseInt(object.Accounts[i], 10);
                    else if (typeof object.Accounts[i] === "number")
                        message.Accounts[i] = object.Accounts[i];
                    else if (typeof object.Accounts[i] === "object")
                        message.Accounts[i] = new $util.LongBits(object.Accounts[i].low >>> 0, object.Accounts[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountSubscribeReqMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountSubscribeReqMsg
         * @static
         * @param {PropTradingProtocol.AccountSubscribeReqMsg} message AccountSubscribeReqMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountSubscribeReqMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.Accounts = [];
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Accounts && message.Accounts.length) {
                object.Accounts = [];
                for (let j = 0; j < message.Accounts.length; ++j)
                    if (typeof message.Accounts[j] === "number")
                        object.Accounts[j] = options.longs === String ? String(message.Accounts[j]) : message.Accounts[j];
                    else
                        object.Accounts[j] = options.longs === String ? $util.Long.prototype.toString.call(message.Accounts[j]) : options.longs === Number ? new $util.LongBits(message.Accounts[j].low >>> 0, message.Accounts[j].high >>> 0).toNumber() : message.Accounts[j];
            }
            return object;
        };

        /**
         * Converts this AccountSubscribeReqMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountSubscribeReqMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountSubscribeReqMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountSubscribeReqMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountSubscribeReqMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountSubscribeReqMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountSubscribeReqMsg";
        };

        return AccountSubscribeReqMsg;
    })();

    PropTradingProtocol.AccountSubscribeRespMsg = (function() {

        /**
         * Properties of an AccountSubscribeRespMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountSubscribeRespMsg
         * @property {number|Long|null} [RequestId] AccountSubscribeRespMsg RequestId
         * @property {boolean|null} [Success] AccountSubscribeRespMsg Success
         * @property {string|null} [Reason] AccountSubscribeRespMsg Reason
         */

        /**
         * Constructs a new AccountSubscribeRespMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountSubscribeRespMsg.
         * @implements IAccountSubscribeRespMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountSubscribeRespMsg=} [properties] Properties to set
         */
        function AccountSubscribeRespMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountSubscribeRespMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.AccountSubscribeRespMsg
         * @instance
         */
        AccountSubscribeRespMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountSubscribeRespMsg Success.
         * @member {boolean} Success
         * @memberof PropTradingProtocol.AccountSubscribeRespMsg
         * @instance
         */
        AccountSubscribeRespMsg.prototype.Success = false;

        /**
         * AccountSubscribeRespMsg Reason.
         * @member {string} Reason
         * @memberof PropTradingProtocol.AccountSubscribeRespMsg
         * @instance
         */
        AccountSubscribeRespMsg.prototype.Reason = "";

        /**
         * Creates a new AccountSubscribeRespMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountSubscribeRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountSubscribeRespMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountSubscribeRespMsg} AccountSubscribeRespMsg instance
         */
        AccountSubscribeRespMsg.create = function create(properties) {
            return new AccountSubscribeRespMsg(properties);
        };

        /**
         * Encodes the specified AccountSubscribeRespMsg message. Does not implicitly {@link PropTradingProtocol.AccountSubscribeRespMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountSubscribeRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountSubscribeRespMsg} message AccountSubscribeRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountSubscribeRespMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Success != null && Object.hasOwnProperty.call(message, "Success"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.Success);
            if (message.Reason != null && Object.hasOwnProperty.call(message, "Reason"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Reason);
            return writer;
        };

        /**
         * Encodes the specified AccountSubscribeRespMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountSubscribeRespMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountSubscribeRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountSubscribeRespMsg} message AccountSubscribeRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountSubscribeRespMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountSubscribeRespMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountSubscribeRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountSubscribeRespMsg} AccountSubscribeRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountSubscribeRespMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountSubscribeRespMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.Success = reader.bool();
                        break;
                    }
                case 3: {
                        message.Reason = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountSubscribeRespMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountSubscribeRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountSubscribeRespMsg} AccountSubscribeRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountSubscribeRespMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountSubscribeRespMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountSubscribeRespMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountSubscribeRespMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Success != null && message.hasOwnProperty("Success"))
                if (typeof message.Success !== "boolean")
                    return "Success: boolean expected";
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                if (!$util.isString(message.Reason))
                    return "Reason: string expected";
            return null;
        };

        /**
         * Creates an AccountSubscribeRespMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountSubscribeRespMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountSubscribeRespMsg} AccountSubscribeRespMsg
         */
        AccountSubscribeRespMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountSubscribeRespMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountSubscribeRespMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Success != null)
                message.Success = Boolean(object.Success);
            if (object.Reason != null)
                message.Reason = String(object.Reason);
            return message;
        };

        /**
         * Creates a plain object from an AccountSubscribeRespMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountSubscribeRespMsg
         * @static
         * @param {PropTradingProtocol.AccountSubscribeRespMsg} message AccountSubscribeRespMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountSubscribeRespMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.Success = false;
                object.Reason = "";
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Success != null && message.hasOwnProperty("Success"))
                object.Success = message.Success;
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                object.Reason = message.Reason;
            return object;
        };

        /**
         * Converts this AccountSubscribeRespMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountSubscribeRespMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountSubscribeRespMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountSubscribeRespMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountSubscribeRespMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountSubscribeRespMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountSubscribeRespMsg";
        };

        return AccountSubscribeRespMsg;
    })();

    PropTradingProtocol.OrderMsg = (function() {

        /**
         * Properties of an OrderMsg.
         * @memberof PropTradingProtocol
         * @interface IOrderMsg
         * @property {PropTradingProtocol.IOrderInsertMsg|null} [OrderInsert] OrderMsg OrderInsert
         * @property {PropTradingProtocol.IOrderRemoveMsg|null} [OrderRemove] OrderMsg OrderRemove
         * @property {PropTradingProtocol.IOrderModifyMsg|null} [OrderModify] OrderMsg OrderModify
         * @property {PropTradingProtocol.IBracketStrageyInsertMsg|null} [BracketStrategyInsert] OrderMsg BracketStrategyInsert
         * @property {PropTradingProtocol.IBracketModifyMsg|null} [BracketModify] OrderMsg BracketModify
         * @property {PropTradingProtocol.IOcoGroupCreateMsg|null} [OcoGroupCreate] OrderMsg OcoGroupCreate
         * @property {PropTradingProtocol.IOcoGroupRemoveMsg|null} [OcoGroupRemove] OrderMsg OcoGroupRemove
         * @property {PropTradingProtocol.IPositionFlatMsg|null} [PositionFlatMsg] OrderMsg PositionFlatMsg
         * @property {PropTradingProtocol.IBracketInsertMsg|null} [BracketInsert] OrderMsg BracketInsert
         * @property {PropTradingProtocol.IBracketRemoveMsg|null} [BracketRemove] OrderMsg BracketRemove
         */

        /**
         * Constructs a new OrderMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an OrderMsg.
         * @implements IOrderMsg
         * @constructor
         * @param {PropTradingProtocol.IOrderMsg=} [properties] Properties to set
         */
        function OrderMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderMsg OrderInsert.
         * @member {PropTradingProtocol.IOrderInsertMsg|null|undefined} OrderInsert
         * @memberof PropTradingProtocol.OrderMsg
         * @instance
         */
        OrderMsg.prototype.OrderInsert = null;

        /**
         * OrderMsg OrderRemove.
         * @member {PropTradingProtocol.IOrderRemoveMsg|null|undefined} OrderRemove
         * @memberof PropTradingProtocol.OrderMsg
         * @instance
         */
        OrderMsg.prototype.OrderRemove = null;

        /**
         * OrderMsg OrderModify.
         * @member {PropTradingProtocol.IOrderModifyMsg|null|undefined} OrderModify
         * @memberof PropTradingProtocol.OrderMsg
         * @instance
         */
        OrderMsg.prototype.OrderModify = null;

        /**
         * OrderMsg BracketStrategyInsert.
         * @member {PropTradingProtocol.IBracketStrageyInsertMsg|null|undefined} BracketStrategyInsert
         * @memberof PropTradingProtocol.OrderMsg
         * @instance
         */
        OrderMsg.prototype.BracketStrategyInsert = null;

        /**
         * OrderMsg BracketModify.
         * @member {PropTradingProtocol.IBracketModifyMsg|null|undefined} BracketModify
         * @memberof PropTradingProtocol.OrderMsg
         * @instance
         */
        OrderMsg.prototype.BracketModify = null;

        /**
         * OrderMsg OcoGroupCreate.
         * @member {PropTradingProtocol.IOcoGroupCreateMsg|null|undefined} OcoGroupCreate
         * @memberof PropTradingProtocol.OrderMsg
         * @instance
         */
        OrderMsg.prototype.OcoGroupCreate = null;

        /**
         * OrderMsg OcoGroupRemove.
         * @member {PropTradingProtocol.IOcoGroupRemoveMsg|null|undefined} OcoGroupRemove
         * @memberof PropTradingProtocol.OrderMsg
         * @instance
         */
        OrderMsg.prototype.OcoGroupRemove = null;

        /**
         * OrderMsg PositionFlatMsg.
         * @member {PropTradingProtocol.IPositionFlatMsg|null|undefined} PositionFlatMsg
         * @memberof PropTradingProtocol.OrderMsg
         * @instance
         */
        OrderMsg.prototype.PositionFlatMsg = null;

        /**
         * OrderMsg BracketInsert.
         * @member {PropTradingProtocol.IBracketInsertMsg|null|undefined} BracketInsert
         * @memberof PropTradingProtocol.OrderMsg
         * @instance
         */
        OrderMsg.prototype.BracketInsert = null;

        /**
         * OrderMsg BracketRemove.
         * @member {PropTradingProtocol.IBracketRemoveMsg|null|undefined} BracketRemove
         * @memberof PropTradingProtocol.OrderMsg
         * @instance
         */
        OrderMsg.prototype.BracketRemove = null;

        /**
         * Creates a new OrderMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.OrderMsg
         * @static
         * @param {PropTradingProtocol.IOrderMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.OrderMsg} OrderMsg instance
         */
        OrderMsg.create = function create(properties) {
            return new OrderMsg(properties);
        };

        /**
         * Encodes the specified OrderMsg message. Does not implicitly {@link PropTradingProtocol.OrderMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.OrderMsg
         * @static
         * @param {PropTradingProtocol.IOrderMsg} message OrderMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.OrderInsert != null && Object.hasOwnProperty.call(message, "OrderInsert"))
                $root.PropTradingProtocol.OrderInsertMsg.encode(message.OrderInsert, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.OrderRemove != null && Object.hasOwnProperty.call(message, "OrderRemove"))
                $root.PropTradingProtocol.OrderRemoveMsg.encode(message.OrderRemove, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.OrderModify != null && Object.hasOwnProperty.call(message, "OrderModify"))
                $root.PropTradingProtocol.OrderModifyMsg.encode(message.OrderModify, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.BracketStrategyInsert != null && Object.hasOwnProperty.call(message, "BracketStrategyInsert"))
                $root.PropTradingProtocol.BracketStrageyInsertMsg.encode(message.BracketStrategyInsert, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.BracketModify != null && Object.hasOwnProperty.call(message, "BracketModify"))
                $root.PropTradingProtocol.BracketModifyMsg.encode(message.BracketModify, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.OcoGroupCreate != null && Object.hasOwnProperty.call(message, "OcoGroupCreate"))
                $root.PropTradingProtocol.OcoGroupCreateMsg.encode(message.OcoGroupCreate, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.OcoGroupRemove != null && Object.hasOwnProperty.call(message, "OcoGroupRemove"))
                $root.PropTradingProtocol.OcoGroupRemoveMsg.encode(message.OcoGroupRemove, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.PositionFlatMsg != null && Object.hasOwnProperty.call(message, "PositionFlatMsg"))
                $root.PropTradingProtocol.PositionFlatMsg.encode(message.PositionFlatMsg, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.BracketInsert != null && Object.hasOwnProperty.call(message, "BracketInsert"))
                $root.PropTradingProtocol.BracketInsertMsg.encode(message.BracketInsert, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.BracketRemove != null && Object.hasOwnProperty.call(message, "BracketRemove"))
                $root.PropTradingProtocol.BracketRemoveMsg.encode(message.BracketRemove, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OrderMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.OrderMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.OrderMsg
         * @static
         * @param {PropTradingProtocol.IOrderMsg} message OrderMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OrderMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.OrderMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.OrderMsg} OrderMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.OrderMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.OrderInsert = $root.PropTradingProtocol.OrderInsertMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.OrderRemove = $root.PropTradingProtocol.OrderRemoveMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.OrderModify = $root.PropTradingProtocol.OrderModifyMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.BracketStrategyInsert = $root.PropTradingProtocol.BracketStrageyInsertMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.BracketModify = $root.PropTradingProtocol.BracketModifyMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.OcoGroupCreate = $root.PropTradingProtocol.OcoGroupCreateMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.OcoGroupRemove = $root.PropTradingProtocol.OcoGroupRemoveMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.PositionFlatMsg = $root.PropTradingProtocol.PositionFlatMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.BracketInsert = $root.PropTradingProtocol.BracketInsertMsg.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.BracketRemove = $root.PropTradingProtocol.BracketRemoveMsg.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OrderMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.OrderMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.OrderMsg} OrderMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OrderMsg message.
         * @function verify
         * @memberof PropTradingProtocol.OrderMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.OrderInsert != null && message.hasOwnProperty("OrderInsert")) {
                let error = $root.PropTradingProtocol.OrderInsertMsg.verify(message.OrderInsert);
                if (error)
                    return "OrderInsert." + error;
            }
            if (message.OrderRemove != null && message.hasOwnProperty("OrderRemove")) {
                let error = $root.PropTradingProtocol.OrderRemoveMsg.verify(message.OrderRemove);
                if (error)
                    return "OrderRemove." + error;
            }
            if (message.OrderModify != null && message.hasOwnProperty("OrderModify")) {
                let error = $root.PropTradingProtocol.OrderModifyMsg.verify(message.OrderModify);
                if (error)
                    return "OrderModify." + error;
            }
            if (message.BracketStrategyInsert != null && message.hasOwnProperty("BracketStrategyInsert")) {
                let error = $root.PropTradingProtocol.BracketStrageyInsertMsg.verify(message.BracketStrategyInsert);
                if (error)
                    return "BracketStrategyInsert." + error;
            }
            if (message.BracketModify != null && message.hasOwnProperty("BracketModify")) {
                let error = $root.PropTradingProtocol.BracketModifyMsg.verify(message.BracketModify);
                if (error)
                    return "BracketModify." + error;
            }
            if (message.OcoGroupCreate != null && message.hasOwnProperty("OcoGroupCreate")) {
                let error = $root.PropTradingProtocol.OcoGroupCreateMsg.verify(message.OcoGroupCreate);
                if (error)
                    return "OcoGroupCreate." + error;
            }
            if (message.OcoGroupRemove != null && message.hasOwnProperty("OcoGroupRemove")) {
                let error = $root.PropTradingProtocol.OcoGroupRemoveMsg.verify(message.OcoGroupRemove);
                if (error)
                    return "OcoGroupRemove." + error;
            }
            if (message.PositionFlatMsg != null && message.hasOwnProperty("PositionFlatMsg")) {
                let error = $root.PropTradingProtocol.PositionFlatMsg.verify(message.PositionFlatMsg);
                if (error)
                    return "PositionFlatMsg." + error;
            }
            if (message.BracketInsert != null && message.hasOwnProperty("BracketInsert")) {
                let error = $root.PropTradingProtocol.BracketInsertMsg.verify(message.BracketInsert);
                if (error)
                    return "BracketInsert." + error;
            }
            if (message.BracketRemove != null && message.hasOwnProperty("BracketRemove")) {
                let error = $root.PropTradingProtocol.BracketRemoveMsg.verify(message.BracketRemove);
                if (error)
                    return "BracketRemove." + error;
            }
            return null;
        };

        /**
         * Creates an OrderMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.OrderMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.OrderMsg} OrderMsg
         */
        OrderMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.OrderMsg)
                return object;
            let message = new $root.PropTradingProtocol.OrderMsg();
            if (object.OrderInsert != null) {
                if (typeof object.OrderInsert !== "object")
                    throw TypeError(".PropTradingProtocol.OrderMsg.OrderInsert: object expected");
                message.OrderInsert = $root.PropTradingProtocol.OrderInsertMsg.fromObject(object.OrderInsert);
            }
            if (object.OrderRemove != null) {
                if (typeof object.OrderRemove !== "object")
                    throw TypeError(".PropTradingProtocol.OrderMsg.OrderRemove: object expected");
                message.OrderRemove = $root.PropTradingProtocol.OrderRemoveMsg.fromObject(object.OrderRemove);
            }
            if (object.OrderModify != null) {
                if (typeof object.OrderModify !== "object")
                    throw TypeError(".PropTradingProtocol.OrderMsg.OrderModify: object expected");
                message.OrderModify = $root.PropTradingProtocol.OrderModifyMsg.fromObject(object.OrderModify);
            }
            if (object.BracketStrategyInsert != null) {
                if (typeof object.BracketStrategyInsert !== "object")
                    throw TypeError(".PropTradingProtocol.OrderMsg.BracketStrategyInsert: object expected");
                message.BracketStrategyInsert = $root.PropTradingProtocol.BracketStrageyInsertMsg.fromObject(object.BracketStrategyInsert);
            }
            if (object.BracketModify != null) {
                if (typeof object.BracketModify !== "object")
                    throw TypeError(".PropTradingProtocol.OrderMsg.BracketModify: object expected");
                message.BracketModify = $root.PropTradingProtocol.BracketModifyMsg.fromObject(object.BracketModify);
            }
            if (object.OcoGroupCreate != null) {
                if (typeof object.OcoGroupCreate !== "object")
                    throw TypeError(".PropTradingProtocol.OrderMsg.OcoGroupCreate: object expected");
                message.OcoGroupCreate = $root.PropTradingProtocol.OcoGroupCreateMsg.fromObject(object.OcoGroupCreate);
            }
            if (object.OcoGroupRemove != null) {
                if (typeof object.OcoGroupRemove !== "object")
                    throw TypeError(".PropTradingProtocol.OrderMsg.OcoGroupRemove: object expected");
                message.OcoGroupRemove = $root.PropTradingProtocol.OcoGroupRemoveMsg.fromObject(object.OcoGroupRemove);
            }
            if (object.PositionFlatMsg != null) {
                if (typeof object.PositionFlatMsg !== "object")
                    throw TypeError(".PropTradingProtocol.OrderMsg.PositionFlatMsg: object expected");
                message.PositionFlatMsg = $root.PropTradingProtocol.PositionFlatMsg.fromObject(object.PositionFlatMsg);
            }
            if (object.BracketInsert != null) {
                if (typeof object.BracketInsert !== "object")
                    throw TypeError(".PropTradingProtocol.OrderMsg.BracketInsert: object expected");
                message.BracketInsert = $root.PropTradingProtocol.BracketInsertMsg.fromObject(object.BracketInsert);
            }
            if (object.BracketRemove != null) {
                if (typeof object.BracketRemove !== "object")
                    throw TypeError(".PropTradingProtocol.OrderMsg.BracketRemove: object expected");
                message.BracketRemove = $root.PropTradingProtocol.BracketRemoveMsg.fromObject(object.BracketRemove);
            }
            return message;
        };

        /**
         * Creates a plain object from an OrderMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.OrderMsg
         * @static
         * @param {PropTradingProtocol.OrderMsg} message OrderMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.OrderInsert = null;
                object.OrderRemove = null;
                object.OrderModify = null;
                object.BracketStrategyInsert = null;
                object.BracketModify = null;
                object.OcoGroupCreate = null;
                object.OcoGroupRemove = null;
                object.PositionFlatMsg = null;
                object.BracketInsert = null;
                object.BracketRemove = null;
            }
            if (message.OrderInsert != null && message.hasOwnProperty("OrderInsert"))
                object.OrderInsert = $root.PropTradingProtocol.OrderInsertMsg.toObject(message.OrderInsert, options);
            if (message.OrderRemove != null && message.hasOwnProperty("OrderRemove"))
                object.OrderRemove = $root.PropTradingProtocol.OrderRemoveMsg.toObject(message.OrderRemove, options);
            if (message.OrderModify != null && message.hasOwnProperty("OrderModify"))
                object.OrderModify = $root.PropTradingProtocol.OrderModifyMsg.toObject(message.OrderModify, options);
            if (message.BracketStrategyInsert != null && message.hasOwnProperty("BracketStrategyInsert"))
                object.BracketStrategyInsert = $root.PropTradingProtocol.BracketStrageyInsertMsg.toObject(message.BracketStrategyInsert, options);
            if (message.BracketModify != null && message.hasOwnProperty("BracketModify"))
                object.BracketModify = $root.PropTradingProtocol.BracketModifyMsg.toObject(message.BracketModify, options);
            if (message.OcoGroupCreate != null && message.hasOwnProperty("OcoGroupCreate"))
                object.OcoGroupCreate = $root.PropTradingProtocol.OcoGroupCreateMsg.toObject(message.OcoGroupCreate, options);
            if (message.OcoGroupRemove != null && message.hasOwnProperty("OcoGroupRemove"))
                object.OcoGroupRemove = $root.PropTradingProtocol.OcoGroupRemoveMsg.toObject(message.OcoGroupRemove, options);
            if (message.PositionFlatMsg != null && message.hasOwnProperty("PositionFlatMsg"))
                object.PositionFlatMsg = $root.PropTradingProtocol.PositionFlatMsg.toObject(message.PositionFlatMsg, options);
            if (message.BracketInsert != null && message.hasOwnProperty("BracketInsert"))
                object.BracketInsert = $root.PropTradingProtocol.BracketInsertMsg.toObject(message.BracketInsert, options);
            if (message.BracketRemove != null && message.hasOwnProperty("BracketRemove"))
                object.BracketRemove = $root.PropTradingProtocol.BracketRemoveMsg.toObject(message.BracketRemove, options);
            return object;
        };

        /**
         * Converts this OrderMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.OrderMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OrderMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.OrderMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OrderMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.OrderMsg";
        };

        return OrderMsg;
    })();

    /**
     * OrderTypeEnum enum.
     * @name PropTradingProtocol.OrderTypeEnum
     * @enum {number}
     * @property {number} Market=0 Market value
     * @property {number} Limit=1 Limit value
     * @property {number} Stop=2 Stop value
     * @property {number} StopLimit=3 StopLimit value
     */
    PropTradingProtocol.OrderTypeEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Market"] = 0;
        values[valuesById[1] = "Limit"] = 1;
        values[valuesById[2] = "Stop"] = 2;
        values[valuesById[3] = "StopLimit"] = 3;
        return values;
    })();

    /**
     * OrderExpireEnum enum.
     * @name PropTradingProtocol.OrderExpireEnum
     * @enum {number}
     * @property {number} Never=1 Never value
     * @property {number} TillDay=2 TillDay value
     */
    PropTradingProtocol.OrderExpireEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "Never"] = 1;
        values[valuesById[2] = "TillDay"] = 2;
        return values;
    })();

    /**
     * RequestSourceEnum enum.
     * @name PropTradingProtocol.RequestSourceEnum
     * @enum {number}
     * @property {number} Unknown=0 Unknown value
     * @property {number} Manual=1 Manual value
     * @property {number} Automatic=2 Automatic value
     * @property {number} Copy=3 Copy value
     */
    PropTradingProtocol.RequestSourceEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Unknown"] = 0;
        values[valuesById[1] = "Manual"] = 1;
        values[valuesById[2] = "Automatic"] = 2;
        values[valuesById[3] = "Copy"] = 3;
        return values;
    })();

    /**
     * OrderQuantityModeEnum enum.
     * @name PropTradingProtocol.OrderQuantityModeEnum
     * @enum {number}
     * @property {number} Fixed=0 Fixed value
     * @property {number} All=1 All value
     * @property {number} AccountCountervalue=2 AccountCountervalue value
     */
    PropTradingProtocol.OrderQuantityModeEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Fixed"] = 0;
        values[valuesById[1] = "All"] = 1;
        values[valuesById[2] = "AccountCountervalue"] = 2;
        return values;
    })();

    PropTradingProtocol.OrderInsertMsg = (function() {

        /**
         * Properties of an OrderInsertMsg.
         * @memberof PropTradingProtocol
         * @interface IOrderInsertMsg
         * @property {number|Long|null} [ContractId] OrderInsertMsg ContractId
         * @property {number|null} [SeqClientId] OrderInsertMsg SeqClientId
         * @property {number|null} [Quantity] OrderInsertMsg Quantity
         * @property {number|null} [Price] OrderInsertMsg Price
         * @property {PropTradingProtocol.OrderTypeEnum|null} [OrderType] OrderInsertMsg OrderType
         * @property {number|Long|null} [AccNumber] OrderInsertMsg AccNumber
         * @property {number|null} [LimitPrice] OrderInsertMsg LimitPrice
         * @property {PropTradingProtocol.IBracketStrategyParam|null} [BracketStrategy] OrderInsertMsg BracketStrategy
         * @property {number|Long|null} [RefPositionId] OrderInsertMsg RefPositionId
         * @property {PropTradingProtocol.RequestSourceEnum|null} [Source] OrderInsertMsg Source
         * @property {PropTradingProtocol.OrderQuantityModeEnum|null} [QuantityMode] OrderInsertMsg QuantityMode
         */

        /**
         * Constructs a new OrderInsertMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an OrderInsertMsg.
         * @implements IOrderInsertMsg
         * @constructor
         * @param {PropTradingProtocol.IOrderInsertMsg=} [properties] Properties to set
         */
        function OrderInsertMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderInsertMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @instance
         */
        OrderInsertMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderInsertMsg SeqClientId.
         * @member {number} SeqClientId
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @instance
         */
        OrderInsertMsg.prototype.SeqClientId = 0;

        /**
         * OrderInsertMsg Quantity.
         * @member {number} Quantity
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @instance
         */
        OrderInsertMsg.prototype.Quantity = 0;

        /**
         * OrderInsertMsg Price.
         * @member {number} Price
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @instance
         */
        OrderInsertMsg.prototype.Price = 0;

        /**
         * OrderInsertMsg OrderType.
         * @member {PropTradingProtocol.OrderTypeEnum} OrderType
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @instance
         */
        OrderInsertMsg.prototype.OrderType = 0;

        /**
         * OrderInsertMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @instance
         */
        OrderInsertMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderInsertMsg LimitPrice.
         * @member {number} LimitPrice
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @instance
         */
        OrderInsertMsg.prototype.LimitPrice = 0;

        /**
         * OrderInsertMsg BracketStrategy.
         * @member {PropTradingProtocol.IBracketStrategyParam|null|undefined} BracketStrategy
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @instance
         */
        OrderInsertMsg.prototype.BracketStrategy = null;

        /**
         * OrderInsertMsg RefPositionId.
         * @member {number|Long} RefPositionId
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @instance
         */
        OrderInsertMsg.prototype.RefPositionId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderInsertMsg Source.
         * @member {PropTradingProtocol.RequestSourceEnum} Source
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @instance
         */
        OrderInsertMsg.prototype.Source = 0;

        /**
         * OrderInsertMsg QuantityMode.
         * @member {PropTradingProtocol.OrderQuantityModeEnum} QuantityMode
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @instance
         */
        OrderInsertMsg.prototype.QuantityMode = 0;

        /**
         * Creates a new OrderInsertMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @static
         * @param {PropTradingProtocol.IOrderInsertMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.OrderInsertMsg} OrderInsertMsg instance
         */
        OrderInsertMsg.create = function create(properties) {
            return new OrderInsertMsg(properties);
        };

        /**
         * Encodes the specified OrderInsertMsg message. Does not implicitly {@link PropTradingProtocol.OrderInsertMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @static
         * @param {PropTradingProtocol.IOrderInsertMsg} message OrderInsertMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderInsertMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.ContractId);
            if (message.SeqClientId != null && Object.hasOwnProperty.call(message, "SeqClientId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.SeqClientId);
            if (message.Quantity != null && Object.hasOwnProperty.call(message, "Quantity"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Quantity);
            if (message.Price != null && Object.hasOwnProperty.call(message, "Price"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.Price);
            if (message.OrderType != null && Object.hasOwnProperty.call(message, "OrderType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.OrderType);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 6, wireType 0 =*/48).sint64(message.AccNumber);
            if (message.LimitPrice != null && Object.hasOwnProperty.call(message, "LimitPrice"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.LimitPrice);
            if (message.BracketStrategy != null && Object.hasOwnProperty.call(message, "BracketStrategy"))
                $root.PropTradingProtocol.BracketStrategyParam.encode(message.BracketStrategy, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.RefPositionId != null && Object.hasOwnProperty.call(message, "RefPositionId"))
                writer.uint32(/* id 9, wireType 0 =*/72).sint64(message.RefPositionId);
            if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.Source);
            if (message.QuantityMode != null && Object.hasOwnProperty.call(message, "QuantityMode"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.QuantityMode);
            return writer;
        };

        /**
         * Encodes the specified OrderInsertMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.OrderInsertMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @static
         * @param {PropTradingProtocol.IOrderInsertMsg} message OrderInsertMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderInsertMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OrderInsertMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.OrderInsertMsg} OrderInsertMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderInsertMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.OrderInsertMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.SeqClientId = reader.int32();
                        break;
                    }
                case 3: {
                        message.Quantity = reader.int32();
                        break;
                    }
                case 4: {
                        message.Price = reader.double();
                        break;
                    }
                case 5: {
                        message.OrderType = reader.int32();
                        break;
                    }
                case 6: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 7: {
                        message.LimitPrice = reader.double();
                        break;
                    }
                case 8: {
                        message.BracketStrategy = $root.PropTradingProtocol.BracketStrategyParam.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.RefPositionId = reader.sint64();
                        break;
                    }
                case 10: {
                        message.Source = reader.int32();
                        break;
                    }
                case 11: {
                        message.QuantityMode = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OrderInsertMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.OrderInsertMsg} OrderInsertMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderInsertMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OrderInsertMsg message.
         * @function verify
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderInsertMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.SeqClientId != null && message.hasOwnProperty("SeqClientId"))
                if (!$util.isInteger(message.SeqClientId))
                    return "SeqClientId: integer expected";
            if (message.Quantity != null && message.hasOwnProperty("Quantity"))
                if (!$util.isInteger(message.Quantity))
                    return "Quantity: integer expected";
            if (message.Price != null && message.hasOwnProperty("Price"))
                if (typeof message.Price !== "number")
                    return "Price: number expected";
            if (message.OrderType != null && message.hasOwnProperty("OrderType"))
                switch (message.OrderType) {
                default:
                    return "OrderType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.LimitPrice != null && message.hasOwnProperty("LimitPrice"))
                if (typeof message.LimitPrice !== "number")
                    return "LimitPrice: number expected";
            if (message.BracketStrategy != null && message.hasOwnProperty("BracketStrategy")) {
                let error = $root.PropTradingProtocol.BracketStrategyParam.verify(message.BracketStrategy);
                if (error)
                    return "BracketStrategy." + error;
            }
            if (message.RefPositionId != null && message.hasOwnProperty("RefPositionId"))
                if (!$util.isInteger(message.RefPositionId) && !(message.RefPositionId && $util.isInteger(message.RefPositionId.low) && $util.isInteger(message.RefPositionId.high)))
                    return "RefPositionId: integer|Long expected";
            if (message.Source != null && message.hasOwnProperty("Source"))
                switch (message.Source) {
                default:
                    return "Source: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.QuantityMode != null && message.hasOwnProperty("QuantityMode"))
                switch (message.QuantityMode) {
                default:
                    return "QuantityMode: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates an OrderInsertMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.OrderInsertMsg} OrderInsertMsg
         */
        OrderInsertMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.OrderInsertMsg)
                return object;
            let message = new $root.PropTradingProtocol.OrderInsertMsg();
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.SeqClientId != null)
                message.SeqClientId = object.SeqClientId | 0;
            if (object.Quantity != null)
                message.Quantity = object.Quantity | 0;
            if (object.Price != null)
                message.Price = Number(object.Price);
            switch (object.OrderType) {
            default:
                if (typeof object.OrderType === "number") {
                    message.OrderType = object.OrderType;
                    break;
                }
                break;
            case "Market":
            case 0:
                message.OrderType = 0;
                break;
            case "Limit":
            case 1:
                message.OrderType = 1;
                break;
            case "Stop":
            case 2:
                message.OrderType = 2;
                break;
            case "StopLimit":
            case 3:
                message.OrderType = 3;
                break;
            }
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            if (object.LimitPrice != null)
                message.LimitPrice = Number(object.LimitPrice);
            if (object.BracketStrategy != null) {
                if (typeof object.BracketStrategy !== "object")
                    throw TypeError(".PropTradingProtocol.OrderInsertMsg.BracketStrategy: object expected");
                message.BracketStrategy = $root.PropTradingProtocol.BracketStrategyParam.fromObject(object.BracketStrategy);
            }
            if (object.RefPositionId != null)
                if ($util.Long)
                    (message.RefPositionId = $util.Long.fromValue(object.RefPositionId)).unsigned = false;
                else if (typeof object.RefPositionId === "string")
                    message.RefPositionId = parseInt(object.RefPositionId, 10);
                else if (typeof object.RefPositionId === "number")
                    message.RefPositionId = object.RefPositionId;
                else if (typeof object.RefPositionId === "object")
                    message.RefPositionId = new $util.LongBits(object.RefPositionId.low >>> 0, object.RefPositionId.high >>> 0).toNumber();
            switch (object.Source) {
            default:
                if (typeof object.Source === "number") {
                    message.Source = object.Source;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.Source = 0;
                break;
            case "Manual":
            case 1:
                message.Source = 1;
                break;
            case "Automatic":
            case 2:
                message.Source = 2;
                break;
            case "Copy":
            case 3:
                message.Source = 3;
                break;
            }
            switch (object.QuantityMode) {
            default:
                if (typeof object.QuantityMode === "number") {
                    message.QuantityMode = object.QuantityMode;
                    break;
                }
                break;
            case "Fixed":
            case 0:
                message.QuantityMode = 0;
                break;
            case "All":
            case 1:
                message.QuantityMode = 1;
                break;
            case "AccountCountervalue":
            case 2:
                message.QuantityMode = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an OrderInsertMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @static
         * @param {PropTradingProtocol.OrderInsertMsg} message OrderInsertMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderInsertMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                object.SeqClientId = 0;
                object.Quantity = 0;
                object.Price = 0;
                object.OrderType = options.enums === String ? "Market" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                object.LimitPrice = 0;
                object.BracketStrategy = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RefPositionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RefPositionId = options.longs === String ? "0" : 0;
                object.Source = options.enums === String ? "Unknown" : 0;
                object.QuantityMode = options.enums === String ? "Fixed" : 0;
            }
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.SeqClientId != null && message.hasOwnProperty("SeqClientId"))
                object.SeqClientId = message.SeqClientId;
            if (message.Quantity != null && message.hasOwnProperty("Quantity"))
                object.Quantity = message.Quantity;
            if (message.Price != null && message.hasOwnProperty("Price"))
                object.Price = options.json && !isFinite(message.Price) ? String(message.Price) : message.Price;
            if (message.OrderType != null && message.hasOwnProperty("OrderType"))
                object.OrderType = options.enums === String ? $root.PropTradingProtocol.OrderTypeEnum[message.OrderType] === undefined ? message.OrderType : $root.PropTradingProtocol.OrderTypeEnum[message.OrderType] : message.OrderType;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.LimitPrice != null && message.hasOwnProperty("LimitPrice"))
                object.LimitPrice = options.json && !isFinite(message.LimitPrice) ? String(message.LimitPrice) : message.LimitPrice;
            if (message.BracketStrategy != null && message.hasOwnProperty("BracketStrategy"))
                object.BracketStrategy = $root.PropTradingProtocol.BracketStrategyParam.toObject(message.BracketStrategy, options);
            if (message.RefPositionId != null && message.hasOwnProperty("RefPositionId"))
                if (typeof message.RefPositionId === "number")
                    object.RefPositionId = options.longs === String ? String(message.RefPositionId) : message.RefPositionId;
                else
                    object.RefPositionId = options.longs === String ? $util.Long.prototype.toString.call(message.RefPositionId) : options.longs === Number ? new $util.LongBits(message.RefPositionId.low >>> 0, message.RefPositionId.high >>> 0).toNumber() : message.RefPositionId;
            if (message.Source != null && message.hasOwnProperty("Source"))
                object.Source = options.enums === String ? $root.PropTradingProtocol.RequestSourceEnum[message.Source] === undefined ? message.Source : $root.PropTradingProtocol.RequestSourceEnum[message.Source] : message.Source;
            if (message.QuantityMode != null && message.hasOwnProperty("QuantityMode"))
                object.QuantityMode = options.enums === String ? $root.PropTradingProtocol.OrderQuantityModeEnum[message.QuantityMode] === undefined ? message.QuantityMode : $root.PropTradingProtocol.OrderQuantityModeEnum[message.QuantityMode] : message.QuantityMode;
            return object;
        };

        /**
         * Converts this OrderInsertMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderInsertMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OrderInsertMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.OrderInsertMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OrderInsertMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.OrderInsertMsg";
        };

        return OrderInsertMsg;
    })();

    PropTradingProtocol.OrderModifyMsg = (function() {

        /**
         * Properties of an OrderModifyMsg.
         * @memberof PropTradingProtocol
         * @interface IOrderModifyMsg
         * @property {number|Long|null} [ContractId] OrderModifyMsg ContractId
         * @property {number|Long|null} [OrgServerId] OrderModifyMsg OrgServerId
         * @property {number|null} [NewSeqClientId] OrderModifyMsg NewSeqClientId
         * @property {number|null} [Quantity] OrderModifyMsg Quantity
         * @property {number|null} [Price] OrderModifyMsg Price
         * @property {number|Long|null} [AccNumber] OrderModifyMsg AccNumber
         * @property {number|null} [LimitPrice] OrderModifyMsg LimitPrice
         * @property {PropTradingProtocol.RequestSourceEnum|null} [Source] OrderModifyMsg Source
         */

        /**
         * Constructs a new OrderModifyMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an OrderModifyMsg.
         * @implements IOrderModifyMsg
         * @constructor
         * @param {PropTradingProtocol.IOrderModifyMsg=} [properties] Properties to set
         */
        function OrderModifyMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderModifyMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @instance
         */
        OrderModifyMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderModifyMsg OrgServerId.
         * @member {number|Long} OrgServerId
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @instance
         */
        OrderModifyMsg.prototype.OrgServerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderModifyMsg NewSeqClientId.
         * @member {number} NewSeqClientId
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @instance
         */
        OrderModifyMsg.prototype.NewSeqClientId = 0;

        /**
         * OrderModifyMsg Quantity.
         * @member {number} Quantity
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @instance
         */
        OrderModifyMsg.prototype.Quantity = 0;

        /**
         * OrderModifyMsg Price.
         * @member {number} Price
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @instance
         */
        OrderModifyMsg.prototype.Price = 0;

        /**
         * OrderModifyMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @instance
         */
        OrderModifyMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderModifyMsg LimitPrice.
         * @member {number} LimitPrice
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @instance
         */
        OrderModifyMsg.prototype.LimitPrice = 0;

        /**
         * OrderModifyMsg Source.
         * @member {PropTradingProtocol.RequestSourceEnum} Source
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @instance
         */
        OrderModifyMsg.prototype.Source = 0;

        /**
         * Creates a new OrderModifyMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @static
         * @param {PropTradingProtocol.IOrderModifyMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.OrderModifyMsg} OrderModifyMsg instance
         */
        OrderModifyMsg.create = function create(properties) {
            return new OrderModifyMsg(properties);
        };

        /**
         * Encodes the specified OrderModifyMsg message. Does not implicitly {@link PropTradingProtocol.OrderModifyMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @static
         * @param {PropTradingProtocol.IOrderModifyMsg} message OrderModifyMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderModifyMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.ContractId);
            if (message.OrgServerId != null && Object.hasOwnProperty.call(message, "OrgServerId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.OrgServerId);
            if (message.NewSeqClientId != null && Object.hasOwnProperty.call(message, "NewSeqClientId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.NewSeqClientId);
            if (message.Quantity != null && Object.hasOwnProperty.call(message, "Quantity"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Quantity);
            if (message.Price != null && Object.hasOwnProperty.call(message, "Price"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.Price);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 6, wireType 0 =*/48).sint64(message.AccNumber);
            if (message.LimitPrice != null && Object.hasOwnProperty.call(message, "LimitPrice"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.LimitPrice);
            if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Source);
            return writer;
        };

        /**
         * Encodes the specified OrderModifyMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.OrderModifyMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @static
         * @param {PropTradingProtocol.IOrderModifyMsg} message OrderModifyMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderModifyMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OrderModifyMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.OrderModifyMsg} OrderModifyMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderModifyMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.OrderModifyMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.OrgServerId = reader.sint64();
                        break;
                    }
                case 3: {
                        message.NewSeqClientId = reader.int32();
                        break;
                    }
                case 4: {
                        message.Quantity = reader.int32();
                        break;
                    }
                case 5: {
                        message.Price = reader.double();
                        break;
                    }
                case 6: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 7: {
                        message.LimitPrice = reader.double();
                        break;
                    }
                case 8: {
                        message.Source = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OrderModifyMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.OrderModifyMsg} OrderModifyMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderModifyMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OrderModifyMsg message.
         * @function verify
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderModifyMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.OrgServerId != null && message.hasOwnProperty("OrgServerId"))
                if (!$util.isInteger(message.OrgServerId) && !(message.OrgServerId && $util.isInteger(message.OrgServerId.low) && $util.isInteger(message.OrgServerId.high)))
                    return "OrgServerId: integer|Long expected";
            if (message.NewSeqClientId != null && message.hasOwnProperty("NewSeqClientId"))
                if (!$util.isInteger(message.NewSeqClientId))
                    return "NewSeqClientId: integer expected";
            if (message.Quantity != null && message.hasOwnProperty("Quantity"))
                if (!$util.isInteger(message.Quantity))
                    return "Quantity: integer expected";
            if (message.Price != null && message.hasOwnProperty("Price"))
                if (typeof message.Price !== "number")
                    return "Price: number expected";
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.LimitPrice != null && message.hasOwnProperty("LimitPrice"))
                if (typeof message.LimitPrice !== "number")
                    return "LimitPrice: number expected";
            if (message.Source != null && message.hasOwnProperty("Source"))
                switch (message.Source) {
                default:
                    return "Source: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates an OrderModifyMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.OrderModifyMsg} OrderModifyMsg
         */
        OrderModifyMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.OrderModifyMsg)
                return object;
            let message = new $root.PropTradingProtocol.OrderModifyMsg();
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.OrgServerId != null)
                if ($util.Long)
                    (message.OrgServerId = $util.Long.fromValue(object.OrgServerId)).unsigned = false;
                else if (typeof object.OrgServerId === "string")
                    message.OrgServerId = parseInt(object.OrgServerId, 10);
                else if (typeof object.OrgServerId === "number")
                    message.OrgServerId = object.OrgServerId;
                else if (typeof object.OrgServerId === "object")
                    message.OrgServerId = new $util.LongBits(object.OrgServerId.low >>> 0, object.OrgServerId.high >>> 0).toNumber();
            if (object.NewSeqClientId != null)
                message.NewSeqClientId = object.NewSeqClientId | 0;
            if (object.Quantity != null)
                message.Quantity = object.Quantity | 0;
            if (object.Price != null)
                message.Price = Number(object.Price);
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            if (object.LimitPrice != null)
                message.LimitPrice = Number(object.LimitPrice);
            switch (object.Source) {
            default:
                if (typeof object.Source === "number") {
                    message.Source = object.Source;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.Source = 0;
                break;
            case "Manual":
            case 1:
                message.Source = 1;
                break;
            case "Automatic":
            case 2:
                message.Source = 2;
                break;
            case "Copy":
            case 3:
                message.Source = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an OrderModifyMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @static
         * @param {PropTradingProtocol.OrderModifyMsg} message OrderModifyMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderModifyMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OrgServerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OrgServerId = options.longs === String ? "0" : 0;
                object.NewSeqClientId = 0;
                object.Quantity = 0;
                object.Price = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                object.LimitPrice = 0;
                object.Source = options.enums === String ? "Unknown" : 0;
            }
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.OrgServerId != null && message.hasOwnProperty("OrgServerId"))
                if (typeof message.OrgServerId === "number")
                    object.OrgServerId = options.longs === String ? String(message.OrgServerId) : message.OrgServerId;
                else
                    object.OrgServerId = options.longs === String ? $util.Long.prototype.toString.call(message.OrgServerId) : options.longs === Number ? new $util.LongBits(message.OrgServerId.low >>> 0, message.OrgServerId.high >>> 0).toNumber() : message.OrgServerId;
            if (message.NewSeqClientId != null && message.hasOwnProperty("NewSeqClientId"))
                object.NewSeqClientId = message.NewSeqClientId;
            if (message.Quantity != null && message.hasOwnProperty("Quantity"))
                object.Quantity = message.Quantity;
            if (message.Price != null && message.hasOwnProperty("Price"))
                object.Price = options.json && !isFinite(message.Price) ? String(message.Price) : message.Price;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.LimitPrice != null && message.hasOwnProperty("LimitPrice"))
                object.LimitPrice = options.json && !isFinite(message.LimitPrice) ? String(message.LimitPrice) : message.LimitPrice;
            if (message.Source != null && message.hasOwnProperty("Source"))
                object.Source = options.enums === String ? $root.PropTradingProtocol.RequestSourceEnum[message.Source] === undefined ? message.Source : $root.PropTradingProtocol.RequestSourceEnum[message.Source] : message.Source;
            return object;
        };

        /**
         * Converts this OrderModifyMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderModifyMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OrderModifyMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.OrderModifyMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OrderModifyMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.OrderModifyMsg";
        };

        return OrderModifyMsg;
    })();

    PropTradingProtocol.OrderRemoveMsg = (function() {

        /**
         * Properties of an OrderRemoveMsg.
         * @memberof PropTradingProtocol
         * @interface IOrderRemoveMsg
         * @property {number|Long|null} [OrgServerId] OrderRemoveMsg OrgServerId
         * @property {number|Long|null} [AccNumber] OrderRemoveMsg AccNumber
         * @property {PropTradingProtocol.RequestSourceEnum|null} [Source] OrderRemoveMsg Source
         */

        /**
         * Constructs a new OrderRemoveMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an OrderRemoveMsg.
         * @implements IOrderRemoveMsg
         * @constructor
         * @param {PropTradingProtocol.IOrderRemoveMsg=} [properties] Properties to set
         */
        function OrderRemoveMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderRemoveMsg OrgServerId.
         * @member {number|Long} OrgServerId
         * @memberof PropTradingProtocol.OrderRemoveMsg
         * @instance
         */
        OrderRemoveMsg.prototype.OrgServerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderRemoveMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.OrderRemoveMsg
         * @instance
         */
        OrderRemoveMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderRemoveMsg Source.
         * @member {PropTradingProtocol.RequestSourceEnum} Source
         * @memberof PropTradingProtocol.OrderRemoveMsg
         * @instance
         */
        OrderRemoveMsg.prototype.Source = 0;

        /**
         * Creates a new OrderRemoveMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.OrderRemoveMsg
         * @static
         * @param {PropTradingProtocol.IOrderRemoveMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.OrderRemoveMsg} OrderRemoveMsg instance
         */
        OrderRemoveMsg.create = function create(properties) {
            return new OrderRemoveMsg(properties);
        };

        /**
         * Encodes the specified OrderRemoveMsg message. Does not implicitly {@link PropTradingProtocol.OrderRemoveMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.OrderRemoveMsg
         * @static
         * @param {PropTradingProtocol.IOrderRemoveMsg} message OrderRemoveMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderRemoveMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.OrgServerId != null && Object.hasOwnProperty.call(message, "OrgServerId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.OrgServerId);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccNumber);
            if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Source);
            return writer;
        };

        /**
         * Encodes the specified OrderRemoveMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.OrderRemoveMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.OrderRemoveMsg
         * @static
         * @param {PropTradingProtocol.IOrderRemoveMsg} message OrderRemoveMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderRemoveMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OrderRemoveMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.OrderRemoveMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.OrderRemoveMsg} OrderRemoveMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderRemoveMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.OrderRemoveMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.OrgServerId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 3: {
                        message.Source = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OrderRemoveMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.OrderRemoveMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.OrderRemoveMsg} OrderRemoveMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderRemoveMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OrderRemoveMsg message.
         * @function verify
         * @memberof PropTradingProtocol.OrderRemoveMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderRemoveMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.OrgServerId != null && message.hasOwnProperty("OrgServerId"))
                if (!$util.isInteger(message.OrgServerId) && !(message.OrgServerId && $util.isInteger(message.OrgServerId.low) && $util.isInteger(message.OrgServerId.high)))
                    return "OrgServerId: integer|Long expected";
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.Source != null && message.hasOwnProperty("Source"))
                switch (message.Source) {
                default:
                    return "Source: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates an OrderRemoveMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.OrderRemoveMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.OrderRemoveMsg} OrderRemoveMsg
         */
        OrderRemoveMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.OrderRemoveMsg)
                return object;
            let message = new $root.PropTradingProtocol.OrderRemoveMsg();
            if (object.OrgServerId != null)
                if ($util.Long)
                    (message.OrgServerId = $util.Long.fromValue(object.OrgServerId)).unsigned = false;
                else if (typeof object.OrgServerId === "string")
                    message.OrgServerId = parseInt(object.OrgServerId, 10);
                else if (typeof object.OrgServerId === "number")
                    message.OrgServerId = object.OrgServerId;
                else if (typeof object.OrgServerId === "object")
                    message.OrgServerId = new $util.LongBits(object.OrgServerId.low >>> 0, object.OrgServerId.high >>> 0).toNumber();
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            switch (object.Source) {
            default:
                if (typeof object.Source === "number") {
                    message.Source = object.Source;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.Source = 0;
                break;
            case "Manual":
            case 1:
                message.Source = 1;
                break;
            case "Automatic":
            case 2:
                message.Source = 2;
                break;
            case "Copy":
            case 3:
                message.Source = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an OrderRemoveMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.OrderRemoveMsg
         * @static
         * @param {PropTradingProtocol.OrderRemoveMsg} message OrderRemoveMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderRemoveMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OrgServerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OrgServerId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                object.Source = options.enums === String ? "Unknown" : 0;
            }
            if (message.OrgServerId != null && message.hasOwnProperty("OrgServerId"))
                if (typeof message.OrgServerId === "number")
                    object.OrgServerId = options.longs === String ? String(message.OrgServerId) : message.OrgServerId;
                else
                    object.OrgServerId = options.longs === String ? $util.Long.prototype.toString.call(message.OrgServerId) : options.longs === Number ? new $util.LongBits(message.OrgServerId.low >>> 0, message.OrgServerId.high >>> 0).toNumber() : message.OrgServerId;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.Source != null && message.hasOwnProperty("Source"))
                object.Source = options.enums === String ? $root.PropTradingProtocol.RequestSourceEnum[message.Source] === undefined ? message.Source : $root.PropTradingProtocol.RequestSourceEnum[message.Source] : message.Source;
            return object;
        };

        /**
         * Converts this OrderRemoveMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.OrderRemoveMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderRemoveMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OrderRemoveMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.OrderRemoveMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OrderRemoveMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.OrderRemoveMsg";
        };

        return OrderRemoveMsg;
    })();

    PropTradingProtocol.BracketStrategyParam = (function() {

        /**
         * Properties of a BracketStrategyParam.
         * @memberof PropTradingProtocol
         * @interface IBracketStrategyParam
         * @property {PropTradingProtocol.BracketStrategyParam.TypeEnum|null} [Type] BracketStrategyParam Type
         * @property {Array.<PropTradingProtocol.IBracketParam>|null} [Stops] BracketStrategyParam Stops
         * @property {Array.<PropTradingProtocol.IBracketParam>|null} [Targets] BracketStrategyParam Targets
         * @property {PropTradingProtocol.BracketStrategyParam.StopTrailingModeEnum|null} [TrailingMode] BracketStrategyParam TrailingMode
         * @property {number|null} [TrailingTicks] BracketStrategyParam TrailingTicks
         * @property {number|null} [TrailingMinOffsetTicks] BracketStrategyParam TrailingMinOffsetTicks
         */

        /**
         * Constructs a new BracketStrategyParam.
         * @memberof PropTradingProtocol
         * @classdesc Represents a BracketStrategyParam.
         * @implements IBracketStrategyParam
         * @constructor
         * @param {PropTradingProtocol.IBracketStrategyParam=} [properties] Properties to set
         */
        function BracketStrategyParam(properties) {
            this.Stops = [];
            this.Targets = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BracketStrategyParam Type.
         * @member {PropTradingProtocol.BracketStrategyParam.TypeEnum} Type
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @instance
         */
        BracketStrategyParam.prototype.Type = 0;

        /**
         * BracketStrategyParam Stops.
         * @member {Array.<PropTradingProtocol.IBracketParam>} Stops
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @instance
         */
        BracketStrategyParam.prototype.Stops = $util.emptyArray;

        /**
         * BracketStrategyParam Targets.
         * @member {Array.<PropTradingProtocol.IBracketParam>} Targets
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @instance
         */
        BracketStrategyParam.prototype.Targets = $util.emptyArray;

        /**
         * BracketStrategyParam TrailingMode.
         * @member {PropTradingProtocol.BracketStrategyParam.StopTrailingModeEnum} TrailingMode
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @instance
         */
        BracketStrategyParam.prototype.TrailingMode = 0;

        /**
         * BracketStrategyParam TrailingTicks.
         * @member {number} TrailingTicks
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @instance
         */
        BracketStrategyParam.prototype.TrailingTicks = 0;

        /**
         * BracketStrategyParam TrailingMinOffsetTicks.
         * @member {number} TrailingMinOffsetTicks
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @instance
         */
        BracketStrategyParam.prototype.TrailingMinOffsetTicks = 0;

        /**
         * Creates a new BracketStrategyParam instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @static
         * @param {PropTradingProtocol.IBracketStrategyParam=} [properties] Properties to set
         * @returns {PropTradingProtocol.BracketStrategyParam} BracketStrategyParam instance
         */
        BracketStrategyParam.create = function create(properties) {
            return new BracketStrategyParam(properties);
        };

        /**
         * Encodes the specified BracketStrategyParam message. Does not implicitly {@link PropTradingProtocol.BracketStrategyParam.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @static
         * @param {PropTradingProtocol.IBracketStrategyParam} message BracketStrategyParam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketStrategyParam.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && Object.hasOwnProperty.call(message, "Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.Stops != null && message.Stops.length)
                for (let i = 0; i < message.Stops.length; ++i)
                    $root.PropTradingProtocol.BracketParam.encode(message.Stops[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.Targets != null && message.Targets.length)
                for (let i = 0; i < message.Targets.length; ++i)
                    $root.PropTradingProtocol.BracketParam.encode(message.Targets[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.TrailingMode != null && Object.hasOwnProperty.call(message, "TrailingMode"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.TrailingMode);
            if (message.TrailingTicks != null && Object.hasOwnProperty.call(message, "TrailingTicks"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.TrailingTicks);
            if (message.TrailingMinOffsetTicks != null && Object.hasOwnProperty.call(message, "TrailingMinOffsetTicks"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.TrailingMinOffsetTicks);
            return writer;
        };

        /**
         * Encodes the specified BracketStrategyParam message, length delimited. Does not implicitly {@link PropTradingProtocol.BracketStrategyParam.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @static
         * @param {PropTradingProtocol.IBracketStrategyParam} message BracketStrategyParam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketStrategyParam.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BracketStrategyParam message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.BracketStrategyParam} BracketStrategyParam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketStrategyParam.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.BracketStrategyParam();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.Type = reader.int32();
                        break;
                    }
                case 2: {
                        if (!(message.Stops && message.Stops.length))
                            message.Stops = [];
                        message.Stops.push($root.PropTradingProtocol.BracketParam.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.Targets && message.Targets.length))
                            message.Targets = [];
                        message.Targets.push($root.PropTradingProtocol.BracketParam.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.TrailingMode = reader.int32();
                        break;
                    }
                case 5: {
                        message.TrailingTicks = reader.int32();
                        break;
                    }
                case 6: {
                        message.TrailingMinOffsetTicks = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BracketStrategyParam message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.BracketStrategyParam} BracketStrategyParam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketStrategyParam.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BracketStrategyParam message.
         * @function verify
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BracketStrategyParam.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.Stops != null && message.hasOwnProperty("Stops")) {
                if (!Array.isArray(message.Stops))
                    return "Stops: array expected";
                for (let i = 0; i < message.Stops.length; ++i) {
                    let error = $root.PropTradingProtocol.BracketParam.verify(message.Stops[i]);
                    if (error)
                        return "Stops." + error;
                }
            }
            if (message.Targets != null && message.hasOwnProperty("Targets")) {
                if (!Array.isArray(message.Targets))
                    return "Targets: array expected";
                for (let i = 0; i < message.Targets.length; ++i) {
                    let error = $root.PropTradingProtocol.BracketParam.verify(message.Targets[i]);
                    if (error)
                        return "Targets." + error;
                }
            }
            if (message.TrailingMode != null && message.hasOwnProperty("TrailingMode"))
                switch (message.TrailingMode) {
                default:
                    return "TrailingMode: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.TrailingTicks != null && message.hasOwnProperty("TrailingTicks"))
                if (!$util.isInteger(message.TrailingTicks))
                    return "TrailingTicks: integer expected";
            if (message.TrailingMinOffsetTicks != null && message.hasOwnProperty("TrailingMinOffsetTicks"))
                if (!$util.isInteger(message.TrailingMinOffsetTicks))
                    return "TrailingMinOffsetTicks: integer expected";
            return null;
        };

        /**
         * Creates a BracketStrategyParam message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.BracketStrategyParam} BracketStrategyParam
         */
        BracketStrategyParam.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.BracketStrategyParam)
                return object;
            let message = new $root.PropTradingProtocol.BracketStrategyParam();
            switch (object.Type) {
            default:
                if (typeof object.Type === "number") {
                    message.Type = object.Type;
                    break;
                }
                break;
            case "STOP_AND_TARGET":
            case 0:
                message.Type = 0;
                break;
            case "STOP_AND_TARGET_STATIC":
            case 1:
                message.Type = 1;
                break;
            case "STOP":
            case 2:
                message.Type = 2;
                break;
            case "STOP_STATIC":
            case 3:
                message.Type = 3;
                break;
            case "TARGET":
            case 4:
                message.Type = 4;
                break;
            case "TARGET_STATIC":
            case 5:
                message.Type = 5;
                break;
            }
            if (object.Stops) {
                if (!Array.isArray(object.Stops))
                    throw TypeError(".PropTradingProtocol.BracketStrategyParam.Stops: array expected");
                message.Stops = [];
                for (let i = 0; i < object.Stops.length; ++i) {
                    if (typeof object.Stops[i] !== "object")
                        throw TypeError(".PropTradingProtocol.BracketStrategyParam.Stops: object expected");
                    message.Stops[i] = $root.PropTradingProtocol.BracketParam.fromObject(object.Stops[i]);
                }
            }
            if (object.Targets) {
                if (!Array.isArray(object.Targets))
                    throw TypeError(".PropTradingProtocol.BracketStrategyParam.Targets: array expected");
                message.Targets = [];
                for (let i = 0; i < object.Targets.length; ++i) {
                    if (typeof object.Targets[i] !== "object")
                        throw TypeError(".PropTradingProtocol.BracketStrategyParam.Targets: object expected");
                    message.Targets[i] = $root.PropTradingProtocol.BracketParam.fromObject(object.Targets[i]);
                }
            }
            switch (object.TrailingMode) {
            default:
                if (typeof object.TrailingMode === "number") {
                    message.TrailingMode = object.TrailingMode;
                    break;
                }
                break;
            case "None":
            case 0:
                message.TrailingMode = 0;
                break;
            case "Breakeven":
            case 1:
                message.TrailingMode = 1;
                break;
            case "Trailing":
            case 2:
                message.TrailingMode = 2;
                break;
            }
            if (object.TrailingTicks != null)
                message.TrailingTicks = object.TrailingTicks | 0;
            if (object.TrailingMinOffsetTicks != null)
                message.TrailingMinOffsetTicks = object.TrailingMinOffsetTicks | 0;
            return message;
        };

        /**
         * Creates a plain object from a BracketStrategyParam message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @static
         * @param {PropTradingProtocol.BracketStrategyParam} message BracketStrategyParam
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BracketStrategyParam.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.Stops = [];
                object.Targets = [];
            }
            if (options.defaults) {
                object.Type = options.enums === String ? "STOP_AND_TARGET" : 0;
                object.TrailingMode = options.enums === String ? "None" : 0;
                object.TrailingTicks = 0;
                object.TrailingMinOffsetTicks = 0;
            }
            if (message.Type != null && message.hasOwnProperty("Type"))
                object.Type = options.enums === String ? $root.PropTradingProtocol.BracketStrategyParam.TypeEnum[message.Type] === undefined ? message.Type : $root.PropTradingProtocol.BracketStrategyParam.TypeEnum[message.Type] : message.Type;
            if (message.Stops && message.Stops.length) {
                object.Stops = [];
                for (let j = 0; j < message.Stops.length; ++j)
                    object.Stops[j] = $root.PropTradingProtocol.BracketParam.toObject(message.Stops[j], options);
            }
            if (message.Targets && message.Targets.length) {
                object.Targets = [];
                for (let j = 0; j < message.Targets.length; ++j)
                    object.Targets[j] = $root.PropTradingProtocol.BracketParam.toObject(message.Targets[j], options);
            }
            if (message.TrailingMode != null && message.hasOwnProperty("TrailingMode"))
                object.TrailingMode = options.enums === String ? $root.PropTradingProtocol.BracketStrategyParam.StopTrailingModeEnum[message.TrailingMode] === undefined ? message.TrailingMode : $root.PropTradingProtocol.BracketStrategyParam.StopTrailingModeEnum[message.TrailingMode] : message.TrailingMode;
            if (message.TrailingTicks != null && message.hasOwnProperty("TrailingTicks"))
                object.TrailingTicks = message.TrailingTicks;
            if (message.TrailingMinOffsetTicks != null && message.hasOwnProperty("TrailingMinOffsetTicks"))
                object.TrailingMinOffsetTicks = message.TrailingMinOffsetTicks;
            return object;
        };

        /**
         * Converts this BracketStrategyParam to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BracketStrategyParam.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BracketStrategyParam
         * @function getTypeUrl
         * @memberof PropTradingProtocol.BracketStrategyParam
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BracketStrategyParam.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.BracketStrategyParam";
        };

        /**
         * TypeEnum enum.
         * @name PropTradingProtocol.BracketStrategyParam.TypeEnum
         * @enum {number}
         * @property {number} STOP_AND_TARGET=0 STOP_AND_TARGET value
         * @property {number} STOP_AND_TARGET_STATIC=1 STOP_AND_TARGET_STATIC value
         * @property {number} STOP=2 STOP value
         * @property {number} STOP_STATIC=3 STOP_STATIC value
         * @property {number} TARGET=4 TARGET value
         * @property {number} TARGET_STATIC=5 TARGET_STATIC value
         */
        BracketStrategyParam.TypeEnum = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "STOP_AND_TARGET"] = 0;
            values[valuesById[1] = "STOP_AND_TARGET_STATIC"] = 1;
            values[valuesById[2] = "STOP"] = 2;
            values[valuesById[3] = "STOP_STATIC"] = 3;
            values[valuesById[4] = "TARGET"] = 4;
            values[valuesById[5] = "TARGET_STATIC"] = 5;
            return values;
        })();

        /**
         * StopTrailingModeEnum enum.
         * @name PropTradingProtocol.BracketStrategyParam.StopTrailingModeEnum
         * @enum {number}
         * @property {number} None=0 None value
         * @property {number} Breakeven=1 Breakeven value
         * @property {number} Trailing=2 Trailing value
         */
        BracketStrategyParam.StopTrailingModeEnum = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "None"] = 0;
            values[valuesById[1] = "Breakeven"] = 1;
            values[valuesById[2] = "Trailing"] = 2;
            return values;
        })();

        return BracketStrategyParam;
    })();

    PropTradingProtocol.BracketParam = (function() {

        /**
         * Properties of a BracketParam.
         * @memberof PropTradingProtocol
         * @interface IBracketParam
         * @property {number|null} [Quantity] BracketParam Quantity
         * @property {PropTradingProtocol.BracketParam.PriceModeEnum|null} [PriceMode] BracketParam PriceMode
         * @property {number|null} [TicksOffset] BracketParam TicksOffset
         * @property {number|null} [Price] BracketParam Price
         */

        /**
         * Constructs a new BracketParam.
         * @memberof PropTradingProtocol
         * @classdesc Represents a BracketParam.
         * @implements IBracketParam
         * @constructor
         * @param {PropTradingProtocol.IBracketParam=} [properties] Properties to set
         */
        function BracketParam(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BracketParam Quantity.
         * @member {number} Quantity
         * @memberof PropTradingProtocol.BracketParam
         * @instance
         */
        BracketParam.prototype.Quantity = 0;

        /**
         * BracketParam PriceMode.
         * @member {PropTradingProtocol.BracketParam.PriceModeEnum} PriceMode
         * @memberof PropTradingProtocol.BracketParam
         * @instance
         */
        BracketParam.prototype.PriceMode = 0;

        /**
         * BracketParam TicksOffset.
         * @member {number} TicksOffset
         * @memberof PropTradingProtocol.BracketParam
         * @instance
         */
        BracketParam.prototype.TicksOffset = 0;

        /**
         * BracketParam Price.
         * @member {number} Price
         * @memberof PropTradingProtocol.BracketParam
         * @instance
         */
        BracketParam.prototype.Price = 0;

        /**
         * Creates a new BracketParam instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.BracketParam
         * @static
         * @param {PropTradingProtocol.IBracketParam=} [properties] Properties to set
         * @returns {PropTradingProtocol.BracketParam} BracketParam instance
         */
        BracketParam.create = function create(properties) {
            return new BracketParam(properties);
        };

        /**
         * Encodes the specified BracketParam message. Does not implicitly {@link PropTradingProtocol.BracketParam.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.BracketParam
         * @static
         * @param {PropTradingProtocol.IBracketParam} message BracketParam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketParam.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Quantity != null && Object.hasOwnProperty.call(message, "Quantity"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Quantity);
            if (message.PriceMode != null && Object.hasOwnProperty.call(message, "PriceMode"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.PriceMode);
            if (message.TicksOffset != null && Object.hasOwnProperty.call(message, "TicksOffset"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.TicksOffset);
            if (message.Price != null && Object.hasOwnProperty.call(message, "Price"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.Price);
            return writer;
        };

        /**
         * Encodes the specified BracketParam message, length delimited. Does not implicitly {@link PropTradingProtocol.BracketParam.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.BracketParam
         * @static
         * @param {PropTradingProtocol.IBracketParam} message BracketParam message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketParam.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BracketParam message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.BracketParam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.BracketParam} BracketParam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketParam.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.BracketParam();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.Quantity = reader.int32();
                        break;
                    }
                case 2: {
                        message.PriceMode = reader.int32();
                        break;
                    }
                case 3: {
                        message.TicksOffset = reader.int32();
                        break;
                    }
                case 4: {
                        message.Price = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BracketParam message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.BracketParam
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.BracketParam} BracketParam
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketParam.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BracketParam message.
         * @function verify
         * @memberof PropTradingProtocol.BracketParam
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BracketParam.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Quantity != null && message.hasOwnProperty("Quantity"))
                if (!$util.isInteger(message.Quantity))
                    return "Quantity: integer expected";
            if (message.PriceMode != null && message.hasOwnProperty("PriceMode"))
                switch (message.PriceMode) {
                default:
                    return "PriceMode: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.TicksOffset != null && message.hasOwnProperty("TicksOffset"))
                if (!$util.isInteger(message.TicksOffset))
                    return "TicksOffset: integer expected";
            if (message.Price != null && message.hasOwnProperty("Price"))
                if (typeof message.Price !== "number")
                    return "Price: number expected";
            return null;
        };

        /**
         * Creates a BracketParam message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.BracketParam
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.BracketParam} BracketParam
         */
        BracketParam.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.BracketParam)
                return object;
            let message = new $root.PropTradingProtocol.BracketParam();
            if (object.Quantity != null)
                message.Quantity = object.Quantity | 0;
            switch (object.PriceMode) {
            default:
                if (typeof object.PriceMode === "number") {
                    message.PriceMode = object.PriceMode;
                    break;
                }
                break;
            case "Ticks":
            case 0:
                message.PriceMode = 0;
                break;
            case "Price":
            case 1:
                message.PriceMode = 1;
                break;
            case "PriceOffset":
            case 2:
                message.PriceMode = 2;
                break;
            }
            if (object.TicksOffset != null)
                message.TicksOffset = object.TicksOffset | 0;
            if (object.Price != null)
                message.Price = Number(object.Price);
            return message;
        };

        /**
         * Creates a plain object from a BracketParam message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.BracketParam
         * @static
         * @param {PropTradingProtocol.BracketParam} message BracketParam
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BracketParam.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.Quantity = 0;
                object.PriceMode = options.enums === String ? "Ticks" : 0;
                object.TicksOffset = 0;
                object.Price = 0;
            }
            if (message.Quantity != null && message.hasOwnProperty("Quantity"))
                object.Quantity = message.Quantity;
            if (message.PriceMode != null && message.hasOwnProperty("PriceMode"))
                object.PriceMode = options.enums === String ? $root.PropTradingProtocol.BracketParam.PriceModeEnum[message.PriceMode] === undefined ? message.PriceMode : $root.PropTradingProtocol.BracketParam.PriceModeEnum[message.PriceMode] : message.PriceMode;
            if (message.TicksOffset != null && message.hasOwnProperty("TicksOffset"))
                object.TicksOffset = message.TicksOffset;
            if (message.Price != null && message.hasOwnProperty("Price"))
                object.Price = options.json && !isFinite(message.Price) ? String(message.Price) : message.Price;
            return object;
        };

        /**
         * Converts this BracketParam to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.BracketParam
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BracketParam.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BracketParam
         * @function getTypeUrl
         * @memberof PropTradingProtocol.BracketParam
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BracketParam.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.BracketParam";
        };

        /**
         * PriceModeEnum enum.
         * @name PropTradingProtocol.BracketParam.PriceModeEnum
         * @enum {number}
         * @property {number} Ticks=0 Ticks value
         * @property {number} Price=1 Price value
         * @property {number} PriceOffset=2 PriceOffset value
         */
        BracketParam.PriceModeEnum = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Ticks"] = 0;
            values[valuesById[1] = "Price"] = 1;
            values[valuesById[2] = "PriceOffset"] = 2;
            return values;
        })();

        return BracketParam;
    })();

    PropTradingProtocol.BracketStrageyInsertMsg = (function() {

        /**
         * Properties of a BracketStrageyInsertMsg.
         * @memberof PropTradingProtocol
         * @interface IBracketStrageyInsertMsg
         * @property {number|Long|null} [RequestId] BracketStrageyInsertMsg RequestId
         * @property {number|Long|null} [ParentOrderId] BracketStrageyInsertMsg ParentOrderId
         * @property {PropTradingProtocol.IBracketStrategyParam|null} [BracketStrategy] BracketStrageyInsertMsg BracketStrategy
         * @property {number|Long|null} [AccNumber] BracketStrageyInsertMsg AccNumber
         * @property {PropTradingProtocol.RequestSourceEnum|null} [Source] BracketStrageyInsertMsg Source
         * @property {boolean|null} [IsReplace] BracketStrageyInsertMsg IsReplace
         */

        /**
         * Constructs a new BracketStrageyInsertMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a BracketStrageyInsertMsg.
         * @implements IBracketStrageyInsertMsg
         * @constructor
         * @param {PropTradingProtocol.IBracketStrageyInsertMsg=} [properties] Properties to set
         */
        function BracketStrageyInsertMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BracketStrageyInsertMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @instance
         */
        BracketStrageyInsertMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketStrageyInsertMsg ParentOrderId.
         * @member {number|Long} ParentOrderId
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @instance
         */
        BracketStrageyInsertMsg.prototype.ParentOrderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketStrageyInsertMsg BracketStrategy.
         * @member {PropTradingProtocol.IBracketStrategyParam|null|undefined} BracketStrategy
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @instance
         */
        BracketStrageyInsertMsg.prototype.BracketStrategy = null;

        /**
         * BracketStrageyInsertMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @instance
         */
        BracketStrageyInsertMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketStrageyInsertMsg Source.
         * @member {PropTradingProtocol.RequestSourceEnum} Source
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @instance
         */
        BracketStrageyInsertMsg.prototype.Source = 0;

        /**
         * BracketStrageyInsertMsg IsReplace.
         * @member {boolean} IsReplace
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @instance
         */
        BracketStrageyInsertMsg.prototype.IsReplace = false;

        /**
         * Creates a new BracketStrageyInsertMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @static
         * @param {PropTradingProtocol.IBracketStrageyInsertMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.BracketStrageyInsertMsg} BracketStrageyInsertMsg instance
         */
        BracketStrageyInsertMsg.create = function create(properties) {
            return new BracketStrageyInsertMsg(properties);
        };

        /**
         * Encodes the specified BracketStrageyInsertMsg message. Does not implicitly {@link PropTradingProtocol.BracketStrageyInsertMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @static
         * @param {PropTradingProtocol.IBracketStrageyInsertMsg} message BracketStrageyInsertMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketStrageyInsertMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.ParentOrderId != null && Object.hasOwnProperty.call(message, "ParentOrderId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.ParentOrderId);
            if (message.BracketStrategy != null && Object.hasOwnProperty.call(message, "BracketStrategy"))
                $root.PropTradingProtocol.BracketStrategyParam.encode(message.BracketStrategy, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 4, wireType 0 =*/32).sint64(message.AccNumber);
            if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Source);
            if (message.IsReplace != null && Object.hasOwnProperty.call(message, "IsReplace"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.IsReplace);
            return writer;
        };

        /**
         * Encodes the specified BracketStrageyInsertMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.BracketStrageyInsertMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @static
         * @param {PropTradingProtocol.IBracketStrageyInsertMsg} message BracketStrageyInsertMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketStrageyInsertMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BracketStrageyInsertMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.BracketStrageyInsertMsg} BracketStrageyInsertMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketStrageyInsertMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.BracketStrageyInsertMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.ParentOrderId = reader.sint64();
                        break;
                    }
                case 3: {
                        message.BracketStrategy = $root.PropTradingProtocol.BracketStrategyParam.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 5: {
                        message.Source = reader.int32();
                        break;
                    }
                case 6: {
                        message.IsReplace = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BracketStrageyInsertMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.BracketStrageyInsertMsg} BracketStrageyInsertMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketStrageyInsertMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BracketStrageyInsertMsg message.
         * @function verify
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BracketStrageyInsertMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.ParentOrderId != null && message.hasOwnProperty("ParentOrderId"))
                if (!$util.isInteger(message.ParentOrderId) && !(message.ParentOrderId && $util.isInteger(message.ParentOrderId.low) && $util.isInteger(message.ParentOrderId.high)))
                    return "ParentOrderId: integer|Long expected";
            if (message.BracketStrategy != null && message.hasOwnProperty("BracketStrategy")) {
                let error = $root.PropTradingProtocol.BracketStrategyParam.verify(message.BracketStrategy);
                if (error)
                    return "BracketStrategy." + error;
            }
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.Source != null && message.hasOwnProperty("Source"))
                switch (message.Source) {
                default:
                    return "Source: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.IsReplace != null && message.hasOwnProperty("IsReplace"))
                if (typeof message.IsReplace !== "boolean")
                    return "IsReplace: boolean expected";
            return null;
        };

        /**
         * Creates a BracketStrageyInsertMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.BracketStrageyInsertMsg} BracketStrageyInsertMsg
         */
        BracketStrageyInsertMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.BracketStrageyInsertMsg)
                return object;
            let message = new $root.PropTradingProtocol.BracketStrageyInsertMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.ParentOrderId != null)
                if ($util.Long)
                    (message.ParentOrderId = $util.Long.fromValue(object.ParentOrderId)).unsigned = false;
                else if (typeof object.ParentOrderId === "string")
                    message.ParentOrderId = parseInt(object.ParentOrderId, 10);
                else if (typeof object.ParentOrderId === "number")
                    message.ParentOrderId = object.ParentOrderId;
                else if (typeof object.ParentOrderId === "object")
                    message.ParentOrderId = new $util.LongBits(object.ParentOrderId.low >>> 0, object.ParentOrderId.high >>> 0).toNumber();
            if (object.BracketStrategy != null) {
                if (typeof object.BracketStrategy !== "object")
                    throw TypeError(".PropTradingProtocol.BracketStrageyInsertMsg.BracketStrategy: object expected");
                message.BracketStrategy = $root.PropTradingProtocol.BracketStrategyParam.fromObject(object.BracketStrategy);
            }
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            switch (object.Source) {
            default:
                if (typeof object.Source === "number") {
                    message.Source = object.Source;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.Source = 0;
                break;
            case "Manual":
            case 1:
                message.Source = 1;
                break;
            case "Automatic":
            case 2:
                message.Source = 2;
                break;
            case "Copy":
            case 3:
                message.Source = 3;
                break;
            }
            if (object.IsReplace != null)
                message.IsReplace = Boolean(object.IsReplace);
            return message;
        };

        /**
         * Creates a plain object from a BracketStrageyInsertMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @static
         * @param {PropTradingProtocol.BracketStrageyInsertMsg} message BracketStrageyInsertMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BracketStrageyInsertMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ParentOrderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ParentOrderId = options.longs === String ? "0" : 0;
                object.BracketStrategy = null;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                object.Source = options.enums === String ? "Unknown" : 0;
                object.IsReplace = false;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.ParentOrderId != null && message.hasOwnProperty("ParentOrderId"))
                if (typeof message.ParentOrderId === "number")
                    object.ParentOrderId = options.longs === String ? String(message.ParentOrderId) : message.ParentOrderId;
                else
                    object.ParentOrderId = options.longs === String ? $util.Long.prototype.toString.call(message.ParentOrderId) : options.longs === Number ? new $util.LongBits(message.ParentOrderId.low >>> 0, message.ParentOrderId.high >>> 0).toNumber() : message.ParentOrderId;
            if (message.BracketStrategy != null && message.hasOwnProperty("BracketStrategy"))
                object.BracketStrategy = $root.PropTradingProtocol.BracketStrategyParam.toObject(message.BracketStrategy, options);
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.Source != null && message.hasOwnProperty("Source"))
                object.Source = options.enums === String ? $root.PropTradingProtocol.RequestSourceEnum[message.Source] === undefined ? message.Source : $root.PropTradingProtocol.RequestSourceEnum[message.Source] : message.Source;
            if (message.IsReplace != null && message.hasOwnProperty("IsReplace"))
                object.IsReplace = message.IsReplace;
            return object;
        };

        /**
         * Converts this BracketStrageyInsertMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BracketStrageyInsertMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BracketStrageyInsertMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.BracketStrageyInsertMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BracketStrageyInsertMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.BracketStrageyInsertMsg";
        };

        return BracketStrageyInsertMsg;
    })();

    PropTradingProtocol.BracketInsertMsg = (function() {

        /**
         * Properties of a BracketInsertMsg.
         * @memberof PropTradingProtocol
         * @interface IBracketInsertMsg
         * @property {number|Long|null} [RequestId] BracketInsertMsg RequestId
         * @property {number|Long|null} [ParentOrderId] BracketInsertMsg ParentOrderId
         * @property {boolean|null} [IsTarget] BracketInsertMsg IsTarget
         * @property {PropTradingProtocol.IBracketParam|null} [BracketParam] BracketInsertMsg BracketParam
         * @property {number|null} [ClientId] BracketInsertMsg ClientId
         * @property {number|Long|null} [AccNumber] BracketInsertMsg AccNumber
         * @property {PropTradingProtocol.RequestSourceEnum|null} [Source] BracketInsertMsg Source
         */

        /**
         * Constructs a new BracketInsertMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a BracketInsertMsg.
         * @implements IBracketInsertMsg
         * @constructor
         * @param {PropTradingProtocol.IBracketInsertMsg=} [properties] Properties to set
         */
        function BracketInsertMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BracketInsertMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @instance
         */
        BracketInsertMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketInsertMsg ParentOrderId.
         * @member {number|Long} ParentOrderId
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @instance
         */
        BracketInsertMsg.prototype.ParentOrderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketInsertMsg IsTarget.
         * @member {boolean} IsTarget
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @instance
         */
        BracketInsertMsg.prototype.IsTarget = false;

        /**
         * BracketInsertMsg BracketParam.
         * @member {PropTradingProtocol.IBracketParam|null|undefined} BracketParam
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @instance
         */
        BracketInsertMsg.prototype.BracketParam = null;

        /**
         * BracketInsertMsg ClientId.
         * @member {number} ClientId
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @instance
         */
        BracketInsertMsg.prototype.ClientId = 0;

        /**
         * BracketInsertMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @instance
         */
        BracketInsertMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketInsertMsg Source.
         * @member {PropTradingProtocol.RequestSourceEnum} Source
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @instance
         */
        BracketInsertMsg.prototype.Source = 0;

        /**
         * Creates a new BracketInsertMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @static
         * @param {PropTradingProtocol.IBracketInsertMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.BracketInsertMsg} BracketInsertMsg instance
         */
        BracketInsertMsg.create = function create(properties) {
            return new BracketInsertMsg(properties);
        };

        /**
         * Encodes the specified BracketInsertMsg message. Does not implicitly {@link PropTradingProtocol.BracketInsertMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @static
         * @param {PropTradingProtocol.IBracketInsertMsg} message BracketInsertMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketInsertMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.ParentOrderId != null && Object.hasOwnProperty.call(message, "ParentOrderId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.ParentOrderId);
            if (message.IsTarget != null && Object.hasOwnProperty.call(message, "IsTarget"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.IsTarget);
            if (message.BracketParam != null && Object.hasOwnProperty.call(message, "BracketParam"))
                $root.PropTradingProtocol.BracketParam.encode(message.BracketParam, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.ClientId != null && Object.hasOwnProperty.call(message, "ClientId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.ClientId);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 6, wireType 0 =*/48).sint64(message.AccNumber);
            if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Source);
            return writer;
        };

        /**
         * Encodes the specified BracketInsertMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.BracketInsertMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @static
         * @param {PropTradingProtocol.IBracketInsertMsg} message BracketInsertMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketInsertMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BracketInsertMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.BracketInsertMsg} BracketInsertMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketInsertMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.BracketInsertMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.ParentOrderId = reader.sint64();
                        break;
                    }
                case 3: {
                        message.IsTarget = reader.bool();
                        break;
                    }
                case 4: {
                        message.BracketParam = $root.PropTradingProtocol.BracketParam.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.ClientId = reader.int32();
                        break;
                    }
                case 6: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 7: {
                        message.Source = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BracketInsertMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.BracketInsertMsg} BracketInsertMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketInsertMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BracketInsertMsg message.
         * @function verify
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BracketInsertMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.ParentOrderId != null && message.hasOwnProperty("ParentOrderId"))
                if (!$util.isInteger(message.ParentOrderId) && !(message.ParentOrderId && $util.isInteger(message.ParentOrderId.low) && $util.isInteger(message.ParentOrderId.high)))
                    return "ParentOrderId: integer|Long expected";
            if (message.IsTarget != null && message.hasOwnProperty("IsTarget"))
                if (typeof message.IsTarget !== "boolean")
                    return "IsTarget: boolean expected";
            if (message.BracketParam != null && message.hasOwnProperty("BracketParam")) {
                let error = $root.PropTradingProtocol.BracketParam.verify(message.BracketParam);
                if (error)
                    return "BracketParam." + error;
            }
            if (message.ClientId != null && message.hasOwnProperty("ClientId"))
                if (!$util.isInteger(message.ClientId))
                    return "ClientId: integer expected";
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.Source != null && message.hasOwnProperty("Source"))
                switch (message.Source) {
                default:
                    return "Source: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a BracketInsertMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.BracketInsertMsg} BracketInsertMsg
         */
        BracketInsertMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.BracketInsertMsg)
                return object;
            let message = new $root.PropTradingProtocol.BracketInsertMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.ParentOrderId != null)
                if ($util.Long)
                    (message.ParentOrderId = $util.Long.fromValue(object.ParentOrderId)).unsigned = false;
                else if (typeof object.ParentOrderId === "string")
                    message.ParentOrderId = parseInt(object.ParentOrderId, 10);
                else if (typeof object.ParentOrderId === "number")
                    message.ParentOrderId = object.ParentOrderId;
                else if (typeof object.ParentOrderId === "object")
                    message.ParentOrderId = new $util.LongBits(object.ParentOrderId.low >>> 0, object.ParentOrderId.high >>> 0).toNumber();
            if (object.IsTarget != null)
                message.IsTarget = Boolean(object.IsTarget);
            if (object.BracketParam != null) {
                if (typeof object.BracketParam !== "object")
                    throw TypeError(".PropTradingProtocol.BracketInsertMsg.BracketParam: object expected");
                message.BracketParam = $root.PropTradingProtocol.BracketParam.fromObject(object.BracketParam);
            }
            if (object.ClientId != null)
                message.ClientId = object.ClientId | 0;
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            switch (object.Source) {
            default:
                if (typeof object.Source === "number") {
                    message.Source = object.Source;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.Source = 0;
                break;
            case "Manual":
            case 1:
                message.Source = 1;
                break;
            case "Automatic":
            case 2:
                message.Source = 2;
                break;
            case "Copy":
            case 3:
                message.Source = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a BracketInsertMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @static
         * @param {PropTradingProtocol.BracketInsertMsg} message BracketInsertMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BracketInsertMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ParentOrderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ParentOrderId = options.longs === String ? "0" : 0;
                object.IsTarget = false;
                object.BracketParam = null;
                object.ClientId = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                object.Source = options.enums === String ? "Unknown" : 0;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.ParentOrderId != null && message.hasOwnProperty("ParentOrderId"))
                if (typeof message.ParentOrderId === "number")
                    object.ParentOrderId = options.longs === String ? String(message.ParentOrderId) : message.ParentOrderId;
                else
                    object.ParentOrderId = options.longs === String ? $util.Long.prototype.toString.call(message.ParentOrderId) : options.longs === Number ? new $util.LongBits(message.ParentOrderId.low >>> 0, message.ParentOrderId.high >>> 0).toNumber() : message.ParentOrderId;
            if (message.IsTarget != null && message.hasOwnProperty("IsTarget"))
                object.IsTarget = message.IsTarget;
            if (message.BracketParam != null && message.hasOwnProperty("BracketParam"))
                object.BracketParam = $root.PropTradingProtocol.BracketParam.toObject(message.BracketParam, options);
            if (message.ClientId != null && message.hasOwnProperty("ClientId"))
                object.ClientId = message.ClientId;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.Source != null && message.hasOwnProperty("Source"))
                object.Source = options.enums === String ? $root.PropTradingProtocol.RequestSourceEnum[message.Source] === undefined ? message.Source : $root.PropTradingProtocol.RequestSourceEnum[message.Source] : message.Source;
            return object;
        };

        /**
         * Converts this BracketInsertMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BracketInsertMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BracketInsertMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.BracketInsertMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BracketInsertMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.BracketInsertMsg";
        };

        return BracketInsertMsg;
    })();

    PropTradingProtocol.BracketModifyMsg = (function() {

        /**
         * Properties of a BracketModifyMsg.
         * @memberof PropTradingProtocol
         * @interface IBracketModifyMsg
         * @property {number|Long|null} [ParentOrderId] BracketModifyMsg ParentOrderId
         * @property {number|Long|null} [BracketId] BracketModifyMsg BracketId
         * @property {PropTradingProtocol.IBracketParam|null} [BracketParam] BracketModifyMsg BracketParam
         * @property {number|null} [ClientId] BracketModifyMsg ClientId
         * @property {number|Long|null} [AccNumber] BracketModifyMsg AccNumber
         * @property {PropTradingProtocol.RequestSourceEnum|null} [Source] BracketModifyMsg Source
         */

        /**
         * Constructs a new BracketModifyMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a BracketModifyMsg.
         * @implements IBracketModifyMsg
         * @constructor
         * @param {PropTradingProtocol.IBracketModifyMsg=} [properties] Properties to set
         */
        function BracketModifyMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BracketModifyMsg ParentOrderId.
         * @member {number|Long} ParentOrderId
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @instance
         */
        BracketModifyMsg.prototype.ParentOrderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketModifyMsg BracketId.
         * @member {number|Long} BracketId
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @instance
         */
        BracketModifyMsg.prototype.BracketId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketModifyMsg BracketParam.
         * @member {PropTradingProtocol.IBracketParam|null|undefined} BracketParam
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @instance
         */
        BracketModifyMsg.prototype.BracketParam = null;

        /**
         * BracketModifyMsg ClientId.
         * @member {number} ClientId
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @instance
         */
        BracketModifyMsg.prototype.ClientId = 0;

        /**
         * BracketModifyMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @instance
         */
        BracketModifyMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketModifyMsg Source.
         * @member {PropTradingProtocol.RequestSourceEnum} Source
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @instance
         */
        BracketModifyMsg.prototype.Source = 0;

        /**
         * Creates a new BracketModifyMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @static
         * @param {PropTradingProtocol.IBracketModifyMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.BracketModifyMsg} BracketModifyMsg instance
         */
        BracketModifyMsg.create = function create(properties) {
            return new BracketModifyMsg(properties);
        };

        /**
         * Encodes the specified BracketModifyMsg message. Does not implicitly {@link PropTradingProtocol.BracketModifyMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @static
         * @param {PropTradingProtocol.IBracketModifyMsg} message BracketModifyMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketModifyMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ParentOrderId != null && Object.hasOwnProperty.call(message, "ParentOrderId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.ParentOrderId);
            if (message.BracketId != null && Object.hasOwnProperty.call(message, "BracketId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.BracketId);
            if (message.BracketParam != null && Object.hasOwnProperty.call(message, "BracketParam"))
                $root.PropTradingProtocol.BracketParam.encode(message.BracketParam, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.ClientId != null && Object.hasOwnProperty.call(message, "ClientId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ClientId);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 5, wireType 0 =*/40).sint64(message.AccNumber);
            if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Source);
            return writer;
        };

        /**
         * Encodes the specified BracketModifyMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.BracketModifyMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @static
         * @param {PropTradingProtocol.IBracketModifyMsg} message BracketModifyMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketModifyMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BracketModifyMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.BracketModifyMsg} BracketModifyMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketModifyMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.BracketModifyMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.ParentOrderId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.BracketId = reader.sint64();
                        break;
                    }
                case 3: {
                        message.BracketParam = $root.PropTradingProtocol.BracketParam.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.ClientId = reader.int32();
                        break;
                    }
                case 5: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 6: {
                        message.Source = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BracketModifyMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.BracketModifyMsg} BracketModifyMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketModifyMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BracketModifyMsg message.
         * @function verify
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BracketModifyMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ParentOrderId != null && message.hasOwnProperty("ParentOrderId"))
                if (!$util.isInteger(message.ParentOrderId) && !(message.ParentOrderId && $util.isInteger(message.ParentOrderId.low) && $util.isInteger(message.ParentOrderId.high)))
                    return "ParentOrderId: integer|Long expected";
            if (message.BracketId != null && message.hasOwnProperty("BracketId"))
                if (!$util.isInteger(message.BracketId) && !(message.BracketId && $util.isInteger(message.BracketId.low) && $util.isInteger(message.BracketId.high)))
                    return "BracketId: integer|Long expected";
            if (message.BracketParam != null && message.hasOwnProperty("BracketParam")) {
                let error = $root.PropTradingProtocol.BracketParam.verify(message.BracketParam);
                if (error)
                    return "BracketParam." + error;
            }
            if (message.ClientId != null && message.hasOwnProperty("ClientId"))
                if (!$util.isInteger(message.ClientId))
                    return "ClientId: integer expected";
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.Source != null && message.hasOwnProperty("Source"))
                switch (message.Source) {
                default:
                    return "Source: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a BracketModifyMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.BracketModifyMsg} BracketModifyMsg
         */
        BracketModifyMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.BracketModifyMsg)
                return object;
            let message = new $root.PropTradingProtocol.BracketModifyMsg();
            if (object.ParentOrderId != null)
                if ($util.Long)
                    (message.ParentOrderId = $util.Long.fromValue(object.ParentOrderId)).unsigned = false;
                else if (typeof object.ParentOrderId === "string")
                    message.ParentOrderId = parseInt(object.ParentOrderId, 10);
                else if (typeof object.ParentOrderId === "number")
                    message.ParentOrderId = object.ParentOrderId;
                else if (typeof object.ParentOrderId === "object")
                    message.ParentOrderId = new $util.LongBits(object.ParentOrderId.low >>> 0, object.ParentOrderId.high >>> 0).toNumber();
            if (object.BracketId != null)
                if ($util.Long)
                    (message.BracketId = $util.Long.fromValue(object.BracketId)).unsigned = false;
                else if (typeof object.BracketId === "string")
                    message.BracketId = parseInt(object.BracketId, 10);
                else if (typeof object.BracketId === "number")
                    message.BracketId = object.BracketId;
                else if (typeof object.BracketId === "object")
                    message.BracketId = new $util.LongBits(object.BracketId.low >>> 0, object.BracketId.high >>> 0).toNumber();
            if (object.BracketParam != null) {
                if (typeof object.BracketParam !== "object")
                    throw TypeError(".PropTradingProtocol.BracketModifyMsg.BracketParam: object expected");
                message.BracketParam = $root.PropTradingProtocol.BracketParam.fromObject(object.BracketParam);
            }
            if (object.ClientId != null)
                message.ClientId = object.ClientId | 0;
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            switch (object.Source) {
            default:
                if (typeof object.Source === "number") {
                    message.Source = object.Source;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.Source = 0;
                break;
            case "Manual":
            case 1:
                message.Source = 1;
                break;
            case "Automatic":
            case 2:
                message.Source = 2;
                break;
            case "Copy":
            case 3:
                message.Source = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a BracketModifyMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @static
         * @param {PropTradingProtocol.BracketModifyMsg} message BracketModifyMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BracketModifyMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ParentOrderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ParentOrderId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.BracketId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.BracketId = options.longs === String ? "0" : 0;
                object.BracketParam = null;
                object.ClientId = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                object.Source = options.enums === String ? "Unknown" : 0;
            }
            if (message.ParentOrderId != null && message.hasOwnProperty("ParentOrderId"))
                if (typeof message.ParentOrderId === "number")
                    object.ParentOrderId = options.longs === String ? String(message.ParentOrderId) : message.ParentOrderId;
                else
                    object.ParentOrderId = options.longs === String ? $util.Long.prototype.toString.call(message.ParentOrderId) : options.longs === Number ? new $util.LongBits(message.ParentOrderId.low >>> 0, message.ParentOrderId.high >>> 0).toNumber() : message.ParentOrderId;
            if (message.BracketId != null && message.hasOwnProperty("BracketId"))
                if (typeof message.BracketId === "number")
                    object.BracketId = options.longs === String ? String(message.BracketId) : message.BracketId;
                else
                    object.BracketId = options.longs === String ? $util.Long.prototype.toString.call(message.BracketId) : options.longs === Number ? new $util.LongBits(message.BracketId.low >>> 0, message.BracketId.high >>> 0).toNumber() : message.BracketId;
            if (message.BracketParam != null && message.hasOwnProperty("BracketParam"))
                object.BracketParam = $root.PropTradingProtocol.BracketParam.toObject(message.BracketParam, options);
            if (message.ClientId != null && message.hasOwnProperty("ClientId"))
                object.ClientId = message.ClientId;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.Source != null && message.hasOwnProperty("Source"))
                object.Source = options.enums === String ? $root.PropTradingProtocol.RequestSourceEnum[message.Source] === undefined ? message.Source : $root.PropTradingProtocol.RequestSourceEnum[message.Source] : message.Source;
            return object;
        };

        /**
         * Converts this BracketModifyMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BracketModifyMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BracketModifyMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.BracketModifyMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BracketModifyMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.BracketModifyMsg";
        };

        return BracketModifyMsg;
    })();

    PropTradingProtocol.BracketRemoveMsg = (function() {

        /**
         * Properties of a BracketRemoveMsg.
         * @memberof PropTradingProtocol
         * @interface IBracketRemoveMsg
         * @property {number|Long|null} [ParentOrderId] BracketRemoveMsg ParentOrderId
         * @property {number|Long|null} [BracketId] BracketRemoveMsg BracketId
         * @property {number|Long|null} [AccNumber] BracketRemoveMsg AccNumber
         * @property {PropTradingProtocol.RequestSourceEnum|null} [Source] BracketRemoveMsg Source
         */

        /**
         * Constructs a new BracketRemoveMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a BracketRemoveMsg.
         * @implements IBracketRemoveMsg
         * @constructor
         * @param {PropTradingProtocol.IBracketRemoveMsg=} [properties] Properties to set
         */
        function BracketRemoveMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BracketRemoveMsg ParentOrderId.
         * @member {number|Long} ParentOrderId
         * @memberof PropTradingProtocol.BracketRemoveMsg
         * @instance
         */
        BracketRemoveMsg.prototype.ParentOrderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketRemoveMsg BracketId.
         * @member {number|Long} BracketId
         * @memberof PropTradingProtocol.BracketRemoveMsg
         * @instance
         */
        BracketRemoveMsg.prototype.BracketId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketRemoveMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.BracketRemoveMsg
         * @instance
         */
        BracketRemoveMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketRemoveMsg Source.
         * @member {PropTradingProtocol.RequestSourceEnum} Source
         * @memberof PropTradingProtocol.BracketRemoveMsg
         * @instance
         */
        BracketRemoveMsg.prototype.Source = 0;

        /**
         * Creates a new BracketRemoveMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.BracketRemoveMsg
         * @static
         * @param {PropTradingProtocol.IBracketRemoveMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.BracketRemoveMsg} BracketRemoveMsg instance
         */
        BracketRemoveMsg.create = function create(properties) {
            return new BracketRemoveMsg(properties);
        };

        /**
         * Encodes the specified BracketRemoveMsg message. Does not implicitly {@link PropTradingProtocol.BracketRemoveMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.BracketRemoveMsg
         * @static
         * @param {PropTradingProtocol.IBracketRemoveMsg} message BracketRemoveMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketRemoveMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ParentOrderId != null && Object.hasOwnProperty.call(message, "ParentOrderId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.ParentOrderId);
            if (message.BracketId != null && Object.hasOwnProperty.call(message, "BracketId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.BracketId);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint64(message.AccNumber);
            if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Source);
            return writer;
        };

        /**
         * Encodes the specified BracketRemoveMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.BracketRemoveMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.BracketRemoveMsg
         * @static
         * @param {PropTradingProtocol.IBracketRemoveMsg} message BracketRemoveMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketRemoveMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BracketRemoveMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.BracketRemoveMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.BracketRemoveMsg} BracketRemoveMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketRemoveMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.BracketRemoveMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.ParentOrderId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.BracketId = reader.sint64();
                        break;
                    }
                case 3: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 4: {
                        message.Source = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BracketRemoveMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.BracketRemoveMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.BracketRemoveMsg} BracketRemoveMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketRemoveMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BracketRemoveMsg message.
         * @function verify
         * @memberof PropTradingProtocol.BracketRemoveMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BracketRemoveMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ParentOrderId != null && message.hasOwnProperty("ParentOrderId"))
                if (!$util.isInteger(message.ParentOrderId) && !(message.ParentOrderId && $util.isInteger(message.ParentOrderId.low) && $util.isInteger(message.ParentOrderId.high)))
                    return "ParentOrderId: integer|Long expected";
            if (message.BracketId != null && message.hasOwnProperty("BracketId"))
                if (!$util.isInteger(message.BracketId) && !(message.BracketId && $util.isInteger(message.BracketId.low) && $util.isInteger(message.BracketId.high)))
                    return "BracketId: integer|Long expected";
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.Source != null && message.hasOwnProperty("Source"))
                switch (message.Source) {
                default:
                    return "Source: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a BracketRemoveMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.BracketRemoveMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.BracketRemoveMsg} BracketRemoveMsg
         */
        BracketRemoveMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.BracketRemoveMsg)
                return object;
            let message = new $root.PropTradingProtocol.BracketRemoveMsg();
            if (object.ParentOrderId != null)
                if ($util.Long)
                    (message.ParentOrderId = $util.Long.fromValue(object.ParentOrderId)).unsigned = false;
                else if (typeof object.ParentOrderId === "string")
                    message.ParentOrderId = parseInt(object.ParentOrderId, 10);
                else if (typeof object.ParentOrderId === "number")
                    message.ParentOrderId = object.ParentOrderId;
                else if (typeof object.ParentOrderId === "object")
                    message.ParentOrderId = new $util.LongBits(object.ParentOrderId.low >>> 0, object.ParentOrderId.high >>> 0).toNumber();
            if (object.BracketId != null)
                if ($util.Long)
                    (message.BracketId = $util.Long.fromValue(object.BracketId)).unsigned = false;
                else if (typeof object.BracketId === "string")
                    message.BracketId = parseInt(object.BracketId, 10);
                else if (typeof object.BracketId === "number")
                    message.BracketId = object.BracketId;
                else if (typeof object.BracketId === "object")
                    message.BracketId = new $util.LongBits(object.BracketId.low >>> 0, object.BracketId.high >>> 0).toNumber();
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            switch (object.Source) {
            default:
                if (typeof object.Source === "number") {
                    message.Source = object.Source;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.Source = 0;
                break;
            case "Manual":
            case 1:
                message.Source = 1;
                break;
            case "Automatic":
            case 2:
                message.Source = 2;
                break;
            case "Copy":
            case 3:
                message.Source = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a BracketRemoveMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.BracketRemoveMsg
         * @static
         * @param {PropTradingProtocol.BracketRemoveMsg} message BracketRemoveMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BracketRemoveMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ParentOrderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ParentOrderId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.BracketId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.BracketId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                object.Source = options.enums === String ? "Unknown" : 0;
            }
            if (message.ParentOrderId != null && message.hasOwnProperty("ParentOrderId"))
                if (typeof message.ParentOrderId === "number")
                    object.ParentOrderId = options.longs === String ? String(message.ParentOrderId) : message.ParentOrderId;
                else
                    object.ParentOrderId = options.longs === String ? $util.Long.prototype.toString.call(message.ParentOrderId) : options.longs === Number ? new $util.LongBits(message.ParentOrderId.low >>> 0, message.ParentOrderId.high >>> 0).toNumber() : message.ParentOrderId;
            if (message.BracketId != null && message.hasOwnProperty("BracketId"))
                if (typeof message.BracketId === "number")
                    object.BracketId = options.longs === String ? String(message.BracketId) : message.BracketId;
                else
                    object.BracketId = options.longs === String ? $util.Long.prototype.toString.call(message.BracketId) : options.longs === Number ? new $util.LongBits(message.BracketId.low >>> 0, message.BracketId.high >>> 0).toNumber() : message.BracketId;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.Source != null && message.hasOwnProperty("Source"))
                object.Source = options.enums === String ? $root.PropTradingProtocol.RequestSourceEnum[message.Source] === undefined ? message.Source : $root.PropTradingProtocol.RequestSourceEnum[message.Source] : message.Source;
            return object;
        };

        /**
         * Converts this BracketRemoveMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.BracketRemoveMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BracketRemoveMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BracketRemoveMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.BracketRemoveMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BracketRemoveMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.BracketRemoveMsg";
        };

        return BracketRemoveMsg;
    })();

    PropTradingProtocol.OcoGroupCreateMsg = (function() {

        /**
         * Properties of an OcoGroupCreateMsg.
         * @memberof PropTradingProtocol
         * @interface IOcoGroupCreateMsg
         * @property {number|Long|null} [RequestId] OcoGroupCreateMsg RequestId
         * @property {number|Long|null} [AccNumber] OcoGroupCreateMsg AccNumber
         * @property {PropTradingProtocol.OcoGroupCreateMsg.GroupTypeEnum|null} [Type] OcoGroupCreateMsg Type
         * @property {Array.<number|Long>|null} [OcoLinkedOrderIds] OcoGroupCreateMsg OcoLinkedOrderIds
         * @property {PropTradingProtocol.OcoGroupCreateMsg.OcoOrdersPlaceEnum|null} [OrderPlace] OcoGroupCreateMsg OrderPlace
         * @property {Array.<PropTradingProtocol.IOrderInsertMsg>|null} [OrderInsert] OcoGroupCreateMsg OrderInsert
         * @property {PropTradingProtocol.RequestSourceEnum|null} [Source] OcoGroupCreateMsg Source
         */

        /**
         * Constructs a new OcoGroupCreateMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an OcoGroupCreateMsg.
         * @implements IOcoGroupCreateMsg
         * @constructor
         * @param {PropTradingProtocol.IOcoGroupCreateMsg=} [properties] Properties to set
         */
        function OcoGroupCreateMsg(properties) {
            this.OcoLinkedOrderIds = [];
            this.OrderInsert = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OcoGroupCreateMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @instance
         */
        OcoGroupCreateMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OcoGroupCreateMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @instance
         */
        OcoGroupCreateMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OcoGroupCreateMsg Type.
         * @member {PropTradingProtocol.OcoGroupCreateMsg.GroupTypeEnum} Type
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @instance
         */
        OcoGroupCreateMsg.prototype.Type = 0;

        /**
         * OcoGroupCreateMsg OcoLinkedOrderIds.
         * @member {Array.<number|Long>} OcoLinkedOrderIds
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @instance
         */
        OcoGroupCreateMsg.prototype.OcoLinkedOrderIds = $util.emptyArray;

        /**
         * OcoGroupCreateMsg OrderPlace.
         * @member {PropTradingProtocol.OcoGroupCreateMsg.OcoOrdersPlaceEnum} OrderPlace
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @instance
         */
        OcoGroupCreateMsg.prototype.OrderPlace = 0;

        /**
         * OcoGroupCreateMsg OrderInsert.
         * @member {Array.<PropTradingProtocol.IOrderInsertMsg>} OrderInsert
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @instance
         */
        OcoGroupCreateMsg.prototype.OrderInsert = $util.emptyArray;

        /**
         * OcoGroupCreateMsg Source.
         * @member {PropTradingProtocol.RequestSourceEnum} Source
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @instance
         */
        OcoGroupCreateMsg.prototype.Source = 0;

        /**
         * Creates a new OcoGroupCreateMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @static
         * @param {PropTradingProtocol.IOcoGroupCreateMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.OcoGroupCreateMsg} OcoGroupCreateMsg instance
         */
        OcoGroupCreateMsg.create = function create(properties) {
            return new OcoGroupCreateMsg(properties);
        };

        /**
         * Encodes the specified OcoGroupCreateMsg message. Does not implicitly {@link PropTradingProtocol.OcoGroupCreateMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @static
         * @param {PropTradingProtocol.IOcoGroupCreateMsg} message OcoGroupCreateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OcoGroupCreateMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccNumber);
            if (message.Type != null && Object.hasOwnProperty.call(message, "Type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Type);
            if (message.OcoLinkedOrderIds != null && message.OcoLinkedOrderIds.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.OcoLinkedOrderIds.length; ++i)
                    writer.sint64(message.OcoLinkedOrderIds[i]);
                writer.ldelim();
            }
            if (message.OrderPlace != null && Object.hasOwnProperty.call(message, "OrderPlace"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.OrderPlace);
            if (message.OrderInsert != null && message.OrderInsert.length)
                for (let i = 0; i < message.OrderInsert.length; ++i)
                    $root.PropTradingProtocol.OrderInsertMsg.encode(message.OrderInsert[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Source);
            return writer;
        };

        /**
         * Encodes the specified OcoGroupCreateMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.OcoGroupCreateMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @static
         * @param {PropTradingProtocol.IOcoGroupCreateMsg} message OcoGroupCreateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OcoGroupCreateMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OcoGroupCreateMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.OcoGroupCreateMsg} OcoGroupCreateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OcoGroupCreateMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.OcoGroupCreateMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 3: {
                        message.Type = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.OcoLinkedOrderIds && message.OcoLinkedOrderIds.length))
                            message.OcoLinkedOrderIds = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.OcoLinkedOrderIds.push(reader.sint64());
                        } else
                            message.OcoLinkedOrderIds.push(reader.sint64());
                        break;
                    }
                case 5: {
                        message.OrderPlace = reader.int32();
                        break;
                    }
                case 6: {
                        if (!(message.OrderInsert && message.OrderInsert.length))
                            message.OrderInsert = [];
                        message.OrderInsert.push($root.PropTradingProtocol.OrderInsertMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        message.Source = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OcoGroupCreateMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.OcoGroupCreateMsg} OcoGroupCreateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OcoGroupCreateMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OcoGroupCreateMsg message.
         * @function verify
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OcoGroupCreateMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.OcoLinkedOrderIds != null && message.hasOwnProperty("OcoLinkedOrderIds")) {
                if (!Array.isArray(message.OcoLinkedOrderIds))
                    return "OcoLinkedOrderIds: array expected";
                for (let i = 0; i < message.OcoLinkedOrderIds.length; ++i)
                    if (!$util.isInteger(message.OcoLinkedOrderIds[i]) && !(message.OcoLinkedOrderIds[i] && $util.isInteger(message.OcoLinkedOrderIds[i].low) && $util.isInteger(message.OcoLinkedOrderIds[i].high)))
                        return "OcoLinkedOrderIds: integer|Long[] expected";
            }
            if (message.OrderPlace != null && message.hasOwnProperty("OrderPlace"))
                switch (message.OrderPlace) {
                default:
                    return "OrderPlace: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.OrderInsert != null && message.hasOwnProperty("OrderInsert")) {
                if (!Array.isArray(message.OrderInsert))
                    return "OrderInsert: array expected";
                for (let i = 0; i < message.OrderInsert.length; ++i) {
                    let error = $root.PropTradingProtocol.OrderInsertMsg.verify(message.OrderInsert[i]);
                    if (error)
                        return "OrderInsert." + error;
                }
            }
            if (message.Source != null && message.hasOwnProperty("Source"))
                switch (message.Source) {
                default:
                    return "Source: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates an OcoGroupCreateMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.OcoGroupCreateMsg} OcoGroupCreateMsg
         */
        OcoGroupCreateMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.OcoGroupCreateMsg)
                return object;
            let message = new $root.PropTradingProtocol.OcoGroupCreateMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            switch (object.Type) {
            default:
                if (typeof object.Type === "number") {
                    message.Type = object.Type;
                    break;
                }
                break;
            case "STOPS_LIMITS":
            case 0:
                message.Type = 0;
                break;
            case "OPPOSITE_QTY":
            case 1:
                message.Type = 1;
                break;
            }
            if (object.OcoLinkedOrderIds) {
                if (!Array.isArray(object.OcoLinkedOrderIds))
                    throw TypeError(".PropTradingProtocol.OcoGroupCreateMsg.OcoLinkedOrderIds: array expected");
                message.OcoLinkedOrderIds = [];
                for (let i = 0; i < object.OcoLinkedOrderIds.length; ++i)
                    if ($util.Long)
                        (message.OcoLinkedOrderIds[i] = $util.Long.fromValue(object.OcoLinkedOrderIds[i])).unsigned = false;
                    else if (typeof object.OcoLinkedOrderIds[i] === "string")
                        message.OcoLinkedOrderIds[i] = parseInt(object.OcoLinkedOrderIds[i], 10);
                    else if (typeof object.OcoLinkedOrderIds[i] === "number")
                        message.OcoLinkedOrderIds[i] = object.OcoLinkedOrderIds[i];
                    else if (typeof object.OcoLinkedOrderIds[i] === "object")
                        message.OcoLinkedOrderIds[i] = new $util.LongBits(object.OcoLinkedOrderIds[i].low >>> 0, object.OcoLinkedOrderIds[i].high >>> 0).toNumber();
            }
            switch (object.OrderPlace) {
            default:
                if (typeof object.OrderPlace === "number") {
                    message.OrderPlace = object.OrderPlace;
                    break;
                }
                break;
            case "EXISTING":
            case 0:
                message.OrderPlace = 0;
                break;
            case "INSERT":
            case 1:
                message.OrderPlace = 1;
                break;
            }
            if (object.OrderInsert) {
                if (!Array.isArray(object.OrderInsert))
                    throw TypeError(".PropTradingProtocol.OcoGroupCreateMsg.OrderInsert: array expected");
                message.OrderInsert = [];
                for (let i = 0; i < object.OrderInsert.length; ++i) {
                    if (typeof object.OrderInsert[i] !== "object")
                        throw TypeError(".PropTradingProtocol.OcoGroupCreateMsg.OrderInsert: object expected");
                    message.OrderInsert[i] = $root.PropTradingProtocol.OrderInsertMsg.fromObject(object.OrderInsert[i]);
                }
            }
            switch (object.Source) {
            default:
                if (typeof object.Source === "number") {
                    message.Source = object.Source;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.Source = 0;
                break;
            case "Manual":
            case 1:
                message.Source = 1;
                break;
            case "Automatic":
            case 2:
                message.Source = 2;
                break;
            case "Copy":
            case 3:
                message.Source = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an OcoGroupCreateMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @static
         * @param {PropTradingProtocol.OcoGroupCreateMsg} message OcoGroupCreateMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OcoGroupCreateMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.OcoLinkedOrderIds = [];
                object.OrderInsert = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                object.Type = options.enums === String ? "STOPS_LIMITS" : 0;
                object.OrderPlace = options.enums === String ? "EXISTING" : 0;
                object.Source = options.enums === String ? "Unknown" : 0;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.Type != null && message.hasOwnProperty("Type"))
                object.Type = options.enums === String ? $root.PropTradingProtocol.OcoGroupCreateMsg.GroupTypeEnum[message.Type] === undefined ? message.Type : $root.PropTradingProtocol.OcoGroupCreateMsg.GroupTypeEnum[message.Type] : message.Type;
            if (message.OcoLinkedOrderIds && message.OcoLinkedOrderIds.length) {
                object.OcoLinkedOrderIds = [];
                for (let j = 0; j < message.OcoLinkedOrderIds.length; ++j)
                    if (typeof message.OcoLinkedOrderIds[j] === "number")
                        object.OcoLinkedOrderIds[j] = options.longs === String ? String(message.OcoLinkedOrderIds[j]) : message.OcoLinkedOrderIds[j];
                    else
                        object.OcoLinkedOrderIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.OcoLinkedOrderIds[j]) : options.longs === Number ? new $util.LongBits(message.OcoLinkedOrderIds[j].low >>> 0, message.OcoLinkedOrderIds[j].high >>> 0).toNumber() : message.OcoLinkedOrderIds[j];
            }
            if (message.OrderPlace != null && message.hasOwnProperty("OrderPlace"))
                object.OrderPlace = options.enums === String ? $root.PropTradingProtocol.OcoGroupCreateMsg.OcoOrdersPlaceEnum[message.OrderPlace] === undefined ? message.OrderPlace : $root.PropTradingProtocol.OcoGroupCreateMsg.OcoOrdersPlaceEnum[message.OrderPlace] : message.OrderPlace;
            if (message.OrderInsert && message.OrderInsert.length) {
                object.OrderInsert = [];
                for (let j = 0; j < message.OrderInsert.length; ++j)
                    object.OrderInsert[j] = $root.PropTradingProtocol.OrderInsertMsg.toObject(message.OrderInsert[j], options);
            }
            if (message.Source != null && message.hasOwnProperty("Source"))
                object.Source = options.enums === String ? $root.PropTradingProtocol.RequestSourceEnum[message.Source] === undefined ? message.Source : $root.PropTradingProtocol.RequestSourceEnum[message.Source] : message.Source;
            return object;
        };

        /**
         * Converts this OcoGroupCreateMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OcoGroupCreateMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OcoGroupCreateMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.OcoGroupCreateMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OcoGroupCreateMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.OcoGroupCreateMsg";
        };

        /**
         * GroupTypeEnum enum.
         * @name PropTradingProtocol.OcoGroupCreateMsg.GroupTypeEnum
         * @enum {number}
         * @property {number} STOPS_LIMITS=0 STOPS_LIMITS value
         * @property {number} OPPOSITE_QTY=1 OPPOSITE_QTY value
         */
        OcoGroupCreateMsg.GroupTypeEnum = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "STOPS_LIMITS"] = 0;
            values[valuesById[1] = "OPPOSITE_QTY"] = 1;
            return values;
        })();

        /**
         * OcoOrdersPlaceEnum enum.
         * @name PropTradingProtocol.OcoGroupCreateMsg.OcoOrdersPlaceEnum
         * @enum {number}
         * @property {number} EXISTING=0 EXISTING value
         * @property {number} INSERT=1 INSERT value
         */
        OcoGroupCreateMsg.OcoOrdersPlaceEnum = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "EXISTING"] = 0;
            values[valuesById[1] = "INSERT"] = 1;
            return values;
        })();

        return OcoGroupCreateMsg;
    })();

    PropTradingProtocol.OcoGroupRemoveMsg = (function() {

        /**
         * Properties of an OcoGroupRemoveMsg.
         * @memberof PropTradingProtocol
         * @interface IOcoGroupRemoveMsg
         * @property {number|Long|null} [RequestId] OcoGroupRemoveMsg RequestId
         * @property {number|Long|null} [AccNumber] OcoGroupRemoveMsg AccNumber
         * @property {number|Long|null} [OcoGroupId] OcoGroupRemoveMsg OcoGroupId
         * @property {PropTradingProtocol.RequestSourceEnum|null} [Source] OcoGroupRemoveMsg Source
         */

        /**
         * Constructs a new OcoGroupRemoveMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an OcoGroupRemoveMsg.
         * @implements IOcoGroupRemoveMsg
         * @constructor
         * @param {PropTradingProtocol.IOcoGroupRemoveMsg=} [properties] Properties to set
         */
        function OcoGroupRemoveMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OcoGroupRemoveMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.OcoGroupRemoveMsg
         * @instance
         */
        OcoGroupRemoveMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OcoGroupRemoveMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.OcoGroupRemoveMsg
         * @instance
         */
        OcoGroupRemoveMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OcoGroupRemoveMsg OcoGroupId.
         * @member {number|Long} OcoGroupId
         * @memberof PropTradingProtocol.OcoGroupRemoveMsg
         * @instance
         */
        OcoGroupRemoveMsg.prototype.OcoGroupId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OcoGroupRemoveMsg Source.
         * @member {PropTradingProtocol.RequestSourceEnum} Source
         * @memberof PropTradingProtocol.OcoGroupRemoveMsg
         * @instance
         */
        OcoGroupRemoveMsg.prototype.Source = 0;

        /**
         * Creates a new OcoGroupRemoveMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.OcoGroupRemoveMsg
         * @static
         * @param {PropTradingProtocol.IOcoGroupRemoveMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.OcoGroupRemoveMsg} OcoGroupRemoveMsg instance
         */
        OcoGroupRemoveMsg.create = function create(properties) {
            return new OcoGroupRemoveMsg(properties);
        };

        /**
         * Encodes the specified OcoGroupRemoveMsg message. Does not implicitly {@link PropTradingProtocol.OcoGroupRemoveMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.OcoGroupRemoveMsg
         * @static
         * @param {PropTradingProtocol.IOcoGroupRemoveMsg} message OcoGroupRemoveMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OcoGroupRemoveMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccNumber);
            if (message.OcoGroupId != null && Object.hasOwnProperty.call(message, "OcoGroupId"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint64(message.OcoGroupId);
            if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Source);
            return writer;
        };

        /**
         * Encodes the specified OcoGroupRemoveMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.OcoGroupRemoveMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.OcoGroupRemoveMsg
         * @static
         * @param {PropTradingProtocol.IOcoGroupRemoveMsg} message OcoGroupRemoveMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OcoGroupRemoveMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OcoGroupRemoveMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.OcoGroupRemoveMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.OcoGroupRemoveMsg} OcoGroupRemoveMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OcoGroupRemoveMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.OcoGroupRemoveMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 3: {
                        message.OcoGroupId = reader.sint64();
                        break;
                    }
                case 4: {
                        message.Source = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OcoGroupRemoveMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.OcoGroupRemoveMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.OcoGroupRemoveMsg} OcoGroupRemoveMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OcoGroupRemoveMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OcoGroupRemoveMsg message.
         * @function verify
         * @memberof PropTradingProtocol.OcoGroupRemoveMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OcoGroupRemoveMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.OcoGroupId != null && message.hasOwnProperty("OcoGroupId"))
                if (!$util.isInteger(message.OcoGroupId) && !(message.OcoGroupId && $util.isInteger(message.OcoGroupId.low) && $util.isInteger(message.OcoGroupId.high)))
                    return "OcoGroupId: integer|Long expected";
            if (message.Source != null && message.hasOwnProperty("Source"))
                switch (message.Source) {
                default:
                    return "Source: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates an OcoGroupRemoveMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.OcoGroupRemoveMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.OcoGroupRemoveMsg} OcoGroupRemoveMsg
         */
        OcoGroupRemoveMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.OcoGroupRemoveMsg)
                return object;
            let message = new $root.PropTradingProtocol.OcoGroupRemoveMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            if (object.OcoGroupId != null)
                if ($util.Long)
                    (message.OcoGroupId = $util.Long.fromValue(object.OcoGroupId)).unsigned = false;
                else if (typeof object.OcoGroupId === "string")
                    message.OcoGroupId = parseInt(object.OcoGroupId, 10);
                else if (typeof object.OcoGroupId === "number")
                    message.OcoGroupId = object.OcoGroupId;
                else if (typeof object.OcoGroupId === "object")
                    message.OcoGroupId = new $util.LongBits(object.OcoGroupId.low >>> 0, object.OcoGroupId.high >>> 0).toNumber();
            switch (object.Source) {
            default:
                if (typeof object.Source === "number") {
                    message.Source = object.Source;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.Source = 0;
                break;
            case "Manual":
            case 1:
                message.Source = 1;
                break;
            case "Automatic":
            case 2:
                message.Source = 2;
                break;
            case "Copy":
            case 3:
                message.Source = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an OcoGroupRemoveMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.OcoGroupRemoveMsg
         * @static
         * @param {PropTradingProtocol.OcoGroupRemoveMsg} message OcoGroupRemoveMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OcoGroupRemoveMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OcoGroupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OcoGroupId = options.longs === String ? "0" : 0;
                object.Source = options.enums === String ? "Unknown" : 0;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.OcoGroupId != null && message.hasOwnProperty("OcoGroupId"))
                if (typeof message.OcoGroupId === "number")
                    object.OcoGroupId = options.longs === String ? String(message.OcoGroupId) : message.OcoGroupId;
                else
                    object.OcoGroupId = options.longs === String ? $util.Long.prototype.toString.call(message.OcoGroupId) : options.longs === Number ? new $util.LongBits(message.OcoGroupId.low >>> 0, message.OcoGroupId.high >>> 0).toNumber() : message.OcoGroupId;
            if (message.Source != null && message.hasOwnProperty("Source"))
                object.Source = options.enums === String ? $root.PropTradingProtocol.RequestSourceEnum[message.Source] === undefined ? message.Source : $root.PropTradingProtocol.RequestSourceEnum[message.Source] : message.Source;
            return object;
        };

        /**
         * Converts this OcoGroupRemoveMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.OcoGroupRemoveMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OcoGroupRemoveMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OcoGroupRemoveMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.OcoGroupRemoveMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OcoGroupRemoveMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.OcoGroupRemoveMsg";
        };

        return OcoGroupRemoveMsg;
    })();

    PropTradingProtocol.OcoGroupReportMsg = (function() {

        /**
         * Properties of an OcoGroupReportMsg.
         * @memberof PropTradingProtocol
         * @interface IOcoGroupReportMsg
         * @property {number|Long|null} [RequestId] OcoGroupReportMsg RequestId
         * @property {boolean|null} [Success] OcoGroupReportMsg Success
         * @property {number|Long|null} [OcoGroupId] OcoGroupReportMsg OcoGroupId
         * @property {string|null} [Reason] OcoGroupReportMsg Reason
         */

        /**
         * Constructs a new OcoGroupReportMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an OcoGroupReportMsg.
         * @implements IOcoGroupReportMsg
         * @constructor
         * @param {PropTradingProtocol.IOcoGroupReportMsg=} [properties] Properties to set
         */
        function OcoGroupReportMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OcoGroupReportMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.OcoGroupReportMsg
         * @instance
         */
        OcoGroupReportMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OcoGroupReportMsg Success.
         * @member {boolean} Success
         * @memberof PropTradingProtocol.OcoGroupReportMsg
         * @instance
         */
        OcoGroupReportMsg.prototype.Success = false;

        /**
         * OcoGroupReportMsg OcoGroupId.
         * @member {number|Long} OcoGroupId
         * @memberof PropTradingProtocol.OcoGroupReportMsg
         * @instance
         */
        OcoGroupReportMsg.prototype.OcoGroupId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OcoGroupReportMsg Reason.
         * @member {string} Reason
         * @memberof PropTradingProtocol.OcoGroupReportMsg
         * @instance
         */
        OcoGroupReportMsg.prototype.Reason = "";

        /**
         * Creates a new OcoGroupReportMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.OcoGroupReportMsg
         * @static
         * @param {PropTradingProtocol.IOcoGroupReportMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.OcoGroupReportMsg} OcoGroupReportMsg instance
         */
        OcoGroupReportMsg.create = function create(properties) {
            return new OcoGroupReportMsg(properties);
        };

        /**
         * Encodes the specified OcoGroupReportMsg message. Does not implicitly {@link PropTradingProtocol.OcoGroupReportMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.OcoGroupReportMsg
         * @static
         * @param {PropTradingProtocol.IOcoGroupReportMsg} message OcoGroupReportMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OcoGroupReportMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Success != null && Object.hasOwnProperty.call(message, "Success"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.Success);
            if (message.OcoGroupId != null && Object.hasOwnProperty.call(message, "OcoGroupId"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint64(message.OcoGroupId);
            if (message.Reason != null && Object.hasOwnProperty.call(message, "Reason"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.Reason);
            return writer;
        };

        /**
         * Encodes the specified OcoGroupReportMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.OcoGroupReportMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.OcoGroupReportMsg
         * @static
         * @param {PropTradingProtocol.IOcoGroupReportMsg} message OcoGroupReportMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OcoGroupReportMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OcoGroupReportMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.OcoGroupReportMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.OcoGroupReportMsg} OcoGroupReportMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OcoGroupReportMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.OcoGroupReportMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.Success = reader.bool();
                        break;
                    }
                case 3: {
                        message.OcoGroupId = reader.sint64();
                        break;
                    }
                case 4: {
                        message.Reason = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OcoGroupReportMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.OcoGroupReportMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.OcoGroupReportMsg} OcoGroupReportMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OcoGroupReportMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OcoGroupReportMsg message.
         * @function verify
         * @memberof PropTradingProtocol.OcoGroupReportMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OcoGroupReportMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Success != null && message.hasOwnProperty("Success"))
                if (typeof message.Success !== "boolean")
                    return "Success: boolean expected";
            if (message.OcoGroupId != null && message.hasOwnProperty("OcoGroupId"))
                if (!$util.isInteger(message.OcoGroupId) && !(message.OcoGroupId && $util.isInteger(message.OcoGroupId.low) && $util.isInteger(message.OcoGroupId.high)))
                    return "OcoGroupId: integer|Long expected";
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                if (!$util.isString(message.Reason))
                    return "Reason: string expected";
            return null;
        };

        /**
         * Creates an OcoGroupReportMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.OcoGroupReportMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.OcoGroupReportMsg} OcoGroupReportMsg
         */
        OcoGroupReportMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.OcoGroupReportMsg)
                return object;
            let message = new $root.PropTradingProtocol.OcoGroupReportMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Success != null)
                message.Success = Boolean(object.Success);
            if (object.OcoGroupId != null)
                if ($util.Long)
                    (message.OcoGroupId = $util.Long.fromValue(object.OcoGroupId)).unsigned = false;
                else if (typeof object.OcoGroupId === "string")
                    message.OcoGroupId = parseInt(object.OcoGroupId, 10);
                else if (typeof object.OcoGroupId === "number")
                    message.OcoGroupId = object.OcoGroupId;
                else if (typeof object.OcoGroupId === "object")
                    message.OcoGroupId = new $util.LongBits(object.OcoGroupId.low >>> 0, object.OcoGroupId.high >>> 0).toNumber();
            if (object.Reason != null)
                message.Reason = String(object.Reason);
            return message;
        };

        /**
         * Creates a plain object from an OcoGroupReportMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.OcoGroupReportMsg
         * @static
         * @param {PropTradingProtocol.OcoGroupReportMsg} message OcoGroupReportMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OcoGroupReportMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.Success = false;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OcoGroupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OcoGroupId = options.longs === String ? "0" : 0;
                object.Reason = "";
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Success != null && message.hasOwnProperty("Success"))
                object.Success = message.Success;
            if (message.OcoGroupId != null && message.hasOwnProperty("OcoGroupId"))
                if (typeof message.OcoGroupId === "number")
                    object.OcoGroupId = options.longs === String ? String(message.OcoGroupId) : message.OcoGroupId;
                else
                    object.OcoGroupId = options.longs === String ? $util.Long.prototype.toString.call(message.OcoGroupId) : options.longs === Number ? new $util.LongBits(message.OcoGroupId.low >>> 0, message.OcoGroupId.high >>> 0).toNumber() : message.OcoGroupId;
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                object.Reason = message.Reason;
            return object;
        };

        /**
         * Converts this OcoGroupReportMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.OcoGroupReportMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OcoGroupReportMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OcoGroupReportMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.OcoGroupReportMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OcoGroupReportMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.OcoGroupReportMsg";
        };

        return OcoGroupReportMsg;
    })();

    PropTradingProtocol.PositionFlatMsg = (function() {

        /**
         * Properties of a PositionFlatMsg.
         * @memberof PropTradingProtocol
         * @interface IPositionFlatMsg
         * @property {number|Long|null} [PositionId] PositionFlatMsg PositionId
         * @property {number|Long|null} [AccNumber] PositionFlatMsg AccNumber
         * @property {PropTradingProtocol.RequestSourceEnum|null} [Source] PositionFlatMsg Source
         */

        /**
         * Constructs a new PositionFlatMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a PositionFlatMsg.
         * @implements IPositionFlatMsg
         * @constructor
         * @param {PropTradingProtocol.IPositionFlatMsg=} [properties] Properties to set
         */
        function PositionFlatMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PositionFlatMsg PositionId.
         * @member {number|Long} PositionId
         * @memberof PropTradingProtocol.PositionFlatMsg
         * @instance
         */
        PositionFlatMsg.prototype.PositionId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PositionFlatMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.PositionFlatMsg
         * @instance
         */
        PositionFlatMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PositionFlatMsg Source.
         * @member {PropTradingProtocol.RequestSourceEnum} Source
         * @memberof PropTradingProtocol.PositionFlatMsg
         * @instance
         */
        PositionFlatMsg.prototype.Source = 0;

        /**
         * Creates a new PositionFlatMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.PositionFlatMsg
         * @static
         * @param {PropTradingProtocol.IPositionFlatMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.PositionFlatMsg} PositionFlatMsg instance
         */
        PositionFlatMsg.create = function create(properties) {
            return new PositionFlatMsg(properties);
        };

        /**
         * Encodes the specified PositionFlatMsg message. Does not implicitly {@link PropTradingProtocol.PositionFlatMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.PositionFlatMsg
         * @static
         * @param {PropTradingProtocol.IPositionFlatMsg} message PositionFlatMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionFlatMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PositionId != null && Object.hasOwnProperty.call(message, "PositionId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.PositionId);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccNumber);
            if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Source);
            return writer;
        };

        /**
         * Encodes the specified PositionFlatMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.PositionFlatMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.PositionFlatMsg
         * @static
         * @param {PropTradingProtocol.IPositionFlatMsg} message PositionFlatMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionFlatMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PositionFlatMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.PositionFlatMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.PositionFlatMsg} PositionFlatMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionFlatMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.PositionFlatMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.PositionId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 3: {
                        message.Source = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PositionFlatMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.PositionFlatMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.PositionFlatMsg} PositionFlatMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionFlatMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PositionFlatMsg message.
         * @function verify
         * @memberof PropTradingProtocol.PositionFlatMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PositionFlatMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PositionId != null && message.hasOwnProperty("PositionId"))
                if (!$util.isInteger(message.PositionId) && !(message.PositionId && $util.isInteger(message.PositionId.low) && $util.isInteger(message.PositionId.high)))
                    return "PositionId: integer|Long expected";
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.Source != null && message.hasOwnProperty("Source"))
                switch (message.Source) {
                default:
                    return "Source: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a PositionFlatMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.PositionFlatMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.PositionFlatMsg} PositionFlatMsg
         */
        PositionFlatMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.PositionFlatMsg)
                return object;
            let message = new $root.PropTradingProtocol.PositionFlatMsg();
            if (object.PositionId != null)
                if ($util.Long)
                    (message.PositionId = $util.Long.fromValue(object.PositionId)).unsigned = false;
                else if (typeof object.PositionId === "string")
                    message.PositionId = parseInt(object.PositionId, 10);
                else if (typeof object.PositionId === "number")
                    message.PositionId = object.PositionId;
                else if (typeof object.PositionId === "object")
                    message.PositionId = new $util.LongBits(object.PositionId.low >>> 0, object.PositionId.high >>> 0).toNumber();
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            switch (object.Source) {
            default:
                if (typeof object.Source === "number") {
                    message.Source = object.Source;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.Source = 0;
                break;
            case "Manual":
            case 1:
                message.Source = 1;
                break;
            case "Automatic":
            case 2:
                message.Source = 2;
                break;
            case "Copy":
            case 3:
                message.Source = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a PositionFlatMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.PositionFlatMsg
         * @static
         * @param {PropTradingProtocol.PositionFlatMsg} message PositionFlatMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PositionFlatMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.PositionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.PositionId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                object.Source = options.enums === String ? "Unknown" : 0;
            }
            if (message.PositionId != null && message.hasOwnProperty("PositionId"))
                if (typeof message.PositionId === "number")
                    object.PositionId = options.longs === String ? String(message.PositionId) : message.PositionId;
                else
                    object.PositionId = options.longs === String ? $util.Long.prototype.toString.call(message.PositionId) : options.longs === Number ? new $util.LongBits(message.PositionId.low >>> 0, message.PositionId.high >>> 0).toNumber() : message.PositionId;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.Source != null && message.hasOwnProperty("Source"))
                object.Source = options.enums === String ? $root.PropTradingProtocol.RequestSourceEnum[message.Source] === undefined ? message.Source : $root.PropTradingProtocol.RequestSourceEnum[message.Source] : message.Source;
            return object;
        };

        /**
         * Converts this PositionFlatMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.PositionFlatMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PositionFlatMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PositionFlatMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.PositionFlatMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PositionFlatMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.PositionFlatMsg";
        };

        return PositionFlatMsg;
    })();

    PropTradingProtocol.OrderInfoMsg = (function() {

        /**
         * Properties of an OrderInfoMsg.
         * @memberof PropTradingProtocol
         * @interface IOrderInfoMsg
         * @property {number|Long|null} [ContractId] OrderInfoMsg ContractId
         * @property {number|Long|null} [OrgServerId] OrderInfoMsg OrgServerId
         * @property {number|null} [OrgClientId] OrderInfoMsg OrgClientId
         * @property {number|Long|null} [SeqServerId] OrderInfoMsg SeqServerId
         * @property {number|null} [SeqClientId] OrderInfoMsg SeqClientId
         * @property {number|null} [OrderPrice] OrderInfoMsg OrderPrice
         * @property {number|null} [OrderLimitPrice] OrderInfoMsg OrderLimitPrice
         * @property {number|null} [PendingQty] OrderInfoMsg PendingQty
         * @property {number|null} [FilledQty] OrderInfoMsg FilledQty
         * @property {PropTradingProtocol.OrderTypeEnum|null} [OrderType] OrderInfoMsg OrderType
         * @property {PropTradingProtocol.OrderInfoMsg.OrderStateEnum|null} [OrderState] OrderInfoMsg OrderState
         * @property {number|null} [AvgPrice] OrderInfoMsg AvgPrice
         * @property {PropTradingProtocol.OrderInfoMsg.SnapTypeEnum|null} [SnapType] OrderInfoMsg SnapType
         * @property {number|Long|null} [AccNumber] OrderInfoMsg AccNumber
         * @property {string|null} [Reason] OrderInfoMsg Reason
         * @property {string|null} [FeedSymbol] OrderInfoMsg FeedSymbol
         * @property {string|null} [Isin] OrderInfoMsg Isin
         * @property {number|Long|null} [OcoLinkedGroupId] OrderInfoMsg OcoLinkedGroupId
         * @property {Array.<number|Long>|null} [OcoLinkedOrderIds] OrderInfoMsg OcoLinkedOrderIds
         * @property {number|Long|null} [OcoParentOrderId] OrderInfoMsg OcoParentOrderId
         * @property {number|Long|null} [PositionLinkId] OrderInfoMsg PositionLinkId
         * @property {boolean|null} [IsGeneratedFromBracket] OrderInfoMsg IsGeneratedFromBracket
         * @property {PropTradingProtocol.OrderQuantityModeEnum|null} [QuantityMode] OrderInfoMsg QuantityMode
         * @property {number|Long|null} [InsertUtc] OrderInfoMsg InsertUtc
         * @property {number|Long|null} [ExeuctionUtc] OrderInfoMsg ExeuctionUtc
         * @property {string|null} [Ip] OrderInfoMsg Ip
         * @property {string|null} [Source] OrderInfoMsg Source
         * @property {number|Long|null} [OrgClientSessionId] RESERVED FIELDS*************************
         * @property {number|Long|null} [SeqClientSessionId] OrderInfoMsg SeqClientSessionId
         * @property {boolean|null} [IsValidationError] OrderInfoMsg IsValidationError
         */

        /**
         * Constructs a new OrderInfoMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an OrderInfoMsg.
         * @implements IOrderInfoMsg
         * @constructor
         * @param {PropTradingProtocol.IOrderInfoMsg=} [properties] Properties to set
         */
        function OrderInfoMsg(properties) {
            this.OcoLinkedOrderIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OrderInfoMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderInfoMsg OrgServerId.
         * @member {number|Long} OrgServerId
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.OrgServerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderInfoMsg OrgClientId.
         * @member {number} OrgClientId
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.OrgClientId = 0;

        /**
         * OrderInfoMsg SeqServerId.
         * @member {number|Long} SeqServerId
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.SeqServerId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderInfoMsg SeqClientId.
         * @member {number} SeqClientId
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.SeqClientId = 0;

        /**
         * OrderInfoMsg OrderPrice.
         * @member {number} OrderPrice
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.OrderPrice = 0;

        /**
         * OrderInfoMsg OrderLimitPrice.
         * @member {number} OrderLimitPrice
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.OrderLimitPrice = 0;

        /**
         * OrderInfoMsg PendingQty.
         * @member {number} PendingQty
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.PendingQty = 0;

        /**
         * OrderInfoMsg FilledQty.
         * @member {number} FilledQty
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.FilledQty = 0;

        /**
         * OrderInfoMsg OrderType.
         * @member {PropTradingProtocol.OrderTypeEnum} OrderType
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.OrderType = 0;

        /**
         * OrderInfoMsg OrderState.
         * @member {PropTradingProtocol.OrderInfoMsg.OrderStateEnum} OrderState
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.OrderState = 0;

        /**
         * OrderInfoMsg AvgPrice.
         * @member {number} AvgPrice
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.AvgPrice = 0;

        /**
         * OrderInfoMsg SnapType.
         * @member {PropTradingProtocol.OrderInfoMsg.SnapTypeEnum} SnapType
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.SnapType = 1;

        /**
         * OrderInfoMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderInfoMsg Reason.
         * @member {string} Reason
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.Reason = "";

        /**
         * OrderInfoMsg FeedSymbol.
         * @member {string} FeedSymbol
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.FeedSymbol = "";

        /**
         * OrderInfoMsg Isin.
         * @member {string} Isin
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.Isin = "";

        /**
         * OrderInfoMsg OcoLinkedGroupId.
         * @member {number|Long} OcoLinkedGroupId
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.OcoLinkedGroupId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderInfoMsg OcoLinkedOrderIds.
         * @member {Array.<number|Long>} OcoLinkedOrderIds
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.OcoLinkedOrderIds = $util.emptyArray;

        /**
         * OrderInfoMsg OcoParentOrderId.
         * @member {number|Long} OcoParentOrderId
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.OcoParentOrderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderInfoMsg PositionLinkId.
         * @member {number|Long} PositionLinkId
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.PositionLinkId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderInfoMsg IsGeneratedFromBracket.
         * @member {boolean} IsGeneratedFromBracket
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.IsGeneratedFromBracket = false;

        /**
         * OrderInfoMsg QuantityMode.
         * @member {PropTradingProtocol.OrderQuantityModeEnum} QuantityMode
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.QuantityMode = 0;

        /**
         * OrderInfoMsg InsertUtc.
         * @member {number|Long} InsertUtc
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.InsertUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderInfoMsg ExeuctionUtc.
         * @member {number|Long} ExeuctionUtc
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.ExeuctionUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderInfoMsg Ip.
         * @member {string} Ip
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.Ip = "";

        /**
         * OrderInfoMsg Source.
         * @member {string} Source
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.Source = "";

        /**
         * RESERVED FIELDS*************************
         * @member {number|Long} OrgClientSessionId
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.OrgClientSessionId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderInfoMsg SeqClientSessionId.
         * @member {number|Long} SeqClientSessionId
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.SeqClientSessionId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * OrderInfoMsg IsValidationError.
         * @member {boolean} IsValidationError
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         */
        OrderInfoMsg.prototype.IsValidationError = false;

        /**
         * Creates a new OrderInfoMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @static
         * @param {PropTradingProtocol.IOrderInfoMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.OrderInfoMsg} OrderInfoMsg instance
         */
        OrderInfoMsg.create = function create(properties) {
            return new OrderInfoMsg(properties);
        };

        /**
         * Encodes the specified OrderInfoMsg message. Does not implicitly {@link PropTradingProtocol.OrderInfoMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @static
         * @param {PropTradingProtocol.IOrderInfoMsg} message OrderInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderInfoMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.ContractId);
            if (message.OrgServerId != null && Object.hasOwnProperty.call(message, "OrgServerId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.OrgServerId);
            if (message.OrgClientId != null && Object.hasOwnProperty.call(message, "OrgClientId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.OrgClientId);
            if (message.SeqServerId != null && Object.hasOwnProperty.call(message, "SeqServerId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.SeqServerId);
            if (message.SeqClientId != null && Object.hasOwnProperty.call(message, "SeqClientId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.SeqClientId);
            if (message.OrderPrice != null && Object.hasOwnProperty.call(message, "OrderPrice"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.OrderPrice);
            if (message.OrderLimitPrice != null && Object.hasOwnProperty.call(message, "OrderLimitPrice"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.OrderLimitPrice);
            if (message.PendingQty != null && Object.hasOwnProperty.call(message, "PendingQty"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.PendingQty);
            if (message.FilledQty != null && Object.hasOwnProperty.call(message, "FilledQty"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.FilledQty);
            if (message.OrderType != null && Object.hasOwnProperty.call(message, "OrderType"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.OrderType);
            if (message.OrderState != null && Object.hasOwnProperty.call(message, "OrderState"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.OrderState);
            if (message.AvgPrice != null && Object.hasOwnProperty.call(message, "AvgPrice"))
                writer.uint32(/* id 12, wireType 1 =*/97).double(message.AvgPrice);
            if (message.SnapType != null && Object.hasOwnProperty.call(message, "SnapType"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.SnapType);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 14, wireType 0 =*/112).sint64(message.AccNumber);
            if (message.Reason != null && Object.hasOwnProperty.call(message, "Reason"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.Reason);
            if (message.FeedSymbol != null && Object.hasOwnProperty.call(message, "FeedSymbol"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.FeedSymbol);
            if (message.Isin != null && Object.hasOwnProperty.call(message, "Isin"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.Isin);
            if (message.OcoLinkedGroupId != null && Object.hasOwnProperty.call(message, "OcoLinkedGroupId"))
                writer.uint32(/* id 18, wireType 0 =*/144).sint64(message.OcoLinkedGroupId);
            if (message.OcoLinkedOrderIds != null && message.OcoLinkedOrderIds.length) {
                writer.uint32(/* id 19, wireType 2 =*/154).fork();
                for (let i = 0; i < message.OcoLinkedOrderIds.length; ++i)
                    writer.sint64(message.OcoLinkedOrderIds[i]);
                writer.ldelim();
            }
            if (message.OcoParentOrderId != null && Object.hasOwnProperty.call(message, "OcoParentOrderId"))
                writer.uint32(/* id 20, wireType 0 =*/160).sint64(message.OcoParentOrderId);
            if (message.PositionLinkId != null && Object.hasOwnProperty.call(message, "PositionLinkId"))
                writer.uint32(/* id 21, wireType 0 =*/168).sint64(message.PositionLinkId);
            if (message.IsGeneratedFromBracket != null && Object.hasOwnProperty.call(message, "IsGeneratedFromBracket"))
                writer.uint32(/* id 22, wireType 0 =*/176).bool(message.IsGeneratedFromBracket);
            if (message.QuantityMode != null && Object.hasOwnProperty.call(message, "QuantityMode"))
                writer.uint32(/* id 23, wireType 0 =*/184).int32(message.QuantityMode);
            if (message.InsertUtc != null && Object.hasOwnProperty.call(message, "InsertUtc"))
                writer.uint32(/* id 24, wireType 0 =*/192).sint64(message.InsertUtc);
            if (message.ExeuctionUtc != null && Object.hasOwnProperty.call(message, "ExeuctionUtc"))
                writer.uint32(/* id 25, wireType 0 =*/200).sint64(message.ExeuctionUtc);
            if (message.Ip != null && Object.hasOwnProperty.call(message, "Ip"))
                writer.uint32(/* id 26, wireType 2 =*/210).string(message.Ip);
            if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                writer.uint32(/* id 27, wireType 2 =*/218).string(message.Source);
            if (message.OrgClientSessionId != null && Object.hasOwnProperty.call(message, "OrgClientSessionId"))
                writer.uint32(/* id 100, wireType 0 =*/800).sint64(message.OrgClientSessionId);
            if (message.SeqClientSessionId != null && Object.hasOwnProperty.call(message, "SeqClientSessionId"))
                writer.uint32(/* id 101, wireType 0 =*/808).sint64(message.SeqClientSessionId);
            if (message.IsValidationError != null && Object.hasOwnProperty.call(message, "IsValidationError"))
                writer.uint32(/* id 102, wireType 0 =*/816).bool(message.IsValidationError);
            return writer;
        };

        /**
         * Encodes the specified OrderInfoMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.OrderInfoMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @static
         * @param {PropTradingProtocol.IOrderInfoMsg} message OrderInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OrderInfoMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OrderInfoMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.OrderInfoMsg} OrderInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderInfoMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.OrderInfoMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.OrgServerId = reader.sint64();
                        break;
                    }
                case 3: {
                        message.OrgClientId = reader.int32();
                        break;
                    }
                case 4: {
                        message.SeqServerId = reader.int64();
                        break;
                    }
                case 5: {
                        message.SeqClientId = reader.int32();
                        break;
                    }
                case 6: {
                        message.OrderPrice = reader.double();
                        break;
                    }
                case 7: {
                        message.OrderLimitPrice = reader.double();
                        break;
                    }
                case 8: {
                        message.PendingQty = reader.int32();
                        break;
                    }
                case 9: {
                        message.FilledQty = reader.int32();
                        break;
                    }
                case 10: {
                        message.OrderType = reader.int32();
                        break;
                    }
                case 11: {
                        message.OrderState = reader.int32();
                        break;
                    }
                case 12: {
                        message.AvgPrice = reader.double();
                        break;
                    }
                case 13: {
                        message.SnapType = reader.int32();
                        break;
                    }
                case 14: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 15: {
                        message.Reason = reader.string();
                        break;
                    }
                case 16: {
                        message.FeedSymbol = reader.string();
                        break;
                    }
                case 17: {
                        message.Isin = reader.string();
                        break;
                    }
                case 18: {
                        message.OcoLinkedGroupId = reader.sint64();
                        break;
                    }
                case 19: {
                        if (!(message.OcoLinkedOrderIds && message.OcoLinkedOrderIds.length))
                            message.OcoLinkedOrderIds = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.OcoLinkedOrderIds.push(reader.sint64());
                        } else
                            message.OcoLinkedOrderIds.push(reader.sint64());
                        break;
                    }
                case 20: {
                        message.OcoParentOrderId = reader.sint64();
                        break;
                    }
                case 21: {
                        message.PositionLinkId = reader.sint64();
                        break;
                    }
                case 22: {
                        message.IsGeneratedFromBracket = reader.bool();
                        break;
                    }
                case 23: {
                        message.QuantityMode = reader.int32();
                        break;
                    }
                case 24: {
                        message.InsertUtc = reader.sint64();
                        break;
                    }
                case 25: {
                        message.ExeuctionUtc = reader.sint64();
                        break;
                    }
                case 26: {
                        message.Ip = reader.string();
                        break;
                    }
                case 27: {
                        message.Source = reader.string();
                        break;
                    }
                case 100: {
                        message.OrgClientSessionId = reader.sint64();
                        break;
                    }
                case 101: {
                        message.SeqClientSessionId = reader.sint64();
                        break;
                    }
                case 102: {
                        message.IsValidationError = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OrderInfoMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.OrderInfoMsg} OrderInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OrderInfoMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OrderInfoMsg message.
         * @function verify
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OrderInfoMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.OrgServerId != null && message.hasOwnProperty("OrgServerId"))
                if (!$util.isInteger(message.OrgServerId) && !(message.OrgServerId && $util.isInteger(message.OrgServerId.low) && $util.isInteger(message.OrgServerId.high)))
                    return "OrgServerId: integer|Long expected";
            if (message.OrgClientId != null && message.hasOwnProperty("OrgClientId"))
                if (!$util.isInteger(message.OrgClientId))
                    return "OrgClientId: integer expected";
            if (message.SeqServerId != null && message.hasOwnProperty("SeqServerId"))
                if (!$util.isInteger(message.SeqServerId) && !(message.SeqServerId && $util.isInteger(message.SeqServerId.low) && $util.isInteger(message.SeqServerId.high)))
                    return "SeqServerId: integer|Long expected";
            if (message.SeqClientId != null && message.hasOwnProperty("SeqClientId"))
                if (!$util.isInteger(message.SeqClientId))
                    return "SeqClientId: integer expected";
            if (message.OrderPrice != null && message.hasOwnProperty("OrderPrice"))
                if (typeof message.OrderPrice !== "number")
                    return "OrderPrice: number expected";
            if (message.OrderLimitPrice != null && message.hasOwnProperty("OrderLimitPrice"))
                if (typeof message.OrderLimitPrice !== "number")
                    return "OrderLimitPrice: number expected";
            if (message.PendingQty != null && message.hasOwnProperty("PendingQty"))
                if (!$util.isInteger(message.PendingQty))
                    return "PendingQty: integer expected";
            if (message.FilledQty != null && message.hasOwnProperty("FilledQty"))
                if (!$util.isInteger(message.FilledQty))
                    return "FilledQty: integer expected";
            if (message.OrderType != null && message.hasOwnProperty("OrderType"))
                switch (message.OrderType) {
                default:
                    return "OrderType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.OrderState != null && message.hasOwnProperty("OrderState"))
                switch (message.OrderState) {
                default:
                    return "OrderState: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.AvgPrice != null && message.hasOwnProperty("AvgPrice"))
                if (typeof message.AvgPrice !== "number")
                    return "AvgPrice: number expected";
            if (message.SnapType != null && message.hasOwnProperty("SnapType"))
                switch (message.SnapType) {
                default:
                    return "SnapType: enum value expected";
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                if (!$util.isString(message.Reason))
                    return "Reason: string expected";
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                if (!$util.isString(message.FeedSymbol))
                    return "FeedSymbol: string expected";
            if (message.Isin != null && message.hasOwnProperty("Isin"))
                if (!$util.isString(message.Isin))
                    return "Isin: string expected";
            if (message.OcoLinkedGroupId != null && message.hasOwnProperty("OcoLinkedGroupId"))
                if (!$util.isInteger(message.OcoLinkedGroupId) && !(message.OcoLinkedGroupId && $util.isInteger(message.OcoLinkedGroupId.low) && $util.isInteger(message.OcoLinkedGroupId.high)))
                    return "OcoLinkedGroupId: integer|Long expected";
            if (message.OcoLinkedOrderIds != null && message.hasOwnProperty("OcoLinkedOrderIds")) {
                if (!Array.isArray(message.OcoLinkedOrderIds))
                    return "OcoLinkedOrderIds: array expected";
                for (let i = 0; i < message.OcoLinkedOrderIds.length; ++i)
                    if (!$util.isInteger(message.OcoLinkedOrderIds[i]) && !(message.OcoLinkedOrderIds[i] && $util.isInteger(message.OcoLinkedOrderIds[i].low) && $util.isInteger(message.OcoLinkedOrderIds[i].high)))
                        return "OcoLinkedOrderIds: integer|Long[] expected";
            }
            if (message.OcoParentOrderId != null && message.hasOwnProperty("OcoParentOrderId"))
                if (!$util.isInteger(message.OcoParentOrderId) && !(message.OcoParentOrderId && $util.isInteger(message.OcoParentOrderId.low) && $util.isInteger(message.OcoParentOrderId.high)))
                    return "OcoParentOrderId: integer|Long expected";
            if (message.PositionLinkId != null && message.hasOwnProperty("PositionLinkId"))
                if (!$util.isInteger(message.PositionLinkId) && !(message.PositionLinkId && $util.isInteger(message.PositionLinkId.low) && $util.isInteger(message.PositionLinkId.high)))
                    return "PositionLinkId: integer|Long expected";
            if (message.IsGeneratedFromBracket != null && message.hasOwnProperty("IsGeneratedFromBracket"))
                if (typeof message.IsGeneratedFromBracket !== "boolean")
                    return "IsGeneratedFromBracket: boolean expected";
            if (message.QuantityMode != null && message.hasOwnProperty("QuantityMode"))
                switch (message.QuantityMode) {
                default:
                    return "QuantityMode: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.InsertUtc != null && message.hasOwnProperty("InsertUtc"))
                if (!$util.isInteger(message.InsertUtc) && !(message.InsertUtc && $util.isInteger(message.InsertUtc.low) && $util.isInteger(message.InsertUtc.high)))
                    return "InsertUtc: integer|Long expected";
            if (message.ExeuctionUtc != null && message.hasOwnProperty("ExeuctionUtc"))
                if (!$util.isInteger(message.ExeuctionUtc) && !(message.ExeuctionUtc && $util.isInteger(message.ExeuctionUtc.low) && $util.isInteger(message.ExeuctionUtc.high)))
                    return "ExeuctionUtc: integer|Long expected";
            if (message.Ip != null && message.hasOwnProperty("Ip"))
                if (!$util.isString(message.Ip))
                    return "Ip: string expected";
            if (message.Source != null && message.hasOwnProperty("Source"))
                if (!$util.isString(message.Source))
                    return "Source: string expected";
            if (message.OrgClientSessionId != null && message.hasOwnProperty("OrgClientSessionId"))
                if (!$util.isInteger(message.OrgClientSessionId) && !(message.OrgClientSessionId && $util.isInteger(message.OrgClientSessionId.low) && $util.isInteger(message.OrgClientSessionId.high)))
                    return "OrgClientSessionId: integer|Long expected";
            if (message.SeqClientSessionId != null && message.hasOwnProperty("SeqClientSessionId"))
                if (!$util.isInteger(message.SeqClientSessionId) && !(message.SeqClientSessionId && $util.isInteger(message.SeqClientSessionId.low) && $util.isInteger(message.SeqClientSessionId.high)))
                    return "SeqClientSessionId: integer|Long expected";
            if (message.IsValidationError != null && message.hasOwnProperty("IsValidationError"))
                if (typeof message.IsValidationError !== "boolean")
                    return "IsValidationError: boolean expected";
            return null;
        };

        /**
         * Creates an OrderInfoMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.OrderInfoMsg} OrderInfoMsg
         */
        OrderInfoMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.OrderInfoMsg)
                return object;
            let message = new $root.PropTradingProtocol.OrderInfoMsg();
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.OrgServerId != null)
                if ($util.Long)
                    (message.OrgServerId = $util.Long.fromValue(object.OrgServerId)).unsigned = false;
                else if (typeof object.OrgServerId === "string")
                    message.OrgServerId = parseInt(object.OrgServerId, 10);
                else if (typeof object.OrgServerId === "number")
                    message.OrgServerId = object.OrgServerId;
                else if (typeof object.OrgServerId === "object")
                    message.OrgServerId = new $util.LongBits(object.OrgServerId.low >>> 0, object.OrgServerId.high >>> 0).toNumber();
            if (object.OrgClientId != null)
                message.OrgClientId = object.OrgClientId | 0;
            if (object.SeqServerId != null)
                if ($util.Long)
                    (message.SeqServerId = $util.Long.fromValue(object.SeqServerId)).unsigned = false;
                else if (typeof object.SeqServerId === "string")
                    message.SeqServerId = parseInt(object.SeqServerId, 10);
                else if (typeof object.SeqServerId === "number")
                    message.SeqServerId = object.SeqServerId;
                else if (typeof object.SeqServerId === "object")
                    message.SeqServerId = new $util.LongBits(object.SeqServerId.low >>> 0, object.SeqServerId.high >>> 0).toNumber();
            if (object.SeqClientId != null)
                message.SeqClientId = object.SeqClientId | 0;
            if (object.OrderPrice != null)
                message.OrderPrice = Number(object.OrderPrice);
            if (object.OrderLimitPrice != null)
                message.OrderLimitPrice = Number(object.OrderLimitPrice);
            if (object.PendingQty != null)
                message.PendingQty = object.PendingQty | 0;
            if (object.FilledQty != null)
                message.FilledQty = object.FilledQty | 0;
            switch (object.OrderType) {
            default:
                if (typeof object.OrderType === "number") {
                    message.OrderType = object.OrderType;
                    break;
                }
                break;
            case "Market":
            case 0:
                message.OrderType = 0;
                break;
            case "Limit":
            case 1:
                message.OrderType = 1;
                break;
            case "Stop":
            case 2:
                message.OrderType = 2;
                break;
            case "StopLimit":
            case 3:
                message.OrderType = 3;
                break;
            }
            switch (object.OrderState) {
            default:
                if (typeof object.OrderState === "number") {
                    message.OrderState = object.OrderState;
                    break;
                }
                break;
            case "Submitted":
            case 0:
                message.OrderState = 0;
                break;
            case "Canceled":
            case 1:
                message.OrderState = 1;
                break;
            case "Error":
            case 2:
                message.OrderState = 2;
                break;
            case "ErrorModify":
            case 3:
                message.OrderState = 3;
                break;
            }
            if (object.AvgPrice != null)
                message.AvgPrice = Number(object.AvgPrice);
            switch (object.SnapType) {
            default:
                if (typeof object.SnapType === "number") {
                    message.SnapType = object.SnapType;
                    break;
                }
                break;
            case "Historical":
            case 1:
                message.SnapType = 1;
                break;
            case "RealTime":
            case 2:
                message.SnapType = 2;
                break;
            case "HistPos":
            case 3:
                message.SnapType = 3;
                break;
            }
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            if (object.Reason != null)
                message.Reason = String(object.Reason);
            if (object.FeedSymbol != null)
                message.FeedSymbol = String(object.FeedSymbol);
            if (object.Isin != null)
                message.Isin = String(object.Isin);
            if (object.OcoLinkedGroupId != null)
                if ($util.Long)
                    (message.OcoLinkedGroupId = $util.Long.fromValue(object.OcoLinkedGroupId)).unsigned = false;
                else if (typeof object.OcoLinkedGroupId === "string")
                    message.OcoLinkedGroupId = parseInt(object.OcoLinkedGroupId, 10);
                else if (typeof object.OcoLinkedGroupId === "number")
                    message.OcoLinkedGroupId = object.OcoLinkedGroupId;
                else if (typeof object.OcoLinkedGroupId === "object")
                    message.OcoLinkedGroupId = new $util.LongBits(object.OcoLinkedGroupId.low >>> 0, object.OcoLinkedGroupId.high >>> 0).toNumber();
            if (object.OcoLinkedOrderIds) {
                if (!Array.isArray(object.OcoLinkedOrderIds))
                    throw TypeError(".PropTradingProtocol.OrderInfoMsg.OcoLinkedOrderIds: array expected");
                message.OcoLinkedOrderIds = [];
                for (let i = 0; i < object.OcoLinkedOrderIds.length; ++i)
                    if ($util.Long)
                        (message.OcoLinkedOrderIds[i] = $util.Long.fromValue(object.OcoLinkedOrderIds[i])).unsigned = false;
                    else if (typeof object.OcoLinkedOrderIds[i] === "string")
                        message.OcoLinkedOrderIds[i] = parseInt(object.OcoLinkedOrderIds[i], 10);
                    else if (typeof object.OcoLinkedOrderIds[i] === "number")
                        message.OcoLinkedOrderIds[i] = object.OcoLinkedOrderIds[i];
                    else if (typeof object.OcoLinkedOrderIds[i] === "object")
                        message.OcoLinkedOrderIds[i] = new $util.LongBits(object.OcoLinkedOrderIds[i].low >>> 0, object.OcoLinkedOrderIds[i].high >>> 0).toNumber();
            }
            if (object.OcoParentOrderId != null)
                if ($util.Long)
                    (message.OcoParentOrderId = $util.Long.fromValue(object.OcoParentOrderId)).unsigned = false;
                else if (typeof object.OcoParentOrderId === "string")
                    message.OcoParentOrderId = parseInt(object.OcoParentOrderId, 10);
                else if (typeof object.OcoParentOrderId === "number")
                    message.OcoParentOrderId = object.OcoParentOrderId;
                else if (typeof object.OcoParentOrderId === "object")
                    message.OcoParentOrderId = new $util.LongBits(object.OcoParentOrderId.low >>> 0, object.OcoParentOrderId.high >>> 0).toNumber();
            if (object.PositionLinkId != null)
                if ($util.Long)
                    (message.PositionLinkId = $util.Long.fromValue(object.PositionLinkId)).unsigned = false;
                else if (typeof object.PositionLinkId === "string")
                    message.PositionLinkId = parseInt(object.PositionLinkId, 10);
                else if (typeof object.PositionLinkId === "number")
                    message.PositionLinkId = object.PositionLinkId;
                else if (typeof object.PositionLinkId === "object")
                    message.PositionLinkId = new $util.LongBits(object.PositionLinkId.low >>> 0, object.PositionLinkId.high >>> 0).toNumber();
            if (object.IsGeneratedFromBracket != null)
                message.IsGeneratedFromBracket = Boolean(object.IsGeneratedFromBracket);
            switch (object.QuantityMode) {
            default:
                if (typeof object.QuantityMode === "number") {
                    message.QuantityMode = object.QuantityMode;
                    break;
                }
                break;
            case "Fixed":
            case 0:
                message.QuantityMode = 0;
                break;
            case "All":
            case 1:
                message.QuantityMode = 1;
                break;
            case "AccountCountervalue":
            case 2:
                message.QuantityMode = 2;
                break;
            }
            if (object.InsertUtc != null)
                if ($util.Long)
                    (message.InsertUtc = $util.Long.fromValue(object.InsertUtc)).unsigned = false;
                else if (typeof object.InsertUtc === "string")
                    message.InsertUtc = parseInt(object.InsertUtc, 10);
                else if (typeof object.InsertUtc === "number")
                    message.InsertUtc = object.InsertUtc;
                else if (typeof object.InsertUtc === "object")
                    message.InsertUtc = new $util.LongBits(object.InsertUtc.low >>> 0, object.InsertUtc.high >>> 0).toNumber();
            if (object.ExeuctionUtc != null)
                if ($util.Long)
                    (message.ExeuctionUtc = $util.Long.fromValue(object.ExeuctionUtc)).unsigned = false;
                else if (typeof object.ExeuctionUtc === "string")
                    message.ExeuctionUtc = parseInt(object.ExeuctionUtc, 10);
                else if (typeof object.ExeuctionUtc === "number")
                    message.ExeuctionUtc = object.ExeuctionUtc;
                else if (typeof object.ExeuctionUtc === "object")
                    message.ExeuctionUtc = new $util.LongBits(object.ExeuctionUtc.low >>> 0, object.ExeuctionUtc.high >>> 0).toNumber();
            if (object.Ip != null)
                message.Ip = String(object.Ip);
            if (object.Source != null)
                message.Source = String(object.Source);
            if (object.OrgClientSessionId != null)
                if ($util.Long)
                    (message.OrgClientSessionId = $util.Long.fromValue(object.OrgClientSessionId)).unsigned = false;
                else if (typeof object.OrgClientSessionId === "string")
                    message.OrgClientSessionId = parseInt(object.OrgClientSessionId, 10);
                else if (typeof object.OrgClientSessionId === "number")
                    message.OrgClientSessionId = object.OrgClientSessionId;
                else if (typeof object.OrgClientSessionId === "object")
                    message.OrgClientSessionId = new $util.LongBits(object.OrgClientSessionId.low >>> 0, object.OrgClientSessionId.high >>> 0).toNumber();
            if (object.SeqClientSessionId != null)
                if ($util.Long)
                    (message.SeqClientSessionId = $util.Long.fromValue(object.SeqClientSessionId)).unsigned = false;
                else if (typeof object.SeqClientSessionId === "string")
                    message.SeqClientSessionId = parseInt(object.SeqClientSessionId, 10);
                else if (typeof object.SeqClientSessionId === "number")
                    message.SeqClientSessionId = object.SeqClientSessionId;
                else if (typeof object.SeqClientSessionId === "object")
                    message.SeqClientSessionId = new $util.LongBits(object.SeqClientSessionId.low >>> 0, object.SeqClientSessionId.high >>> 0).toNumber();
            if (object.IsValidationError != null)
                message.IsValidationError = Boolean(object.IsValidationError);
            return message;
        };

        /**
         * Creates a plain object from an OrderInfoMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @static
         * @param {PropTradingProtocol.OrderInfoMsg} message OrderInfoMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OrderInfoMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.OcoLinkedOrderIds = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OrgServerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OrgServerId = options.longs === String ? "0" : 0;
                object.OrgClientId = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.SeqServerId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.SeqServerId = options.longs === String ? "0" : 0;
                object.SeqClientId = 0;
                object.OrderPrice = 0;
                object.OrderLimitPrice = 0;
                object.PendingQty = 0;
                object.FilledQty = 0;
                object.OrderType = options.enums === String ? "Market" : 0;
                object.OrderState = options.enums === String ? "Submitted" : 0;
                object.AvgPrice = 0;
                object.SnapType = options.enums === String ? "Historical" : 1;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                object.Reason = "";
                object.FeedSymbol = "";
                object.Isin = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OcoLinkedGroupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OcoLinkedGroupId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OcoParentOrderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OcoParentOrderId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.PositionLinkId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.PositionLinkId = options.longs === String ? "0" : 0;
                object.IsGeneratedFromBracket = false;
                object.QuantityMode = options.enums === String ? "Fixed" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.InsertUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.InsertUtc = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ExeuctionUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ExeuctionUtc = options.longs === String ? "0" : 0;
                object.Ip = "";
                object.Source = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OrgClientSessionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OrgClientSessionId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.SeqClientSessionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.SeqClientSessionId = options.longs === String ? "0" : 0;
                object.IsValidationError = false;
            }
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.OrgServerId != null && message.hasOwnProperty("OrgServerId"))
                if (typeof message.OrgServerId === "number")
                    object.OrgServerId = options.longs === String ? String(message.OrgServerId) : message.OrgServerId;
                else
                    object.OrgServerId = options.longs === String ? $util.Long.prototype.toString.call(message.OrgServerId) : options.longs === Number ? new $util.LongBits(message.OrgServerId.low >>> 0, message.OrgServerId.high >>> 0).toNumber() : message.OrgServerId;
            if (message.OrgClientId != null && message.hasOwnProperty("OrgClientId"))
                object.OrgClientId = message.OrgClientId;
            if (message.SeqServerId != null && message.hasOwnProperty("SeqServerId"))
                if (typeof message.SeqServerId === "number")
                    object.SeqServerId = options.longs === String ? String(message.SeqServerId) : message.SeqServerId;
                else
                    object.SeqServerId = options.longs === String ? $util.Long.prototype.toString.call(message.SeqServerId) : options.longs === Number ? new $util.LongBits(message.SeqServerId.low >>> 0, message.SeqServerId.high >>> 0).toNumber() : message.SeqServerId;
            if (message.SeqClientId != null && message.hasOwnProperty("SeqClientId"))
                object.SeqClientId = message.SeqClientId;
            if (message.OrderPrice != null && message.hasOwnProperty("OrderPrice"))
                object.OrderPrice = options.json && !isFinite(message.OrderPrice) ? String(message.OrderPrice) : message.OrderPrice;
            if (message.OrderLimitPrice != null && message.hasOwnProperty("OrderLimitPrice"))
                object.OrderLimitPrice = options.json && !isFinite(message.OrderLimitPrice) ? String(message.OrderLimitPrice) : message.OrderLimitPrice;
            if (message.PendingQty != null && message.hasOwnProperty("PendingQty"))
                object.PendingQty = message.PendingQty;
            if (message.FilledQty != null && message.hasOwnProperty("FilledQty"))
                object.FilledQty = message.FilledQty;
            if (message.OrderType != null && message.hasOwnProperty("OrderType"))
                object.OrderType = options.enums === String ? $root.PropTradingProtocol.OrderTypeEnum[message.OrderType] === undefined ? message.OrderType : $root.PropTradingProtocol.OrderTypeEnum[message.OrderType] : message.OrderType;
            if (message.OrderState != null && message.hasOwnProperty("OrderState"))
                object.OrderState = options.enums === String ? $root.PropTradingProtocol.OrderInfoMsg.OrderStateEnum[message.OrderState] === undefined ? message.OrderState : $root.PropTradingProtocol.OrderInfoMsg.OrderStateEnum[message.OrderState] : message.OrderState;
            if (message.AvgPrice != null && message.hasOwnProperty("AvgPrice"))
                object.AvgPrice = options.json && !isFinite(message.AvgPrice) ? String(message.AvgPrice) : message.AvgPrice;
            if (message.SnapType != null && message.hasOwnProperty("SnapType"))
                object.SnapType = options.enums === String ? $root.PropTradingProtocol.OrderInfoMsg.SnapTypeEnum[message.SnapType] === undefined ? message.SnapType : $root.PropTradingProtocol.OrderInfoMsg.SnapTypeEnum[message.SnapType] : message.SnapType;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                object.Reason = message.Reason;
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                object.FeedSymbol = message.FeedSymbol;
            if (message.Isin != null && message.hasOwnProperty("Isin"))
                object.Isin = message.Isin;
            if (message.OcoLinkedGroupId != null && message.hasOwnProperty("OcoLinkedGroupId"))
                if (typeof message.OcoLinkedGroupId === "number")
                    object.OcoLinkedGroupId = options.longs === String ? String(message.OcoLinkedGroupId) : message.OcoLinkedGroupId;
                else
                    object.OcoLinkedGroupId = options.longs === String ? $util.Long.prototype.toString.call(message.OcoLinkedGroupId) : options.longs === Number ? new $util.LongBits(message.OcoLinkedGroupId.low >>> 0, message.OcoLinkedGroupId.high >>> 0).toNumber() : message.OcoLinkedGroupId;
            if (message.OcoLinkedOrderIds && message.OcoLinkedOrderIds.length) {
                object.OcoLinkedOrderIds = [];
                for (let j = 0; j < message.OcoLinkedOrderIds.length; ++j)
                    if (typeof message.OcoLinkedOrderIds[j] === "number")
                        object.OcoLinkedOrderIds[j] = options.longs === String ? String(message.OcoLinkedOrderIds[j]) : message.OcoLinkedOrderIds[j];
                    else
                        object.OcoLinkedOrderIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.OcoLinkedOrderIds[j]) : options.longs === Number ? new $util.LongBits(message.OcoLinkedOrderIds[j].low >>> 0, message.OcoLinkedOrderIds[j].high >>> 0).toNumber() : message.OcoLinkedOrderIds[j];
            }
            if (message.OcoParentOrderId != null && message.hasOwnProperty("OcoParentOrderId"))
                if (typeof message.OcoParentOrderId === "number")
                    object.OcoParentOrderId = options.longs === String ? String(message.OcoParentOrderId) : message.OcoParentOrderId;
                else
                    object.OcoParentOrderId = options.longs === String ? $util.Long.prototype.toString.call(message.OcoParentOrderId) : options.longs === Number ? new $util.LongBits(message.OcoParentOrderId.low >>> 0, message.OcoParentOrderId.high >>> 0).toNumber() : message.OcoParentOrderId;
            if (message.PositionLinkId != null && message.hasOwnProperty("PositionLinkId"))
                if (typeof message.PositionLinkId === "number")
                    object.PositionLinkId = options.longs === String ? String(message.PositionLinkId) : message.PositionLinkId;
                else
                    object.PositionLinkId = options.longs === String ? $util.Long.prototype.toString.call(message.PositionLinkId) : options.longs === Number ? new $util.LongBits(message.PositionLinkId.low >>> 0, message.PositionLinkId.high >>> 0).toNumber() : message.PositionLinkId;
            if (message.IsGeneratedFromBracket != null && message.hasOwnProperty("IsGeneratedFromBracket"))
                object.IsGeneratedFromBracket = message.IsGeneratedFromBracket;
            if (message.QuantityMode != null && message.hasOwnProperty("QuantityMode"))
                object.QuantityMode = options.enums === String ? $root.PropTradingProtocol.OrderQuantityModeEnum[message.QuantityMode] === undefined ? message.QuantityMode : $root.PropTradingProtocol.OrderQuantityModeEnum[message.QuantityMode] : message.QuantityMode;
            if (message.InsertUtc != null && message.hasOwnProperty("InsertUtc"))
                if (typeof message.InsertUtc === "number")
                    object.InsertUtc = options.longs === String ? String(message.InsertUtc) : message.InsertUtc;
                else
                    object.InsertUtc = options.longs === String ? $util.Long.prototype.toString.call(message.InsertUtc) : options.longs === Number ? new $util.LongBits(message.InsertUtc.low >>> 0, message.InsertUtc.high >>> 0).toNumber() : message.InsertUtc;
            if (message.ExeuctionUtc != null && message.hasOwnProperty("ExeuctionUtc"))
                if (typeof message.ExeuctionUtc === "number")
                    object.ExeuctionUtc = options.longs === String ? String(message.ExeuctionUtc) : message.ExeuctionUtc;
                else
                    object.ExeuctionUtc = options.longs === String ? $util.Long.prototype.toString.call(message.ExeuctionUtc) : options.longs === Number ? new $util.LongBits(message.ExeuctionUtc.low >>> 0, message.ExeuctionUtc.high >>> 0).toNumber() : message.ExeuctionUtc;
            if (message.Ip != null && message.hasOwnProperty("Ip"))
                object.Ip = message.Ip;
            if (message.Source != null && message.hasOwnProperty("Source"))
                object.Source = message.Source;
            if (message.OrgClientSessionId != null && message.hasOwnProperty("OrgClientSessionId"))
                if (typeof message.OrgClientSessionId === "number")
                    object.OrgClientSessionId = options.longs === String ? String(message.OrgClientSessionId) : message.OrgClientSessionId;
                else
                    object.OrgClientSessionId = options.longs === String ? $util.Long.prototype.toString.call(message.OrgClientSessionId) : options.longs === Number ? new $util.LongBits(message.OrgClientSessionId.low >>> 0, message.OrgClientSessionId.high >>> 0).toNumber() : message.OrgClientSessionId;
            if (message.SeqClientSessionId != null && message.hasOwnProperty("SeqClientSessionId"))
                if (typeof message.SeqClientSessionId === "number")
                    object.SeqClientSessionId = options.longs === String ? String(message.SeqClientSessionId) : message.SeqClientSessionId;
                else
                    object.SeqClientSessionId = options.longs === String ? $util.Long.prototype.toString.call(message.SeqClientSessionId) : options.longs === Number ? new $util.LongBits(message.SeqClientSessionId.low >>> 0, message.SeqClientSessionId.high >>> 0).toNumber() : message.SeqClientSessionId;
            if (message.IsValidationError != null && message.hasOwnProperty("IsValidationError"))
                object.IsValidationError = message.IsValidationError;
            return object;
        };

        /**
         * Converts this OrderInfoMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OrderInfoMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OrderInfoMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.OrderInfoMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OrderInfoMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.OrderInfoMsg";
        };

        /**
         * OrderStateEnum enum.
         * @name PropTradingProtocol.OrderInfoMsg.OrderStateEnum
         * @enum {number}
         * @property {number} Submitted=0 Submitted value
         * @property {number} Canceled=1 Canceled value
         * @property {number} Error=2 Error value
         * @property {number} ErrorModify=3 ErrorModify value
         */
        OrderInfoMsg.OrderStateEnum = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Submitted"] = 0;
            values[valuesById[1] = "Canceled"] = 1;
            values[valuesById[2] = "Error"] = 2;
            values[valuesById[3] = "ErrorModify"] = 3;
            return values;
        })();

        /**
         * SnapTypeEnum enum.
         * @name PropTradingProtocol.OrderInfoMsg.SnapTypeEnum
         * @enum {number}
         * @property {number} Historical=1 Historical value
         * @property {number} RealTime=2 RealTime value
         * @property {number} HistPos=3 HistPos value
         */
        OrderInfoMsg.SnapTypeEnum = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "Historical"] = 1;
            values[valuesById[2] = "RealTime"] = 2;
            values[valuesById[3] = "HistPos"] = 3;
            return values;
        })();

        return OrderInfoMsg;
    })();

    PropTradingProtocol.BracketInfoMsg = (function() {

        /**
         * Properties of a BracketInfoMsg.
         * @memberof PropTradingProtocol
         * @interface IBracketInfoMsg
         * @property {number|Long|null} [ContractId] BracketInfoMsg ContractId
         * @property {number|Long|null} [ParentOrderId] BracketInfoMsg ParentOrderId
         * @property {number|Long|null} [OcoGroupId] BracketInfoMsg OcoGroupId
         * @property {number|Long|null} [BracketId] BracketInfoMsg BracketId
         * @property {number|null} [SeqClientId] BracketInfoMsg SeqClientId
         * @property {number|null} [Price] BracketInfoMsg Price
         * @property {number|null} [Ticks] BracketInfoMsg Ticks
         * @property {number|null} [CalculatedPrice] BracketInfoMsg CalculatedPrice
         * @property {number|null} [TotalQty] BracketInfoMsg TotalQty
         * @property {number|null} [ReleasedQty] BracketInfoMsg ReleasedQty
         * @property {boolean|null} [IsTarget] BracketInfoMsg IsTarget
         * @property {PropTradingProtocol.BracketInfoMsg.BracketStateEnum|null} [BracketState] BracketInfoMsg BracketState
         * @property {PropTradingProtocol.BracketInfoMsg.SnapTypeEnum|null} [SnapType] BracketInfoMsg SnapType
         * @property {number|Long|null} [AccNumber] BracketInfoMsg AccNumber
         * @property {string|null} [Reason] BracketInfoMsg Reason
         * @property {string|null} [FeedSymbol] BracketInfoMsg FeedSymbol
         * @property {string|null} [Isin] BracketInfoMsg Isin
         * @property {number|Long|null} [ClientSessionId] RESERVED FIELDS*************************
         * @property {boolean|null} [IsValidationError] BracketInfoMsg IsValidationError
         */

        /**
         * Constructs a new BracketInfoMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a BracketInfoMsg.
         * @implements IBracketInfoMsg
         * @constructor
         * @param {PropTradingProtocol.IBracketInfoMsg=} [properties] Properties to set
         */
        function BracketInfoMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BracketInfoMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketInfoMsg ParentOrderId.
         * @member {number|Long} ParentOrderId
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.ParentOrderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketInfoMsg OcoGroupId.
         * @member {number|Long} OcoGroupId
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.OcoGroupId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketInfoMsg BracketId.
         * @member {number|Long} BracketId
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.BracketId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketInfoMsg SeqClientId.
         * @member {number} SeqClientId
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.SeqClientId = 0;

        /**
         * BracketInfoMsg Price.
         * @member {number} Price
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.Price = 0;

        /**
         * BracketInfoMsg Ticks.
         * @member {number} Ticks
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.Ticks = 0;

        /**
         * BracketInfoMsg CalculatedPrice.
         * @member {number} CalculatedPrice
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.CalculatedPrice = 0;

        /**
         * BracketInfoMsg TotalQty.
         * @member {number} TotalQty
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.TotalQty = 0;

        /**
         * BracketInfoMsg ReleasedQty.
         * @member {number} ReleasedQty
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.ReleasedQty = 0;

        /**
         * BracketInfoMsg IsTarget.
         * @member {boolean} IsTarget
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.IsTarget = false;

        /**
         * BracketInfoMsg BracketState.
         * @member {PropTradingProtocol.BracketInfoMsg.BracketStateEnum} BracketState
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.BracketState = 0;

        /**
         * BracketInfoMsg SnapType.
         * @member {PropTradingProtocol.BracketInfoMsg.SnapTypeEnum} SnapType
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.SnapType = 1;

        /**
         * BracketInfoMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketInfoMsg Reason.
         * @member {string} Reason
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.Reason = "";

        /**
         * BracketInfoMsg FeedSymbol.
         * @member {string} FeedSymbol
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.FeedSymbol = "";

        /**
         * BracketInfoMsg Isin.
         * @member {string} Isin
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.Isin = "";

        /**
         * RESERVED FIELDS*************************
         * @member {number|Long} ClientSessionId
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.ClientSessionId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketInfoMsg IsValidationError.
         * @member {boolean} IsValidationError
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         */
        BracketInfoMsg.prototype.IsValidationError = false;

        /**
         * Creates a new BracketInfoMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @static
         * @param {PropTradingProtocol.IBracketInfoMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.BracketInfoMsg} BracketInfoMsg instance
         */
        BracketInfoMsg.create = function create(properties) {
            return new BracketInfoMsg(properties);
        };

        /**
         * Encodes the specified BracketInfoMsg message. Does not implicitly {@link PropTradingProtocol.BracketInfoMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @static
         * @param {PropTradingProtocol.IBracketInfoMsg} message BracketInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketInfoMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.ContractId);
            if (message.ParentOrderId != null && Object.hasOwnProperty.call(message, "ParentOrderId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.ParentOrderId);
            if (message.OcoGroupId != null && Object.hasOwnProperty.call(message, "OcoGroupId"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint64(message.OcoGroupId);
            if (message.BracketId != null && Object.hasOwnProperty.call(message, "BracketId"))
                writer.uint32(/* id 4, wireType 0 =*/32).sint64(message.BracketId);
            if (message.SeqClientId != null && Object.hasOwnProperty.call(message, "SeqClientId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.SeqClientId);
            if (message.Price != null && Object.hasOwnProperty.call(message, "Price"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.Price);
            if (message.Ticks != null && Object.hasOwnProperty.call(message, "Ticks"))
                writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.Ticks);
            if (message.CalculatedPrice != null && Object.hasOwnProperty.call(message, "CalculatedPrice"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.CalculatedPrice);
            if (message.TotalQty != null && Object.hasOwnProperty.call(message, "TotalQty"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.TotalQty);
            if (message.ReleasedQty != null && Object.hasOwnProperty.call(message, "ReleasedQty"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.ReleasedQty);
            if (message.IsTarget != null && Object.hasOwnProperty.call(message, "IsTarget"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.IsTarget);
            if (message.BracketState != null && Object.hasOwnProperty.call(message, "BracketState"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.BracketState);
            if (message.SnapType != null && Object.hasOwnProperty.call(message, "SnapType"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.SnapType);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 14, wireType 0 =*/112).sint64(message.AccNumber);
            if (message.Reason != null && Object.hasOwnProperty.call(message, "Reason"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.Reason);
            if (message.FeedSymbol != null && Object.hasOwnProperty.call(message, "FeedSymbol"))
                writer.uint32(/* id 16, wireType 2 =*/130).string(message.FeedSymbol);
            if (message.Isin != null && Object.hasOwnProperty.call(message, "Isin"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.Isin);
            if (message.ClientSessionId != null && Object.hasOwnProperty.call(message, "ClientSessionId"))
                writer.uint32(/* id 101, wireType 0 =*/808).sint64(message.ClientSessionId);
            if (message.IsValidationError != null && Object.hasOwnProperty.call(message, "IsValidationError"))
                writer.uint32(/* id 102, wireType 0 =*/816).bool(message.IsValidationError);
            return writer;
        };

        /**
         * Encodes the specified BracketInfoMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.BracketInfoMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @static
         * @param {PropTradingProtocol.IBracketInfoMsg} message BracketInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketInfoMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BracketInfoMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.BracketInfoMsg} BracketInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketInfoMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.BracketInfoMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.ParentOrderId = reader.sint64();
                        break;
                    }
                case 3: {
                        message.OcoGroupId = reader.sint64();
                        break;
                    }
                case 4: {
                        message.BracketId = reader.sint64();
                        break;
                    }
                case 5: {
                        message.SeqClientId = reader.int32();
                        break;
                    }
                case 6: {
                        message.Price = reader.double();
                        break;
                    }
                case 7: {
                        message.Ticks = reader.sint32();
                        break;
                    }
                case 8: {
                        message.CalculatedPrice = reader.double();
                        break;
                    }
                case 9: {
                        message.TotalQty = reader.int32();
                        break;
                    }
                case 10: {
                        message.ReleasedQty = reader.int32();
                        break;
                    }
                case 11: {
                        message.IsTarget = reader.bool();
                        break;
                    }
                case 12: {
                        message.BracketState = reader.int32();
                        break;
                    }
                case 13: {
                        message.SnapType = reader.int32();
                        break;
                    }
                case 14: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 15: {
                        message.Reason = reader.string();
                        break;
                    }
                case 16: {
                        message.FeedSymbol = reader.string();
                        break;
                    }
                case 17: {
                        message.Isin = reader.string();
                        break;
                    }
                case 101: {
                        message.ClientSessionId = reader.sint64();
                        break;
                    }
                case 102: {
                        message.IsValidationError = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BracketInfoMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.BracketInfoMsg} BracketInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketInfoMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BracketInfoMsg message.
         * @function verify
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BracketInfoMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.ParentOrderId != null && message.hasOwnProperty("ParentOrderId"))
                if (!$util.isInteger(message.ParentOrderId) && !(message.ParentOrderId && $util.isInteger(message.ParentOrderId.low) && $util.isInteger(message.ParentOrderId.high)))
                    return "ParentOrderId: integer|Long expected";
            if (message.OcoGroupId != null && message.hasOwnProperty("OcoGroupId"))
                if (!$util.isInteger(message.OcoGroupId) && !(message.OcoGroupId && $util.isInteger(message.OcoGroupId.low) && $util.isInteger(message.OcoGroupId.high)))
                    return "OcoGroupId: integer|Long expected";
            if (message.BracketId != null && message.hasOwnProperty("BracketId"))
                if (!$util.isInteger(message.BracketId) && !(message.BracketId && $util.isInteger(message.BracketId.low) && $util.isInteger(message.BracketId.high)))
                    return "BracketId: integer|Long expected";
            if (message.SeqClientId != null && message.hasOwnProperty("SeqClientId"))
                if (!$util.isInteger(message.SeqClientId))
                    return "SeqClientId: integer expected";
            if (message.Price != null && message.hasOwnProperty("Price"))
                if (typeof message.Price !== "number")
                    return "Price: number expected";
            if (message.Ticks != null && message.hasOwnProperty("Ticks"))
                if (!$util.isInteger(message.Ticks))
                    return "Ticks: integer expected";
            if (message.CalculatedPrice != null && message.hasOwnProperty("CalculatedPrice"))
                if (typeof message.CalculatedPrice !== "number")
                    return "CalculatedPrice: number expected";
            if (message.TotalQty != null && message.hasOwnProperty("TotalQty"))
                if (!$util.isInteger(message.TotalQty))
                    return "TotalQty: integer expected";
            if (message.ReleasedQty != null && message.hasOwnProperty("ReleasedQty"))
                if (!$util.isInteger(message.ReleasedQty))
                    return "ReleasedQty: integer expected";
            if (message.IsTarget != null && message.hasOwnProperty("IsTarget"))
                if (typeof message.IsTarget !== "boolean")
                    return "IsTarget: boolean expected";
            if (message.BracketState != null && message.hasOwnProperty("BracketState"))
                switch (message.BracketState) {
                default:
                    return "BracketState: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.SnapType != null && message.hasOwnProperty("SnapType"))
                switch (message.SnapType) {
                default:
                    return "SnapType: enum value expected";
                case 1:
                case 2:
                    break;
                }
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                if (!$util.isString(message.Reason))
                    return "Reason: string expected";
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                if (!$util.isString(message.FeedSymbol))
                    return "FeedSymbol: string expected";
            if (message.Isin != null && message.hasOwnProperty("Isin"))
                if (!$util.isString(message.Isin))
                    return "Isin: string expected";
            if (message.ClientSessionId != null && message.hasOwnProperty("ClientSessionId"))
                if (!$util.isInteger(message.ClientSessionId) && !(message.ClientSessionId && $util.isInteger(message.ClientSessionId.low) && $util.isInteger(message.ClientSessionId.high)))
                    return "ClientSessionId: integer|Long expected";
            if (message.IsValidationError != null && message.hasOwnProperty("IsValidationError"))
                if (typeof message.IsValidationError !== "boolean")
                    return "IsValidationError: boolean expected";
            return null;
        };

        /**
         * Creates a BracketInfoMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.BracketInfoMsg} BracketInfoMsg
         */
        BracketInfoMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.BracketInfoMsg)
                return object;
            let message = new $root.PropTradingProtocol.BracketInfoMsg();
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.ParentOrderId != null)
                if ($util.Long)
                    (message.ParentOrderId = $util.Long.fromValue(object.ParentOrderId)).unsigned = false;
                else if (typeof object.ParentOrderId === "string")
                    message.ParentOrderId = parseInt(object.ParentOrderId, 10);
                else if (typeof object.ParentOrderId === "number")
                    message.ParentOrderId = object.ParentOrderId;
                else if (typeof object.ParentOrderId === "object")
                    message.ParentOrderId = new $util.LongBits(object.ParentOrderId.low >>> 0, object.ParentOrderId.high >>> 0).toNumber();
            if (object.OcoGroupId != null)
                if ($util.Long)
                    (message.OcoGroupId = $util.Long.fromValue(object.OcoGroupId)).unsigned = false;
                else if (typeof object.OcoGroupId === "string")
                    message.OcoGroupId = parseInt(object.OcoGroupId, 10);
                else if (typeof object.OcoGroupId === "number")
                    message.OcoGroupId = object.OcoGroupId;
                else if (typeof object.OcoGroupId === "object")
                    message.OcoGroupId = new $util.LongBits(object.OcoGroupId.low >>> 0, object.OcoGroupId.high >>> 0).toNumber();
            if (object.BracketId != null)
                if ($util.Long)
                    (message.BracketId = $util.Long.fromValue(object.BracketId)).unsigned = false;
                else if (typeof object.BracketId === "string")
                    message.BracketId = parseInt(object.BracketId, 10);
                else if (typeof object.BracketId === "number")
                    message.BracketId = object.BracketId;
                else if (typeof object.BracketId === "object")
                    message.BracketId = new $util.LongBits(object.BracketId.low >>> 0, object.BracketId.high >>> 0).toNumber();
            if (object.SeqClientId != null)
                message.SeqClientId = object.SeqClientId | 0;
            if (object.Price != null)
                message.Price = Number(object.Price);
            if (object.Ticks != null)
                message.Ticks = object.Ticks | 0;
            if (object.CalculatedPrice != null)
                message.CalculatedPrice = Number(object.CalculatedPrice);
            if (object.TotalQty != null)
                message.TotalQty = object.TotalQty | 0;
            if (object.ReleasedQty != null)
                message.ReleasedQty = object.ReleasedQty | 0;
            if (object.IsTarget != null)
                message.IsTarget = Boolean(object.IsTarget);
            switch (object.BracketState) {
            default:
                if (typeof object.BracketState === "number") {
                    message.BracketState = object.BracketState;
                    break;
                }
                break;
            case "Waiting":
            case 0:
                message.BracketState = 0;
                break;
            case "Submitted":
            case 1:
                message.BracketState = 1;
                break;
            case "Cancelled":
            case 2:
                message.BracketState = 2;
                break;
            case "Error":
            case 3:
                message.BracketState = 3;
                break;
            }
            switch (object.SnapType) {
            default:
                if (typeof object.SnapType === "number") {
                    message.SnapType = object.SnapType;
                    break;
                }
                break;
            case "Historical":
            case 1:
                message.SnapType = 1;
                break;
            case "RealTime":
            case 2:
                message.SnapType = 2;
                break;
            }
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            if (object.Reason != null)
                message.Reason = String(object.Reason);
            if (object.FeedSymbol != null)
                message.FeedSymbol = String(object.FeedSymbol);
            if (object.Isin != null)
                message.Isin = String(object.Isin);
            if (object.ClientSessionId != null)
                if ($util.Long)
                    (message.ClientSessionId = $util.Long.fromValue(object.ClientSessionId)).unsigned = false;
                else if (typeof object.ClientSessionId === "string")
                    message.ClientSessionId = parseInt(object.ClientSessionId, 10);
                else if (typeof object.ClientSessionId === "number")
                    message.ClientSessionId = object.ClientSessionId;
                else if (typeof object.ClientSessionId === "object")
                    message.ClientSessionId = new $util.LongBits(object.ClientSessionId.low >>> 0, object.ClientSessionId.high >>> 0).toNumber();
            if (object.IsValidationError != null)
                message.IsValidationError = Boolean(object.IsValidationError);
            return message;
        };

        /**
         * Creates a plain object from a BracketInfoMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @static
         * @param {PropTradingProtocol.BracketInfoMsg} message BracketInfoMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BracketInfoMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ParentOrderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ParentOrderId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OcoGroupId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OcoGroupId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.BracketId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.BracketId = options.longs === String ? "0" : 0;
                object.SeqClientId = 0;
                object.Price = 0;
                object.Ticks = 0;
                object.CalculatedPrice = 0;
                object.TotalQty = 0;
                object.ReleasedQty = 0;
                object.IsTarget = false;
                object.BracketState = options.enums === String ? "Waiting" : 0;
                object.SnapType = options.enums === String ? "Historical" : 1;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                object.Reason = "";
                object.FeedSymbol = "";
                object.Isin = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ClientSessionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ClientSessionId = options.longs === String ? "0" : 0;
                object.IsValidationError = false;
            }
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.ParentOrderId != null && message.hasOwnProperty("ParentOrderId"))
                if (typeof message.ParentOrderId === "number")
                    object.ParentOrderId = options.longs === String ? String(message.ParentOrderId) : message.ParentOrderId;
                else
                    object.ParentOrderId = options.longs === String ? $util.Long.prototype.toString.call(message.ParentOrderId) : options.longs === Number ? new $util.LongBits(message.ParentOrderId.low >>> 0, message.ParentOrderId.high >>> 0).toNumber() : message.ParentOrderId;
            if (message.OcoGroupId != null && message.hasOwnProperty("OcoGroupId"))
                if (typeof message.OcoGroupId === "number")
                    object.OcoGroupId = options.longs === String ? String(message.OcoGroupId) : message.OcoGroupId;
                else
                    object.OcoGroupId = options.longs === String ? $util.Long.prototype.toString.call(message.OcoGroupId) : options.longs === Number ? new $util.LongBits(message.OcoGroupId.low >>> 0, message.OcoGroupId.high >>> 0).toNumber() : message.OcoGroupId;
            if (message.BracketId != null && message.hasOwnProperty("BracketId"))
                if (typeof message.BracketId === "number")
                    object.BracketId = options.longs === String ? String(message.BracketId) : message.BracketId;
                else
                    object.BracketId = options.longs === String ? $util.Long.prototype.toString.call(message.BracketId) : options.longs === Number ? new $util.LongBits(message.BracketId.low >>> 0, message.BracketId.high >>> 0).toNumber() : message.BracketId;
            if (message.SeqClientId != null && message.hasOwnProperty("SeqClientId"))
                object.SeqClientId = message.SeqClientId;
            if (message.Price != null && message.hasOwnProperty("Price"))
                object.Price = options.json && !isFinite(message.Price) ? String(message.Price) : message.Price;
            if (message.Ticks != null && message.hasOwnProperty("Ticks"))
                object.Ticks = message.Ticks;
            if (message.CalculatedPrice != null && message.hasOwnProperty("CalculatedPrice"))
                object.CalculatedPrice = options.json && !isFinite(message.CalculatedPrice) ? String(message.CalculatedPrice) : message.CalculatedPrice;
            if (message.TotalQty != null && message.hasOwnProperty("TotalQty"))
                object.TotalQty = message.TotalQty;
            if (message.ReleasedQty != null && message.hasOwnProperty("ReleasedQty"))
                object.ReleasedQty = message.ReleasedQty;
            if (message.IsTarget != null && message.hasOwnProperty("IsTarget"))
                object.IsTarget = message.IsTarget;
            if (message.BracketState != null && message.hasOwnProperty("BracketState"))
                object.BracketState = options.enums === String ? $root.PropTradingProtocol.BracketInfoMsg.BracketStateEnum[message.BracketState] === undefined ? message.BracketState : $root.PropTradingProtocol.BracketInfoMsg.BracketStateEnum[message.BracketState] : message.BracketState;
            if (message.SnapType != null && message.hasOwnProperty("SnapType"))
                object.SnapType = options.enums === String ? $root.PropTradingProtocol.BracketInfoMsg.SnapTypeEnum[message.SnapType] === undefined ? message.SnapType : $root.PropTradingProtocol.BracketInfoMsg.SnapTypeEnum[message.SnapType] : message.SnapType;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                object.Reason = message.Reason;
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                object.FeedSymbol = message.FeedSymbol;
            if (message.Isin != null && message.hasOwnProperty("Isin"))
                object.Isin = message.Isin;
            if (message.ClientSessionId != null && message.hasOwnProperty("ClientSessionId"))
                if (typeof message.ClientSessionId === "number")
                    object.ClientSessionId = options.longs === String ? String(message.ClientSessionId) : message.ClientSessionId;
                else
                    object.ClientSessionId = options.longs === String ? $util.Long.prototype.toString.call(message.ClientSessionId) : options.longs === Number ? new $util.LongBits(message.ClientSessionId.low >>> 0, message.ClientSessionId.high >>> 0).toNumber() : message.ClientSessionId;
            if (message.IsValidationError != null && message.hasOwnProperty("IsValidationError"))
                object.IsValidationError = message.IsValidationError;
            return object;
        };

        /**
         * Converts this BracketInfoMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BracketInfoMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BracketInfoMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.BracketInfoMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BracketInfoMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.BracketInfoMsg";
        };

        /**
         * BracketStateEnum enum.
         * @name PropTradingProtocol.BracketInfoMsg.BracketStateEnum
         * @enum {number}
         * @property {number} Waiting=0 Waiting value
         * @property {number} Submitted=1 Submitted value
         * @property {number} Cancelled=2 Cancelled value
         * @property {number} Error=3 Error value
         */
        BracketInfoMsg.BracketStateEnum = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Waiting"] = 0;
            values[valuesById[1] = "Submitted"] = 1;
            values[valuesById[2] = "Cancelled"] = 2;
            values[valuesById[3] = "Error"] = 3;
            return values;
        })();

        /**
         * SnapTypeEnum enum.
         * @name PropTradingProtocol.BracketInfoMsg.SnapTypeEnum
         * @enum {number}
         * @property {number} Historical=1 Historical value
         * @property {number} RealTime=2 RealTime value
         */
        BracketInfoMsg.SnapTypeEnum = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "Historical"] = 1;
            values[valuesById[2] = "RealTime"] = 2;
            return values;
        })();

        return BracketInfoMsg;
    })();

    PropTradingProtocol.LogInfoMsg = (function() {

        /**
         * Properties of a LogInfoMsg.
         * @memberof PropTradingProtocol
         * @interface ILogInfoMsg
         * @property {string|null} [Msg] LogInfoMsg Msg
         * @property {number|Long|null} [AccNumber] LogInfoMsg AccNumber
         */

        /**
         * Constructs a new LogInfoMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a LogInfoMsg.
         * @implements ILogInfoMsg
         * @constructor
         * @param {PropTradingProtocol.ILogInfoMsg=} [properties] Properties to set
         */
        function LogInfoMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LogInfoMsg Msg.
         * @member {string} Msg
         * @memberof PropTradingProtocol.LogInfoMsg
         * @instance
         */
        LogInfoMsg.prototype.Msg = "";

        /**
         * LogInfoMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.LogInfoMsg
         * @instance
         */
        LogInfoMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new LogInfoMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.LogInfoMsg
         * @static
         * @param {PropTradingProtocol.ILogInfoMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.LogInfoMsg} LogInfoMsg instance
         */
        LogInfoMsg.create = function create(properties) {
            return new LogInfoMsg(properties);
        };

        /**
         * Encodes the specified LogInfoMsg message. Does not implicitly {@link PropTradingProtocol.LogInfoMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.LogInfoMsg
         * @static
         * @param {PropTradingProtocol.ILogInfoMsg} message LogInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogInfoMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Msg != null && Object.hasOwnProperty.call(message, "Msg"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Msg);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccNumber);
            return writer;
        };

        /**
         * Encodes the specified LogInfoMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.LogInfoMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.LogInfoMsg
         * @static
         * @param {PropTradingProtocol.ILogInfoMsg} message LogInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LogInfoMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LogInfoMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.LogInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.LogInfoMsg} LogInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogInfoMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.LogInfoMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.Msg = reader.string();
                        break;
                    }
                case 2: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LogInfoMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.LogInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.LogInfoMsg} LogInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LogInfoMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LogInfoMsg message.
         * @function verify
         * @memberof PropTradingProtocol.LogInfoMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LogInfoMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                if (!$util.isString(message.Msg))
                    return "Msg: string expected";
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            return null;
        };

        /**
         * Creates a LogInfoMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.LogInfoMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.LogInfoMsg} LogInfoMsg
         */
        LogInfoMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.LogInfoMsg)
                return object;
            let message = new $root.PropTradingProtocol.LogInfoMsg();
            if (object.Msg != null)
                message.Msg = String(object.Msg);
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a LogInfoMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.LogInfoMsg
         * @static
         * @param {PropTradingProtocol.LogInfoMsg} message LogInfoMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LogInfoMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.Msg = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
            }
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                object.Msg = message.Msg;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            return object;
        };

        /**
         * Converts this LogInfoMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.LogInfoMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LogInfoMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LogInfoMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.LogInfoMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LogInfoMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.LogInfoMsg";
        };

        return LogInfoMsg;
    })();

    PropTradingProtocol.PositionInfoMsg = (function() {

        /**
         * Properties of a PositionInfoMsg.
         * @memberof PropTradingProtocol
         * @interface IPositionInfoMsg
         * @property {number|Long|null} [ContractId] PositionInfoMsg ContractId
         * @property {number|Long|null} [OpenQuantity] PositionInfoMsg OpenQuantity
         * @property {number|null} [OpenPrice] PositionInfoMsg OpenPrice
         * @property {number|null} [MarginUsed] PositionInfoMsg MarginUsed
         * @property {number|Long|null} [DailyBought] PositionInfoMsg DailyBought
         * @property {number|Long|null} [DailySold] PositionInfoMsg DailySold
         * @property {number|null} [DailyPl] PositionInfoMsg DailyPl
         * @property {boolean|null} [HasOpenPl] PositionInfoMsg HasOpenPl
         * @property {number|null} [OpenPl] PositionInfoMsg OpenPl
         * @property {number|null} [DailyCommissions] PositionInfoMsg DailyCommissions
         * @property {PropTradingProtocol.PositionInfoMsg.SnapTypeEnum|null} [SnapType] PositionInfoMsg SnapType
         * @property {number|Long|null} [AccNumber] PositionInfoMsg AccNumber
         * @property {string|null} [FeedSymbol] PositionInfoMsg FeedSymbol
         * @property {string|null} [Isin] PositionInfoMsg Isin
         * @property {number|Long|null} [PositionId] PositionInfoMsg PositionId
         * @property {number|Long|null} [Utc] PositionInfoMsg Utc
         * @property {number|null} [ConvertedDailyPl] PositionInfoMsg ConvertedDailyPl
         * @property {number|null} [ConvertedDailyCommissions] PositionInfoMsg ConvertedDailyCommissions
         * @property {number|null} [ConvertedOpenPl] PositionInfoMsg ConvertedOpenPl
         * @property {number|Long|null} [EntryOrderId] PositionInfoMsg EntryOrderId
         */

        /**
         * Constructs a new PositionInfoMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a PositionInfoMsg.
         * @implements IPositionInfoMsg
         * @constructor
         * @param {PropTradingProtocol.IPositionInfoMsg=} [properties] Properties to set
         */
        function PositionInfoMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PositionInfoMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PositionInfoMsg OpenQuantity.
         * @member {number|Long} OpenQuantity
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.OpenQuantity = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PositionInfoMsg OpenPrice.
         * @member {number} OpenPrice
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.OpenPrice = 0;

        /**
         * PositionInfoMsg MarginUsed.
         * @member {number} MarginUsed
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.MarginUsed = 0;

        /**
         * PositionInfoMsg DailyBought.
         * @member {number|Long} DailyBought
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.DailyBought = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PositionInfoMsg DailySold.
         * @member {number|Long} DailySold
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.DailySold = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PositionInfoMsg DailyPl.
         * @member {number} DailyPl
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.DailyPl = 0;

        /**
         * PositionInfoMsg HasOpenPl.
         * @member {boolean} HasOpenPl
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.HasOpenPl = false;

        /**
         * PositionInfoMsg OpenPl.
         * @member {number} OpenPl
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.OpenPl = 0;

        /**
         * PositionInfoMsg DailyCommissions.
         * @member {number} DailyCommissions
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.DailyCommissions = 0;

        /**
         * PositionInfoMsg SnapType.
         * @member {PropTradingProtocol.PositionInfoMsg.SnapTypeEnum} SnapType
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.SnapType = 1;

        /**
         * PositionInfoMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PositionInfoMsg FeedSymbol.
         * @member {string} FeedSymbol
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.FeedSymbol = "";

        /**
         * PositionInfoMsg Isin.
         * @member {string} Isin
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.Isin = "";

        /**
         * PositionInfoMsg PositionId.
         * @member {number|Long} PositionId
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.PositionId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PositionInfoMsg Utc.
         * @member {number|Long} Utc
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.Utc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * PositionInfoMsg ConvertedDailyPl.
         * @member {number} ConvertedDailyPl
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.ConvertedDailyPl = 0;

        /**
         * PositionInfoMsg ConvertedDailyCommissions.
         * @member {number} ConvertedDailyCommissions
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.ConvertedDailyCommissions = 0;

        /**
         * PositionInfoMsg ConvertedOpenPl.
         * @member {number} ConvertedOpenPl
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.ConvertedOpenPl = 0;

        /**
         * PositionInfoMsg EntryOrderId.
         * @member {number|Long} EntryOrderId
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         */
        PositionInfoMsg.prototype.EntryOrderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new PositionInfoMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @static
         * @param {PropTradingProtocol.IPositionInfoMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.PositionInfoMsg} PositionInfoMsg instance
         */
        PositionInfoMsg.create = function create(properties) {
            return new PositionInfoMsg(properties);
        };

        /**
         * Encodes the specified PositionInfoMsg message. Does not implicitly {@link PropTradingProtocol.PositionInfoMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @static
         * @param {PropTradingProtocol.IPositionInfoMsg} message PositionInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionInfoMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.ContractId);
            if (message.OpenQuantity != null && Object.hasOwnProperty.call(message, "OpenQuantity"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.OpenQuantity);
            if (message.OpenPrice != null && Object.hasOwnProperty.call(message, "OpenPrice"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.OpenPrice);
            if (message.MarginUsed != null && Object.hasOwnProperty.call(message, "MarginUsed"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.MarginUsed);
            if (message.DailyBought != null && Object.hasOwnProperty.call(message, "DailyBought"))
                writer.uint32(/* id 5, wireType 0 =*/40).sint64(message.DailyBought);
            if (message.DailySold != null && Object.hasOwnProperty.call(message, "DailySold"))
                writer.uint32(/* id 6, wireType 0 =*/48).sint64(message.DailySold);
            if (message.DailyPl != null && Object.hasOwnProperty.call(message, "DailyPl"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.DailyPl);
            if (message.HasOpenPl != null && Object.hasOwnProperty.call(message, "HasOpenPl"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.HasOpenPl);
            if (message.OpenPl != null && Object.hasOwnProperty.call(message, "OpenPl"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.OpenPl);
            if (message.DailyCommissions != null && Object.hasOwnProperty.call(message, "DailyCommissions"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.DailyCommissions);
            if (message.SnapType != null && Object.hasOwnProperty.call(message, "SnapType"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.SnapType);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 12, wireType 0 =*/96).sint64(message.AccNumber);
            if (message.FeedSymbol != null && Object.hasOwnProperty.call(message, "FeedSymbol"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.FeedSymbol);
            if (message.Isin != null && Object.hasOwnProperty.call(message, "Isin"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.Isin);
            if (message.PositionId != null && Object.hasOwnProperty.call(message, "PositionId"))
                writer.uint32(/* id 15, wireType 0 =*/120).sint64(message.PositionId);
            if (message.Utc != null && Object.hasOwnProperty.call(message, "Utc"))
                writer.uint32(/* id 16, wireType 0 =*/128).sint64(message.Utc);
            if (message.ConvertedDailyPl != null && Object.hasOwnProperty.call(message, "ConvertedDailyPl"))
                writer.uint32(/* id 17, wireType 1 =*/137).double(message.ConvertedDailyPl);
            if (message.ConvertedDailyCommissions != null && Object.hasOwnProperty.call(message, "ConvertedDailyCommissions"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.ConvertedDailyCommissions);
            if (message.ConvertedOpenPl != null && Object.hasOwnProperty.call(message, "ConvertedOpenPl"))
                writer.uint32(/* id 19, wireType 1 =*/153).double(message.ConvertedOpenPl);
            if (message.EntryOrderId != null && Object.hasOwnProperty.call(message, "EntryOrderId"))
                writer.uint32(/* id 20, wireType 0 =*/160).sint64(message.EntryOrderId);
            return writer;
        };

        /**
         * Encodes the specified PositionInfoMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.PositionInfoMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @static
         * @param {PropTradingProtocol.IPositionInfoMsg} message PositionInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PositionInfoMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PositionInfoMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.PositionInfoMsg} PositionInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionInfoMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.PositionInfoMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.OpenQuantity = reader.sint64();
                        break;
                    }
                case 3: {
                        message.OpenPrice = reader.double();
                        break;
                    }
                case 4: {
                        message.MarginUsed = reader.double();
                        break;
                    }
                case 5: {
                        message.DailyBought = reader.sint64();
                        break;
                    }
                case 6: {
                        message.DailySold = reader.sint64();
                        break;
                    }
                case 7: {
                        message.DailyPl = reader.double();
                        break;
                    }
                case 8: {
                        message.HasOpenPl = reader.bool();
                        break;
                    }
                case 9: {
                        message.OpenPl = reader.double();
                        break;
                    }
                case 10: {
                        message.DailyCommissions = reader.double();
                        break;
                    }
                case 11: {
                        message.SnapType = reader.int32();
                        break;
                    }
                case 12: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 13: {
                        message.FeedSymbol = reader.string();
                        break;
                    }
                case 14: {
                        message.Isin = reader.string();
                        break;
                    }
                case 15: {
                        message.PositionId = reader.sint64();
                        break;
                    }
                case 16: {
                        message.Utc = reader.sint64();
                        break;
                    }
                case 17: {
                        message.ConvertedDailyPl = reader.double();
                        break;
                    }
                case 18: {
                        message.ConvertedDailyCommissions = reader.double();
                        break;
                    }
                case 19: {
                        message.ConvertedOpenPl = reader.double();
                        break;
                    }
                case 20: {
                        message.EntryOrderId = reader.sint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PositionInfoMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.PositionInfoMsg} PositionInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PositionInfoMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PositionInfoMsg message.
         * @function verify
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PositionInfoMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.OpenQuantity != null && message.hasOwnProperty("OpenQuantity"))
                if (!$util.isInteger(message.OpenQuantity) && !(message.OpenQuantity && $util.isInteger(message.OpenQuantity.low) && $util.isInteger(message.OpenQuantity.high)))
                    return "OpenQuantity: integer|Long expected";
            if (message.OpenPrice != null && message.hasOwnProperty("OpenPrice"))
                if (typeof message.OpenPrice !== "number")
                    return "OpenPrice: number expected";
            if (message.MarginUsed != null && message.hasOwnProperty("MarginUsed"))
                if (typeof message.MarginUsed !== "number")
                    return "MarginUsed: number expected";
            if (message.DailyBought != null && message.hasOwnProperty("DailyBought"))
                if (!$util.isInteger(message.DailyBought) && !(message.DailyBought && $util.isInteger(message.DailyBought.low) && $util.isInteger(message.DailyBought.high)))
                    return "DailyBought: integer|Long expected";
            if (message.DailySold != null && message.hasOwnProperty("DailySold"))
                if (!$util.isInteger(message.DailySold) && !(message.DailySold && $util.isInteger(message.DailySold.low) && $util.isInteger(message.DailySold.high)))
                    return "DailySold: integer|Long expected";
            if (message.DailyPl != null && message.hasOwnProperty("DailyPl"))
                if (typeof message.DailyPl !== "number")
                    return "DailyPl: number expected";
            if (message.HasOpenPl != null && message.hasOwnProperty("HasOpenPl"))
                if (typeof message.HasOpenPl !== "boolean")
                    return "HasOpenPl: boolean expected";
            if (message.OpenPl != null && message.hasOwnProperty("OpenPl"))
                if (typeof message.OpenPl !== "number")
                    return "OpenPl: number expected";
            if (message.DailyCommissions != null && message.hasOwnProperty("DailyCommissions"))
                if (typeof message.DailyCommissions !== "number")
                    return "DailyCommissions: number expected";
            if (message.SnapType != null && message.hasOwnProperty("SnapType"))
                switch (message.SnapType) {
                default:
                    return "SnapType: enum value expected";
                case 1:
                case 2:
                    break;
                }
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                if (!$util.isString(message.FeedSymbol))
                    return "FeedSymbol: string expected";
            if (message.Isin != null && message.hasOwnProperty("Isin"))
                if (!$util.isString(message.Isin))
                    return "Isin: string expected";
            if (message.PositionId != null && message.hasOwnProperty("PositionId"))
                if (!$util.isInteger(message.PositionId) && !(message.PositionId && $util.isInteger(message.PositionId.low) && $util.isInteger(message.PositionId.high)))
                    return "PositionId: integer|Long expected";
            if (message.Utc != null && message.hasOwnProperty("Utc"))
                if (!$util.isInteger(message.Utc) && !(message.Utc && $util.isInteger(message.Utc.low) && $util.isInteger(message.Utc.high)))
                    return "Utc: integer|Long expected";
            if (message.ConvertedDailyPl != null && message.hasOwnProperty("ConvertedDailyPl"))
                if (typeof message.ConvertedDailyPl !== "number")
                    return "ConvertedDailyPl: number expected";
            if (message.ConvertedDailyCommissions != null && message.hasOwnProperty("ConvertedDailyCommissions"))
                if (typeof message.ConvertedDailyCommissions !== "number")
                    return "ConvertedDailyCommissions: number expected";
            if (message.ConvertedOpenPl != null && message.hasOwnProperty("ConvertedOpenPl"))
                if (typeof message.ConvertedOpenPl !== "number")
                    return "ConvertedOpenPl: number expected";
            if (message.EntryOrderId != null && message.hasOwnProperty("EntryOrderId"))
                if (!$util.isInteger(message.EntryOrderId) && !(message.EntryOrderId && $util.isInteger(message.EntryOrderId.low) && $util.isInteger(message.EntryOrderId.high)))
                    return "EntryOrderId: integer|Long expected";
            return null;
        };

        /**
         * Creates a PositionInfoMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.PositionInfoMsg} PositionInfoMsg
         */
        PositionInfoMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.PositionInfoMsg)
                return object;
            let message = new $root.PropTradingProtocol.PositionInfoMsg();
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.OpenQuantity != null)
                if ($util.Long)
                    (message.OpenQuantity = $util.Long.fromValue(object.OpenQuantity)).unsigned = false;
                else if (typeof object.OpenQuantity === "string")
                    message.OpenQuantity = parseInt(object.OpenQuantity, 10);
                else if (typeof object.OpenQuantity === "number")
                    message.OpenQuantity = object.OpenQuantity;
                else if (typeof object.OpenQuantity === "object")
                    message.OpenQuantity = new $util.LongBits(object.OpenQuantity.low >>> 0, object.OpenQuantity.high >>> 0).toNumber();
            if (object.OpenPrice != null)
                message.OpenPrice = Number(object.OpenPrice);
            if (object.MarginUsed != null)
                message.MarginUsed = Number(object.MarginUsed);
            if (object.DailyBought != null)
                if ($util.Long)
                    (message.DailyBought = $util.Long.fromValue(object.DailyBought)).unsigned = false;
                else if (typeof object.DailyBought === "string")
                    message.DailyBought = parseInt(object.DailyBought, 10);
                else if (typeof object.DailyBought === "number")
                    message.DailyBought = object.DailyBought;
                else if (typeof object.DailyBought === "object")
                    message.DailyBought = new $util.LongBits(object.DailyBought.low >>> 0, object.DailyBought.high >>> 0).toNumber();
            if (object.DailySold != null)
                if ($util.Long)
                    (message.DailySold = $util.Long.fromValue(object.DailySold)).unsigned = false;
                else if (typeof object.DailySold === "string")
                    message.DailySold = parseInt(object.DailySold, 10);
                else if (typeof object.DailySold === "number")
                    message.DailySold = object.DailySold;
                else if (typeof object.DailySold === "object")
                    message.DailySold = new $util.LongBits(object.DailySold.low >>> 0, object.DailySold.high >>> 0).toNumber();
            if (object.DailyPl != null)
                message.DailyPl = Number(object.DailyPl);
            if (object.HasOpenPl != null)
                message.HasOpenPl = Boolean(object.HasOpenPl);
            if (object.OpenPl != null)
                message.OpenPl = Number(object.OpenPl);
            if (object.DailyCommissions != null)
                message.DailyCommissions = Number(object.DailyCommissions);
            switch (object.SnapType) {
            default:
                if (typeof object.SnapType === "number") {
                    message.SnapType = object.SnapType;
                    break;
                }
                break;
            case "Historical":
            case 1:
                message.SnapType = 1;
                break;
            case "RealTime":
            case 2:
                message.SnapType = 2;
                break;
            }
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            if (object.FeedSymbol != null)
                message.FeedSymbol = String(object.FeedSymbol);
            if (object.Isin != null)
                message.Isin = String(object.Isin);
            if (object.PositionId != null)
                if ($util.Long)
                    (message.PositionId = $util.Long.fromValue(object.PositionId)).unsigned = false;
                else if (typeof object.PositionId === "string")
                    message.PositionId = parseInt(object.PositionId, 10);
                else if (typeof object.PositionId === "number")
                    message.PositionId = object.PositionId;
                else if (typeof object.PositionId === "object")
                    message.PositionId = new $util.LongBits(object.PositionId.low >>> 0, object.PositionId.high >>> 0).toNumber();
            if (object.Utc != null)
                if ($util.Long)
                    (message.Utc = $util.Long.fromValue(object.Utc)).unsigned = false;
                else if (typeof object.Utc === "string")
                    message.Utc = parseInt(object.Utc, 10);
                else if (typeof object.Utc === "number")
                    message.Utc = object.Utc;
                else if (typeof object.Utc === "object")
                    message.Utc = new $util.LongBits(object.Utc.low >>> 0, object.Utc.high >>> 0).toNumber();
            if (object.ConvertedDailyPl != null)
                message.ConvertedDailyPl = Number(object.ConvertedDailyPl);
            if (object.ConvertedDailyCommissions != null)
                message.ConvertedDailyCommissions = Number(object.ConvertedDailyCommissions);
            if (object.ConvertedOpenPl != null)
                message.ConvertedOpenPl = Number(object.ConvertedOpenPl);
            if (object.EntryOrderId != null)
                if ($util.Long)
                    (message.EntryOrderId = $util.Long.fromValue(object.EntryOrderId)).unsigned = false;
                else if (typeof object.EntryOrderId === "string")
                    message.EntryOrderId = parseInt(object.EntryOrderId, 10);
                else if (typeof object.EntryOrderId === "number")
                    message.EntryOrderId = object.EntryOrderId;
                else if (typeof object.EntryOrderId === "object")
                    message.EntryOrderId = new $util.LongBits(object.EntryOrderId.low >>> 0, object.EntryOrderId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a PositionInfoMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @static
         * @param {PropTradingProtocol.PositionInfoMsg} message PositionInfoMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PositionInfoMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OpenQuantity = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OpenQuantity = options.longs === String ? "0" : 0;
                object.OpenPrice = 0;
                object.MarginUsed = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.DailyBought = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.DailyBought = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.DailySold = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.DailySold = options.longs === String ? "0" : 0;
                object.DailyPl = 0;
                object.HasOpenPl = false;
                object.OpenPl = 0;
                object.DailyCommissions = 0;
                object.SnapType = options.enums === String ? "Historical" : 1;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                object.FeedSymbol = "";
                object.Isin = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.PositionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.PositionId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.Utc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Utc = options.longs === String ? "0" : 0;
                object.ConvertedDailyPl = 0;
                object.ConvertedDailyCommissions = 0;
                object.ConvertedOpenPl = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.EntryOrderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.EntryOrderId = options.longs === String ? "0" : 0;
            }
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.OpenQuantity != null && message.hasOwnProperty("OpenQuantity"))
                if (typeof message.OpenQuantity === "number")
                    object.OpenQuantity = options.longs === String ? String(message.OpenQuantity) : message.OpenQuantity;
                else
                    object.OpenQuantity = options.longs === String ? $util.Long.prototype.toString.call(message.OpenQuantity) : options.longs === Number ? new $util.LongBits(message.OpenQuantity.low >>> 0, message.OpenQuantity.high >>> 0).toNumber() : message.OpenQuantity;
            if (message.OpenPrice != null && message.hasOwnProperty("OpenPrice"))
                object.OpenPrice = options.json && !isFinite(message.OpenPrice) ? String(message.OpenPrice) : message.OpenPrice;
            if (message.MarginUsed != null && message.hasOwnProperty("MarginUsed"))
                object.MarginUsed = options.json && !isFinite(message.MarginUsed) ? String(message.MarginUsed) : message.MarginUsed;
            if (message.DailyBought != null && message.hasOwnProperty("DailyBought"))
                if (typeof message.DailyBought === "number")
                    object.DailyBought = options.longs === String ? String(message.DailyBought) : message.DailyBought;
                else
                    object.DailyBought = options.longs === String ? $util.Long.prototype.toString.call(message.DailyBought) : options.longs === Number ? new $util.LongBits(message.DailyBought.low >>> 0, message.DailyBought.high >>> 0).toNumber() : message.DailyBought;
            if (message.DailySold != null && message.hasOwnProperty("DailySold"))
                if (typeof message.DailySold === "number")
                    object.DailySold = options.longs === String ? String(message.DailySold) : message.DailySold;
                else
                    object.DailySold = options.longs === String ? $util.Long.prototype.toString.call(message.DailySold) : options.longs === Number ? new $util.LongBits(message.DailySold.low >>> 0, message.DailySold.high >>> 0).toNumber() : message.DailySold;
            if (message.DailyPl != null && message.hasOwnProperty("DailyPl"))
                object.DailyPl = options.json && !isFinite(message.DailyPl) ? String(message.DailyPl) : message.DailyPl;
            if (message.HasOpenPl != null && message.hasOwnProperty("HasOpenPl"))
                object.HasOpenPl = message.HasOpenPl;
            if (message.OpenPl != null && message.hasOwnProperty("OpenPl"))
                object.OpenPl = options.json && !isFinite(message.OpenPl) ? String(message.OpenPl) : message.OpenPl;
            if (message.DailyCommissions != null && message.hasOwnProperty("DailyCommissions"))
                object.DailyCommissions = options.json && !isFinite(message.DailyCommissions) ? String(message.DailyCommissions) : message.DailyCommissions;
            if (message.SnapType != null && message.hasOwnProperty("SnapType"))
                object.SnapType = options.enums === String ? $root.PropTradingProtocol.PositionInfoMsg.SnapTypeEnum[message.SnapType] === undefined ? message.SnapType : $root.PropTradingProtocol.PositionInfoMsg.SnapTypeEnum[message.SnapType] : message.SnapType;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                object.FeedSymbol = message.FeedSymbol;
            if (message.Isin != null && message.hasOwnProperty("Isin"))
                object.Isin = message.Isin;
            if (message.PositionId != null && message.hasOwnProperty("PositionId"))
                if (typeof message.PositionId === "number")
                    object.PositionId = options.longs === String ? String(message.PositionId) : message.PositionId;
                else
                    object.PositionId = options.longs === String ? $util.Long.prototype.toString.call(message.PositionId) : options.longs === Number ? new $util.LongBits(message.PositionId.low >>> 0, message.PositionId.high >>> 0).toNumber() : message.PositionId;
            if (message.Utc != null && message.hasOwnProperty("Utc"))
                if (typeof message.Utc === "number")
                    object.Utc = options.longs === String ? String(message.Utc) : message.Utc;
                else
                    object.Utc = options.longs === String ? $util.Long.prototype.toString.call(message.Utc) : options.longs === Number ? new $util.LongBits(message.Utc.low >>> 0, message.Utc.high >>> 0).toNumber() : message.Utc;
            if (message.ConvertedDailyPl != null && message.hasOwnProperty("ConvertedDailyPl"))
                object.ConvertedDailyPl = options.json && !isFinite(message.ConvertedDailyPl) ? String(message.ConvertedDailyPl) : message.ConvertedDailyPl;
            if (message.ConvertedDailyCommissions != null && message.hasOwnProperty("ConvertedDailyCommissions"))
                object.ConvertedDailyCommissions = options.json && !isFinite(message.ConvertedDailyCommissions) ? String(message.ConvertedDailyCommissions) : message.ConvertedDailyCommissions;
            if (message.ConvertedOpenPl != null && message.hasOwnProperty("ConvertedOpenPl"))
                object.ConvertedOpenPl = options.json && !isFinite(message.ConvertedOpenPl) ? String(message.ConvertedOpenPl) : message.ConvertedOpenPl;
            if (message.EntryOrderId != null && message.hasOwnProperty("EntryOrderId"))
                if (typeof message.EntryOrderId === "number")
                    object.EntryOrderId = options.longs === String ? String(message.EntryOrderId) : message.EntryOrderId;
                else
                    object.EntryOrderId = options.longs === String ? $util.Long.prototype.toString.call(message.EntryOrderId) : options.longs === Number ? new $util.LongBits(message.EntryOrderId.low >>> 0, message.EntryOrderId.high >>> 0).toNumber() : message.EntryOrderId;
            return object;
        };

        /**
         * Converts this PositionInfoMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PositionInfoMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PositionInfoMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.PositionInfoMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PositionInfoMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.PositionInfoMsg";
        };

        /**
         * SnapTypeEnum enum.
         * @name PropTradingProtocol.PositionInfoMsg.SnapTypeEnum
         * @enum {number}
         * @property {number} Historical=1 Historical value
         * @property {number} RealTime=2 RealTime value
         */
        PositionInfoMsg.SnapTypeEnum = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "Historical"] = 1;
            values[valuesById[2] = "RealTime"] = 2;
            return values;
        })();

        return PositionInfoMsg;
    })();

    PropTradingProtocol.BalanceMsg = (function() {

        /**
         * Properties of a BalanceMsg.
         * @memberof PropTradingProtocol
         * @interface IBalanceMsg
         * @property {number|null} [Balance] BalanceMsg Balance
         * @property {number|Long|null} [AccNumber] BalanceMsg AccNumber
         * @property {string|null} [Description] BalanceMsg Description
         * @property {number|null} [MarginUsed] BalanceMsg MarginUsed
         * @property {number|null} [StopDrawdownOverall] BalanceMsg StopDrawdownOverall
         * @property {number|null} [StopDrawdownIntraday] BalanceMsg StopDrawdownIntraday
         * @property {number|null} [ProfitTarget] BalanceMsg ProfitTarget
         * @property {number|null} [MarginAvailable] BalanceMsg MarginAvailable
         * @property {number|null} [StopDrawdownWeekly] BalanceMsg StopDrawdownWeekly
         * @property {number|null} [Equity] BalanceMsg Equity
         * @property {number|null} [DailyPl] BalanceMsg DailyPl
         * @property {number|null} [DailyNetPl] BalanceMsg DailyNetPl
         * @property {PropTradingProtocol.IBalanceDetailedMsg|null} [Details] BalanceMsg Details
         */

        /**
         * Constructs a new BalanceMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a BalanceMsg.
         * @implements IBalanceMsg
         * @constructor
         * @param {PropTradingProtocol.IBalanceMsg=} [properties] Properties to set
         */
        function BalanceMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BalanceMsg Balance.
         * @member {number} Balance
         * @memberof PropTradingProtocol.BalanceMsg
         * @instance
         */
        BalanceMsg.prototype.Balance = 0;

        /**
         * BalanceMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.BalanceMsg
         * @instance
         */
        BalanceMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BalanceMsg Description.
         * @member {string} Description
         * @memberof PropTradingProtocol.BalanceMsg
         * @instance
         */
        BalanceMsg.prototype.Description = "";

        /**
         * BalanceMsg MarginUsed.
         * @member {number} MarginUsed
         * @memberof PropTradingProtocol.BalanceMsg
         * @instance
         */
        BalanceMsg.prototype.MarginUsed = 0;

        /**
         * BalanceMsg StopDrawdownOverall.
         * @member {number} StopDrawdownOverall
         * @memberof PropTradingProtocol.BalanceMsg
         * @instance
         */
        BalanceMsg.prototype.StopDrawdownOverall = 0;

        /**
         * BalanceMsg StopDrawdownIntraday.
         * @member {number} StopDrawdownIntraday
         * @memberof PropTradingProtocol.BalanceMsg
         * @instance
         */
        BalanceMsg.prototype.StopDrawdownIntraday = 0;

        /**
         * BalanceMsg ProfitTarget.
         * @member {number} ProfitTarget
         * @memberof PropTradingProtocol.BalanceMsg
         * @instance
         */
        BalanceMsg.prototype.ProfitTarget = 0;

        /**
         * BalanceMsg MarginAvailable.
         * @member {number} MarginAvailable
         * @memberof PropTradingProtocol.BalanceMsg
         * @instance
         */
        BalanceMsg.prototype.MarginAvailable = 0;

        /**
         * BalanceMsg StopDrawdownWeekly.
         * @member {number} StopDrawdownWeekly
         * @memberof PropTradingProtocol.BalanceMsg
         * @instance
         */
        BalanceMsg.prototype.StopDrawdownWeekly = 0;

        /**
         * BalanceMsg Equity.
         * @member {number} Equity
         * @memberof PropTradingProtocol.BalanceMsg
         * @instance
         */
        BalanceMsg.prototype.Equity = 0;

        /**
         * BalanceMsg DailyPl.
         * @member {number} DailyPl
         * @memberof PropTradingProtocol.BalanceMsg
         * @instance
         */
        BalanceMsg.prototype.DailyPl = 0;

        /**
         * BalanceMsg DailyNetPl.
         * @member {number} DailyNetPl
         * @memberof PropTradingProtocol.BalanceMsg
         * @instance
         */
        BalanceMsg.prototype.DailyNetPl = 0;

        /**
         * BalanceMsg Details.
         * @member {PropTradingProtocol.IBalanceDetailedMsg|null|undefined} Details
         * @memberof PropTradingProtocol.BalanceMsg
         * @instance
         */
        BalanceMsg.prototype.Details = null;

        /**
         * Creates a new BalanceMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.BalanceMsg
         * @static
         * @param {PropTradingProtocol.IBalanceMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.BalanceMsg} BalanceMsg instance
         */
        BalanceMsg.create = function create(properties) {
            return new BalanceMsg(properties);
        };

        /**
         * Encodes the specified BalanceMsg message. Does not implicitly {@link PropTradingProtocol.BalanceMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.BalanceMsg
         * @static
         * @param {PropTradingProtocol.IBalanceMsg} message BalanceMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BalanceMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Balance != null && Object.hasOwnProperty.call(message, "Balance"))
                writer.uint32(/* id 1, wireType 1 =*/9).double(message.Balance);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccNumber);
            if (message.Description != null && Object.hasOwnProperty.call(message, "Description"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Description);
            if (message.MarginUsed != null && Object.hasOwnProperty.call(message, "MarginUsed"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.MarginUsed);
            if (message.StopDrawdownOverall != null && Object.hasOwnProperty.call(message, "StopDrawdownOverall"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.StopDrawdownOverall);
            if (message.StopDrawdownIntraday != null && Object.hasOwnProperty.call(message, "StopDrawdownIntraday"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.StopDrawdownIntraday);
            if (message.ProfitTarget != null && Object.hasOwnProperty.call(message, "ProfitTarget"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.ProfitTarget);
            if (message.MarginAvailable != null && Object.hasOwnProperty.call(message, "MarginAvailable"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.MarginAvailable);
            if (message.StopDrawdownWeekly != null && Object.hasOwnProperty.call(message, "StopDrawdownWeekly"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.StopDrawdownWeekly);
            if (message.Equity != null && Object.hasOwnProperty.call(message, "Equity"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.Equity);
            if (message.DailyPl != null && Object.hasOwnProperty.call(message, "DailyPl"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.DailyPl);
            if (message.DailyNetPl != null && Object.hasOwnProperty.call(message, "DailyNetPl"))
                writer.uint32(/* id 12, wireType 1 =*/97).double(message.DailyNetPl);
            if (message.Details != null && Object.hasOwnProperty.call(message, "Details"))
                $root.PropTradingProtocol.BalanceDetailedMsg.encode(message.Details, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BalanceMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.BalanceMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.BalanceMsg
         * @static
         * @param {PropTradingProtocol.IBalanceMsg} message BalanceMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BalanceMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BalanceMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.BalanceMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.BalanceMsg} BalanceMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BalanceMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.BalanceMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.Balance = reader.double();
                        break;
                    }
                case 2: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 3: {
                        message.Description = reader.string();
                        break;
                    }
                case 4: {
                        message.MarginUsed = reader.double();
                        break;
                    }
                case 5: {
                        message.StopDrawdownOverall = reader.double();
                        break;
                    }
                case 6: {
                        message.StopDrawdownIntraday = reader.double();
                        break;
                    }
                case 7: {
                        message.ProfitTarget = reader.double();
                        break;
                    }
                case 8: {
                        message.MarginAvailable = reader.double();
                        break;
                    }
                case 9: {
                        message.StopDrawdownWeekly = reader.double();
                        break;
                    }
                case 10: {
                        message.Equity = reader.double();
                        break;
                    }
                case 11: {
                        message.DailyPl = reader.double();
                        break;
                    }
                case 12: {
                        message.DailyNetPl = reader.double();
                        break;
                    }
                case 13: {
                        message.Details = $root.PropTradingProtocol.BalanceDetailedMsg.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BalanceMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.BalanceMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.BalanceMsg} BalanceMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BalanceMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BalanceMsg message.
         * @function verify
         * @memberof PropTradingProtocol.BalanceMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BalanceMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Balance != null && message.hasOwnProperty("Balance"))
                if (typeof message.Balance !== "number")
                    return "Balance: number expected";
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.Description != null && message.hasOwnProperty("Description"))
                if (!$util.isString(message.Description))
                    return "Description: string expected";
            if (message.MarginUsed != null && message.hasOwnProperty("MarginUsed"))
                if (typeof message.MarginUsed !== "number")
                    return "MarginUsed: number expected";
            if (message.StopDrawdownOverall != null && message.hasOwnProperty("StopDrawdownOverall"))
                if (typeof message.StopDrawdownOverall !== "number")
                    return "StopDrawdownOverall: number expected";
            if (message.StopDrawdownIntraday != null && message.hasOwnProperty("StopDrawdownIntraday"))
                if (typeof message.StopDrawdownIntraday !== "number")
                    return "StopDrawdownIntraday: number expected";
            if (message.ProfitTarget != null && message.hasOwnProperty("ProfitTarget"))
                if (typeof message.ProfitTarget !== "number")
                    return "ProfitTarget: number expected";
            if (message.MarginAvailable != null && message.hasOwnProperty("MarginAvailable"))
                if (typeof message.MarginAvailable !== "number")
                    return "MarginAvailable: number expected";
            if (message.StopDrawdownWeekly != null && message.hasOwnProperty("StopDrawdownWeekly"))
                if (typeof message.StopDrawdownWeekly !== "number")
                    return "StopDrawdownWeekly: number expected";
            if (message.Equity != null && message.hasOwnProperty("Equity"))
                if (typeof message.Equity !== "number")
                    return "Equity: number expected";
            if (message.DailyPl != null && message.hasOwnProperty("DailyPl"))
                if (typeof message.DailyPl !== "number")
                    return "DailyPl: number expected";
            if (message.DailyNetPl != null && message.hasOwnProperty("DailyNetPl"))
                if (typeof message.DailyNetPl !== "number")
                    return "DailyNetPl: number expected";
            if (message.Details != null && message.hasOwnProperty("Details")) {
                let error = $root.PropTradingProtocol.BalanceDetailedMsg.verify(message.Details);
                if (error)
                    return "Details." + error;
            }
            return null;
        };

        /**
         * Creates a BalanceMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.BalanceMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.BalanceMsg} BalanceMsg
         */
        BalanceMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.BalanceMsg)
                return object;
            let message = new $root.PropTradingProtocol.BalanceMsg();
            if (object.Balance != null)
                message.Balance = Number(object.Balance);
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            if (object.Description != null)
                message.Description = String(object.Description);
            if (object.MarginUsed != null)
                message.MarginUsed = Number(object.MarginUsed);
            if (object.StopDrawdownOverall != null)
                message.StopDrawdownOverall = Number(object.StopDrawdownOverall);
            if (object.StopDrawdownIntraday != null)
                message.StopDrawdownIntraday = Number(object.StopDrawdownIntraday);
            if (object.ProfitTarget != null)
                message.ProfitTarget = Number(object.ProfitTarget);
            if (object.MarginAvailable != null)
                message.MarginAvailable = Number(object.MarginAvailable);
            if (object.StopDrawdownWeekly != null)
                message.StopDrawdownWeekly = Number(object.StopDrawdownWeekly);
            if (object.Equity != null)
                message.Equity = Number(object.Equity);
            if (object.DailyPl != null)
                message.DailyPl = Number(object.DailyPl);
            if (object.DailyNetPl != null)
                message.DailyNetPl = Number(object.DailyNetPl);
            if (object.Details != null) {
                if (typeof object.Details !== "object")
                    throw TypeError(".PropTradingProtocol.BalanceMsg.Details: object expected");
                message.Details = $root.PropTradingProtocol.BalanceDetailedMsg.fromObject(object.Details);
            }
            return message;
        };

        /**
         * Creates a plain object from a BalanceMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.BalanceMsg
         * @static
         * @param {PropTradingProtocol.BalanceMsg} message BalanceMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BalanceMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.Balance = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                object.Description = "";
                object.MarginUsed = 0;
                object.StopDrawdownOverall = 0;
                object.StopDrawdownIntraday = 0;
                object.ProfitTarget = 0;
                object.MarginAvailable = 0;
                object.StopDrawdownWeekly = 0;
                object.Equity = 0;
                object.DailyPl = 0;
                object.DailyNetPl = 0;
                object.Details = null;
            }
            if (message.Balance != null && message.hasOwnProperty("Balance"))
                object.Balance = options.json && !isFinite(message.Balance) ? String(message.Balance) : message.Balance;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.Description != null && message.hasOwnProperty("Description"))
                object.Description = message.Description;
            if (message.MarginUsed != null && message.hasOwnProperty("MarginUsed"))
                object.MarginUsed = options.json && !isFinite(message.MarginUsed) ? String(message.MarginUsed) : message.MarginUsed;
            if (message.StopDrawdownOverall != null && message.hasOwnProperty("StopDrawdownOverall"))
                object.StopDrawdownOverall = options.json && !isFinite(message.StopDrawdownOverall) ? String(message.StopDrawdownOverall) : message.StopDrawdownOverall;
            if (message.StopDrawdownIntraday != null && message.hasOwnProperty("StopDrawdownIntraday"))
                object.StopDrawdownIntraday = options.json && !isFinite(message.StopDrawdownIntraday) ? String(message.StopDrawdownIntraday) : message.StopDrawdownIntraday;
            if (message.ProfitTarget != null && message.hasOwnProperty("ProfitTarget"))
                object.ProfitTarget = options.json && !isFinite(message.ProfitTarget) ? String(message.ProfitTarget) : message.ProfitTarget;
            if (message.MarginAvailable != null && message.hasOwnProperty("MarginAvailable"))
                object.MarginAvailable = options.json && !isFinite(message.MarginAvailable) ? String(message.MarginAvailable) : message.MarginAvailable;
            if (message.StopDrawdownWeekly != null && message.hasOwnProperty("StopDrawdownWeekly"))
                object.StopDrawdownWeekly = options.json && !isFinite(message.StopDrawdownWeekly) ? String(message.StopDrawdownWeekly) : message.StopDrawdownWeekly;
            if (message.Equity != null && message.hasOwnProperty("Equity"))
                object.Equity = options.json && !isFinite(message.Equity) ? String(message.Equity) : message.Equity;
            if (message.DailyPl != null && message.hasOwnProperty("DailyPl"))
                object.DailyPl = options.json && !isFinite(message.DailyPl) ? String(message.DailyPl) : message.DailyPl;
            if (message.DailyNetPl != null && message.hasOwnProperty("DailyNetPl"))
                object.DailyNetPl = options.json && !isFinite(message.DailyNetPl) ? String(message.DailyNetPl) : message.DailyNetPl;
            if (message.Details != null && message.hasOwnProperty("Details"))
                object.Details = $root.PropTradingProtocol.BalanceDetailedMsg.toObject(message.Details, options);
            return object;
        };

        /**
         * Converts this BalanceMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.BalanceMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BalanceMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BalanceMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.BalanceMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BalanceMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.BalanceMsg";
        };

        return BalanceMsg;
    })();

    PropTradingProtocol.BalanceDetailedMsg = (function() {

        /**
         * Properties of a BalanceDetailedMsg.
         * @memberof PropTradingProtocol
         * @interface IBalanceDetailedMsg
         * @property {boolean|null} [Empty] BalanceDetailedMsg Empty
         * @property {number|null} [StopDrawdownOverallValue] BalanceDetailedMsg StopDrawdownOverallValue
         * @property {number|null} [StopDrawdownIntradayValue] BalanceDetailedMsg StopDrawdownIntradayValue
         * @property {number|null} [ProfitTargetValue] BalanceDetailedMsg ProfitTargetValue
         * @property {number|null} [StopDrawdownWeeklyValue] BalanceDetailedMsg StopDrawdownWeeklyValue
         * @property {number|null} [UserDrawdownDailyBalance] BalanceDetailedMsg UserDrawdownDailyBalance
         * @property {number|null} [UserDrawdownWeeklyBalance] BalanceDetailedMsg UserDrawdownWeeklyBalance
         * @property {number|null} [UserProfitDailyBalance] BalanceDetailedMsg UserProfitDailyBalance
         * @property {number|null} [UserProfitWeeklyBalance] BalanceDetailedMsg UserProfitWeeklyBalance
         * @property {number|null} [UserDrawdownDailyValue] BalanceDetailedMsg UserDrawdownDailyValue
         * @property {number|null} [UserDrawdownWeeklyValue] BalanceDetailedMsg UserDrawdownWeeklyValue
         * @property {number|null} [UserProfitDailyValue] BalanceDetailedMsg UserProfitDailyValue
         * @property {number|null} [UserProfitWeeklyValue] BalanceDetailedMsg UserProfitWeeklyValue
         * @property {number|null} [SessionsNumber] BalanceDetailedMsg SessionsNumber
         * @property {number|null} [SessionsNumberTarget] BalanceDetailedMsg SessionsNumberTarget
         * @property {number|null} [StartBalance] BalanceDetailedMsg StartBalance
         */

        /**
         * Constructs a new BalanceDetailedMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a BalanceDetailedMsg.
         * @implements IBalanceDetailedMsg
         * @constructor
         * @param {PropTradingProtocol.IBalanceDetailedMsg=} [properties] Properties to set
         */
        function BalanceDetailedMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BalanceDetailedMsg Empty.
         * @member {boolean} Empty
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.Empty = false;

        /**
         * BalanceDetailedMsg StopDrawdownOverallValue.
         * @member {number} StopDrawdownOverallValue
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.StopDrawdownOverallValue = 0;

        /**
         * BalanceDetailedMsg StopDrawdownIntradayValue.
         * @member {number} StopDrawdownIntradayValue
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.StopDrawdownIntradayValue = 0;

        /**
         * BalanceDetailedMsg ProfitTargetValue.
         * @member {number} ProfitTargetValue
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.ProfitTargetValue = 0;

        /**
         * BalanceDetailedMsg StopDrawdownWeeklyValue.
         * @member {number} StopDrawdownWeeklyValue
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.StopDrawdownWeeklyValue = 0;

        /**
         * BalanceDetailedMsg UserDrawdownDailyBalance.
         * @member {number} UserDrawdownDailyBalance
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.UserDrawdownDailyBalance = 0;

        /**
         * BalanceDetailedMsg UserDrawdownWeeklyBalance.
         * @member {number} UserDrawdownWeeklyBalance
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.UserDrawdownWeeklyBalance = 0;

        /**
         * BalanceDetailedMsg UserProfitDailyBalance.
         * @member {number} UserProfitDailyBalance
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.UserProfitDailyBalance = 0;

        /**
         * BalanceDetailedMsg UserProfitWeeklyBalance.
         * @member {number} UserProfitWeeklyBalance
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.UserProfitWeeklyBalance = 0;

        /**
         * BalanceDetailedMsg UserDrawdownDailyValue.
         * @member {number} UserDrawdownDailyValue
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.UserDrawdownDailyValue = 0;

        /**
         * BalanceDetailedMsg UserDrawdownWeeklyValue.
         * @member {number} UserDrawdownWeeklyValue
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.UserDrawdownWeeklyValue = 0;

        /**
         * BalanceDetailedMsg UserProfitDailyValue.
         * @member {number} UserProfitDailyValue
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.UserProfitDailyValue = 0;

        /**
         * BalanceDetailedMsg UserProfitWeeklyValue.
         * @member {number} UserProfitWeeklyValue
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.UserProfitWeeklyValue = 0;

        /**
         * BalanceDetailedMsg SessionsNumber.
         * @member {number} SessionsNumber
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.SessionsNumber = 0;

        /**
         * BalanceDetailedMsg SessionsNumberTarget.
         * @member {number} SessionsNumberTarget
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.SessionsNumberTarget = 0;

        /**
         * BalanceDetailedMsg StartBalance.
         * @member {number} StartBalance
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         */
        BalanceDetailedMsg.prototype.StartBalance = 0;

        /**
         * Creates a new BalanceDetailedMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @static
         * @param {PropTradingProtocol.IBalanceDetailedMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.BalanceDetailedMsg} BalanceDetailedMsg instance
         */
        BalanceDetailedMsg.create = function create(properties) {
            return new BalanceDetailedMsg(properties);
        };

        /**
         * Encodes the specified BalanceDetailedMsg message. Does not implicitly {@link PropTradingProtocol.BalanceDetailedMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @static
         * @param {PropTradingProtocol.IBalanceDetailedMsg} message BalanceDetailedMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BalanceDetailedMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Empty != null && Object.hasOwnProperty.call(message, "Empty"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.Empty);
            if (message.StopDrawdownOverallValue != null && Object.hasOwnProperty.call(message, "StopDrawdownOverallValue"))
                writer.uint32(/* id 2, wireType 1 =*/17).double(message.StopDrawdownOverallValue);
            if (message.StopDrawdownIntradayValue != null && Object.hasOwnProperty.call(message, "StopDrawdownIntradayValue"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.StopDrawdownIntradayValue);
            if (message.ProfitTargetValue != null && Object.hasOwnProperty.call(message, "ProfitTargetValue"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.ProfitTargetValue);
            if (message.StopDrawdownWeeklyValue != null && Object.hasOwnProperty.call(message, "StopDrawdownWeeklyValue"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.StopDrawdownWeeklyValue);
            if (message.UserDrawdownDailyBalance != null && Object.hasOwnProperty.call(message, "UserDrawdownDailyBalance"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.UserDrawdownDailyBalance);
            if (message.UserDrawdownWeeklyBalance != null && Object.hasOwnProperty.call(message, "UserDrawdownWeeklyBalance"))
                writer.uint32(/* id 7, wireType 1 =*/57).double(message.UserDrawdownWeeklyBalance);
            if (message.UserProfitDailyBalance != null && Object.hasOwnProperty.call(message, "UserProfitDailyBalance"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.UserProfitDailyBalance);
            if (message.UserProfitWeeklyBalance != null && Object.hasOwnProperty.call(message, "UserProfitWeeklyBalance"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.UserProfitWeeklyBalance);
            if (message.UserDrawdownDailyValue != null && Object.hasOwnProperty.call(message, "UserDrawdownDailyValue"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.UserDrawdownDailyValue);
            if (message.UserDrawdownWeeklyValue != null && Object.hasOwnProperty.call(message, "UserDrawdownWeeklyValue"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.UserDrawdownWeeklyValue);
            if (message.UserProfitDailyValue != null && Object.hasOwnProperty.call(message, "UserProfitDailyValue"))
                writer.uint32(/* id 12, wireType 1 =*/97).double(message.UserProfitDailyValue);
            if (message.UserProfitWeeklyValue != null && Object.hasOwnProperty.call(message, "UserProfitWeeklyValue"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.UserProfitWeeklyValue);
            if (message.SessionsNumber != null && Object.hasOwnProperty.call(message, "SessionsNumber"))
                writer.uint32(/* id 14, wireType 0 =*/112).sint32(message.SessionsNumber);
            if (message.SessionsNumberTarget != null && Object.hasOwnProperty.call(message, "SessionsNumberTarget"))
                writer.uint32(/* id 15, wireType 0 =*/120).sint32(message.SessionsNumberTarget);
            if (message.StartBalance != null && Object.hasOwnProperty.call(message, "StartBalance"))
                writer.uint32(/* id 16, wireType 1 =*/129).double(message.StartBalance);
            return writer;
        };

        /**
         * Encodes the specified BalanceDetailedMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.BalanceDetailedMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @static
         * @param {PropTradingProtocol.IBalanceDetailedMsg} message BalanceDetailedMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BalanceDetailedMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BalanceDetailedMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.BalanceDetailedMsg} BalanceDetailedMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BalanceDetailedMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.BalanceDetailedMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.Empty = reader.bool();
                        break;
                    }
                case 2: {
                        message.StopDrawdownOverallValue = reader.double();
                        break;
                    }
                case 3: {
                        message.StopDrawdownIntradayValue = reader.double();
                        break;
                    }
                case 4: {
                        message.ProfitTargetValue = reader.double();
                        break;
                    }
                case 5: {
                        message.StopDrawdownWeeklyValue = reader.double();
                        break;
                    }
                case 6: {
                        message.UserDrawdownDailyBalance = reader.double();
                        break;
                    }
                case 7: {
                        message.UserDrawdownWeeklyBalance = reader.double();
                        break;
                    }
                case 8: {
                        message.UserProfitDailyBalance = reader.double();
                        break;
                    }
                case 9: {
                        message.UserProfitWeeklyBalance = reader.double();
                        break;
                    }
                case 10: {
                        message.UserDrawdownDailyValue = reader.double();
                        break;
                    }
                case 11: {
                        message.UserDrawdownWeeklyValue = reader.double();
                        break;
                    }
                case 12: {
                        message.UserProfitDailyValue = reader.double();
                        break;
                    }
                case 13: {
                        message.UserProfitWeeklyValue = reader.double();
                        break;
                    }
                case 14: {
                        message.SessionsNumber = reader.sint32();
                        break;
                    }
                case 15: {
                        message.SessionsNumberTarget = reader.sint32();
                        break;
                    }
                case 16: {
                        message.StartBalance = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BalanceDetailedMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.BalanceDetailedMsg} BalanceDetailedMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BalanceDetailedMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BalanceDetailedMsg message.
         * @function verify
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BalanceDetailedMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Empty != null && message.hasOwnProperty("Empty"))
                if (typeof message.Empty !== "boolean")
                    return "Empty: boolean expected";
            if (message.StopDrawdownOverallValue != null && message.hasOwnProperty("StopDrawdownOverallValue"))
                if (typeof message.StopDrawdownOverallValue !== "number")
                    return "StopDrawdownOverallValue: number expected";
            if (message.StopDrawdownIntradayValue != null && message.hasOwnProperty("StopDrawdownIntradayValue"))
                if (typeof message.StopDrawdownIntradayValue !== "number")
                    return "StopDrawdownIntradayValue: number expected";
            if (message.ProfitTargetValue != null && message.hasOwnProperty("ProfitTargetValue"))
                if (typeof message.ProfitTargetValue !== "number")
                    return "ProfitTargetValue: number expected";
            if (message.StopDrawdownWeeklyValue != null && message.hasOwnProperty("StopDrawdownWeeklyValue"))
                if (typeof message.StopDrawdownWeeklyValue !== "number")
                    return "StopDrawdownWeeklyValue: number expected";
            if (message.UserDrawdownDailyBalance != null && message.hasOwnProperty("UserDrawdownDailyBalance"))
                if (typeof message.UserDrawdownDailyBalance !== "number")
                    return "UserDrawdownDailyBalance: number expected";
            if (message.UserDrawdownWeeklyBalance != null && message.hasOwnProperty("UserDrawdownWeeklyBalance"))
                if (typeof message.UserDrawdownWeeklyBalance !== "number")
                    return "UserDrawdownWeeklyBalance: number expected";
            if (message.UserProfitDailyBalance != null && message.hasOwnProperty("UserProfitDailyBalance"))
                if (typeof message.UserProfitDailyBalance !== "number")
                    return "UserProfitDailyBalance: number expected";
            if (message.UserProfitWeeklyBalance != null && message.hasOwnProperty("UserProfitWeeklyBalance"))
                if (typeof message.UserProfitWeeklyBalance !== "number")
                    return "UserProfitWeeklyBalance: number expected";
            if (message.UserDrawdownDailyValue != null && message.hasOwnProperty("UserDrawdownDailyValue"))
                if (typeof message.UserDrawdownDailyValue !== "number")
                    return "UserDrawdownDailyValue: number expected";
            if (message.UserDrawdownWeeklyValue != null && message.hasOwnProperty("UserDrawdownWeeklyValue"))
                if (typeof message.UserDrawdownWeeklyValue !== "number")
                    return "UserDrawdownWeeklyValue: number expected";
            if (message.UserProfitDailyValue != null && message.hasOwnProperty("UserProfitDailyValue"))
                if (typeof message.UserProfitDailyValue !== "number")
                    return "UserProfitDailyValue: number expected";
            if (message.UserProfitWeeklyValue != null && message.hasOwnProperty("UserProfitWeeklyValue"))
                if (typeof message.UserProfitWeeklyValue !== "number")
                    return "UserProfitWeeklyValue: number expected";
            if (message.SessionsNumber != null && message.hasOwnProperty("SessionsNumber"))
                if (!$util.isInteger(message.SessionsNumber))
                    return "SessionsNumber: integer expected";
            if (message.SessionsNumberTarget != null && message.hasOwnProperty("SessionsNumberTarget"))
                if (!$util.isInteger(message.SessionsNumberTarget))
                    return "SessionsNumberTarget: integer expected";
            if (message.StartBalance != null && message.hasOwnProperty("StartBalance"))
                if (typeof message.StartBalance !== "number")
                    return "StartBalance: number expected";
            return null;
        };

        /**
         * Creates a BalanceDetailedMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.BalanceDetailedMsg} BalanceDetailedMsg
         */
        BalanceDetailedMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.BalanceDetailedMsg)
                return object;
            let message = new $root.PropTradingProtocol.BalanceDetailedMsg();
            if (object.Empty != null)
                message.Empty = Boolean(object.Empty);
            if (object.StopDrawdownOverallValue != null)
                message.StopDrawdownOverallValue = Number(object.StopDrawdownOverallValue);
            if (object.StopDrawdownIntradayValue != null)
                message.StopDrawdownIntradayValue = Number(object.StopDrawdownIntradayValue);
            if (object.ProfitTargetValue != null)
                message.ProfitTargetValue = Number(object.ProfitTargetValue);
            if (object.StopDrawdownWeeklyValue != null)
                message.StopDrawdownWeeklyValue = Number(object.StopDrawdownWeeklyValue);
            if (object.UserDrawdownDailyBalance != null)
                message.UserDrawdownDailyBalance = Number(object.UserDrawdownDailyBalance);
            if (object.UserDrawdownWeeklyBalance != null)
                message.UserDrawdownWeeklyBalance = Number(object.UserDrawdownWeeklyBalance);
            if (object.UserProfitDailyBalance != null)
                message.UserProfitDailyBalance = Number(object.UserProfitDailyBalance);
            if (object.UserProfitWeeklyBalance != null)
                message.UserProfitWeeklyBalance = Number(object.UserProfitWeeklyBalance);
            if (object.UserDrawdownDailyValue != null)
                message.UserDrawdownDailyValue = Number(object.UserDrawdownDailyValue);
            if (object.UserDrawdownWeeklyValue != null)
                message.UserDrawdownWeeklyValue = Number(object.UserDrawdownWeeklyValue);
            if (object.UserProfitDailyValue != null)
                message.UserProfitDailyValue = Number(object.UserProfitDailyValue);
            if (object.UserProfitWeeklyValue != null)
                message.UserProfitWeeklyValue = Number(object.UserProfitWeeklyValue);
            if (object.SessionsNumber != null)
                message.SessionsNumber = object.SessionsNumber | 0;
            if (object.SessionsNumberTarget != null)
                message.SessionsNumberTarget = object.SessionsNumberTarget | 0;
            if (object.StartBalance != null)
                message.StartBalance = Number(object.StartBalance);
            return message;
        };

        /**
         * Creates a plain object from a BalanceDetailedMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @static
         * @param {PropTradingProtocol.BalanceDetailedMsg} message BalanceDetailedMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BalanceDetailedMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.Empty = false;
                object.StopDrawdownOverallValue = 0;
                object.StopDrawdownIntradayValue = 0;
                object.ProfitTargetValue = 0;
                object.StopDrawdownWeeklyValue = 0;
                object.UserDrawdownDailyBalance = 0;
                object.UserDrawdownWeeklyBalance = 0;
                object.UserProfitDailyBalance = 0;
                object.UserProfitWeeklyBalance = 0;
                object.UserDrawdownDailyValue = 0;
                object.UserDrawdownWeeklyValue = 0;
                object.UserProfitDailyValue = 0;
                object.UserProfitWeeklyValue = 0;
                object.SessionsNumber = 0;
                object.SessionsNumberTarget = 0;
                object.StartBalance = 0;
            }
            if (message.Empty != null && message.hasOwnProperty("Empty"))
                object.Empty = message.Empty;
            if (message.StopDrawdownOverallValue != null && message.hasOwnProperty("StopDrawdownOverallValue"))
                object.StopDrawdownOverallValue = options.json && !isFinite(message.StopDrawdownOverallValue) ? String(message.StopDrawdownOverallValue) : message.StopDrawdownOverallValue;
            if (message.StopDrawdownIntradayValue != null && message.hasOwnProperty("StopDrawdownIntradayValue"))
                object.StopDrawdownIntradayValue = options.json && !isFinite(message.StopDrawdownIntradayValue) ? String(message.StopDrawdownIntradayValue) : message.StopDrawdownIntradayValue;
            if (message.ProfitTargetValue != null && message.hasOwnProperty("ProfitTargetValue"))
                object.ProfitTargetValue = options.json && !isFinite(message.ProfitTargetValue) ? String(message.ProfitTargetValue) : message.ProfitTargetValue;
            if (message.StopDrawdownWeeklyValue != null && message.hasOwnProperty("StopDrawdownWeeklyValue"))
                object.StopDrawdownWeeklyValue = options.json && !isFinite(message.StopDrawdownWeeklyValue) ? String(message.StopDrawdownWeeklyValue) : message.StopDrawdownWeeklyValue;
            if (message.UserDrawdownDailyBalance != null && message.hasOwnProperty("UserDrawdownDailyBalance"))
                object.UserDrawdownDailyBalance = options.json && !isFinite(message.UserDrawdownDailyBalance) ? String(message.UserDrawdownDailyBalance) : message.UserDrawdownDailyBalance;
            if (message.UserDrawdownWeeklyBalance != null && message.hasOwnProperty("UserDrawdownWeeklyBalance"))
                object.UserDrawdownWeeklyBalance = options.json && !isFinite(message.UserDrawdownWeeklyBalance) ? String(message.UserDrawdownWeeklyBalance) : message.UserDrawdownWeeklyBalance;
            if (message.UserProfitDailyBalance != null && message.hasOwnProperty("UserProfitDailyBalance"))
                object.UserProfitDailyBalance = options.json && !isFinite(message.UserProfitDailyBalance) ? String(message.UserProfitDailyBalance) : message.UserProfitDailyBalance;
            if (message.UserProfitWeeklyBalance != null && message.hasOwnProperty("UserProfitWeeklyBalance"))
                object.UserProfitWeeklyBalance = options.json && !isFinite(message.UserProfitWeeklyBalance) ? String(message.UserProfitWeeklyBalance) : message.UserProfitWeeklyBalance;
            if (message.UserDrawdownDailyValue != null && message.hasOwnProperty("UserDrawdownDailyValue"))
                object.UserDrawdownDailyValue = options.json && !isFinite(message.UserDrawdownDailyValue) ? String(message.UserDrawdownDailyValue) : message.UserDrawdownDailyValue;
            if (message.UserDrawdownWeeklyValue != null && message.hasOwnProperty("UserDrawdownWeeklyValue"))
                object.UserDrawdownWeeklyValue = options.json && !isFinite(message.UserDrawdownWeeklyValue) ? String(message.UserDrawdownWeeklyValue) : message.UserDrawdownWeeklyValue;
            if (message.UserProfitDailyValue != null && message.hasOwnProperty("UserProfitDailyValue"))
                object.UserProfitDailyValue = options.json && !isFinite(message.UserProfitDailyValue) ? String(message.UserProfitDailyValue) : message.UserProfitDailyValue;
            if (message.UserProfitWeeklyValue != null && message.hasOwnProperty("UserProfitWeeklyValue"))
                object.UserProfitWeeklyValue = options.json && !isFinite(message.UserProfitWeeklyValue) ? String(message.UserProfitWeeklyValue) : message.UserProfitWeeklyValue;
            if (message.SessionsNumber != null && message.hasOwnProperty("SessionsNumber"))
                object.SessionsNumber = message.SessionsNumber;
            if (message.SessionsNumberTarget != null && message.hasOwnProperty("SessionsNumberTarget"))
                object.SessionsNumberTarget = message.SessionsNumberTarget;
            if (message.StartBalance != null && message.hasOwnProperty("StartBalance"))
                object.StartBalance = options.json && !isFinite(message.StartBalance) ? String(message.StartBalance) : message.StartBalance;
            return object;
        };

        /**
         * Converts this BalanceDetailedMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BalanceDetailedMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BalanceDetailedMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.BalanceDetailedMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BalanceDetailedMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.BalanceDetailedMsg";
        };

        return BalanceDetailedMsg;
    })();

    PropTradingProtocol.SymbolLookupReqMsg = (function() {

        /**
         * Properties of a SymbolLookupReqMsg.
         * @memberof PropTradingProtocol
         * @interface ISymbolLookupReqMsg
         * @property {number|Long|null} [RequestId] SymbolLookupReqMsg RequestId
         * @property {string|null} [Filter] SymbolLookupReqMsg Filter
         */

        /**
         * Constructs a new SymbolLookupReqMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a SymbolLookupReqMsg.
         * @implements ISymbolLookupReqMsg
         * @constructor
         * @param {PropTradingProtocol.ISymbolLookupReqMsg=} [properties] Properties to set
         */
        function SymbolLookupReqMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SymbolLookupReqMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.SymbolLookupReqMsg
         * @instance
         */
        SymbolLookupReqMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SymbolLookupReqMsg Filter.
         * @member {string} Filter
         * @memberof PropTradingProtocol.SymbolLookupReqMsg
         * @instance
         */
        SymbolLookupReqMsg.prototype.Filter = "";

        /**
         * Creates a new SymbolLookupReqMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.SymbolLookupReqMsg
         * @static
         * @param {PropTradingProtocol.ISymbolLookupReqMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.SymbolLookupReqMsg} SymbolLookupReqMsg instance
         */
        SymbolLookupReqMsg.create = function create(properties) {
            return new SymbolLookupReqMsg(properties);
        };

        /**
         * Encodes the specified SymbolLookupReqMsg message. Does not implicitly {@link PropTradingProtocol.SymbolLookupReqMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.SymbolLookupReqMsg
         * @static
         * @param {PropTradingProtocol.ISymbolLookupReqMsg} message SymbolLookupReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolLookupReqMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Filter != null && Object.hasOwnProperty.call(message, "Filter"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Filter);
            return writer;
        };

        /**
         * Encodes the specified SymbolLookupReqMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.SymbolLookupReqMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.SymbolLookupReqMsg
         * @static
         * @param {PropTradingProtocol.ISymbolLookupReqMsg} message SymbolLookupReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolLookupReqMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SymbolLookupReqMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.SymbolLookupReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.SymbolLookupReqMsg} SymbolLookupReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolLookupReqMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.SymbolLookupReqMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.Filter = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SymbolLookupReqMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.SymbolLookupReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.SymbolLookupReqMsg} SymbolLookupReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolLookupReqMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SymbolLookupReqMsg message.
         * @function verify
         * @memberof PropTradingProtocol.SymbolLookupReqMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SymbolLookupReqMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Filter != null && message.hasOwnProperty("Filter"))
                if (!$util.isString(message.Filter))
                    return "Filter: string expected";
            return null;
        };

        /**
         * Creates a SymbolLookupReqMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.SymbolLookupReqMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.SymbolLookupReqMsg} SymbolLookupReqMsg
         */
        SymbolLookupReqMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.SymbolLookupReqMsg)
                return object;
            let message = new $root.PropTradingProtocol.SymbolLookupReqMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Filter != null)
                message.Filter = String(object.Filter);
            return message;
        };

        /**
         * Creates a plain object from a SymbolLookupReqMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.SymbolLookupReqMsg
         * @static
         * @param {PropTradingProtocol.SymbolLookupReqMsg} message SymbolLookupReqMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SymbolLookupReqMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.Filter = "";
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Filter != null && message.hasOwnProperty("Filter"))
                object.Filter = message.Filter;
            return object;
        };

        /**
         * Converts this SymbolLookupReqMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.SymbolLookupReqMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SymbolLookupReqMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SymbolLookupReqMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.SymbolLookupReqMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SymbolLookupReqMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.SymbolLookupReqMsg";
        };

        return SymbolLookupReqMsg;
    })();

    PropTradingProtocol.SymbolLookupRespMsg = (function() {

        /**
         * Properties of a SymbolLookupRespMsg.
         * @memberof PropTradingProtocol
         * @interface ISymbolLookupRespMsg
         * @property {number|Long|null} [RequestId] SymbolLookupRespMsg RequestId
         * @property {Array.<PropTradingProtocol.ISymbolLookupInfo>|null} [Symbols] SymbolLookupRespMsg Symbols
         */

        /**
         * Constructs a new SymbolLookupRespMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a SymbolLookupRespMsg.
         * @implements ISymbolLookupRespMsg
         * @constructor
         * @param {PropTradingProtocol.ISymbolLookupRespMsg=} [properties] Properties to set
         */
        function SymbolLookupRespMsg(properties) {
            this.Symbols = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SymbolLookupRespMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.SymbolLookupRespMsg
         * @instance
         */
        SymbolLookupRespMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SymbolLookupRespMsg Symbols.
         * @member {Array.<PropTradingProtocol.ISymbolLookupInfo>} Symbols
         * @memberof PropTradingProtocol.SymbolLookupRespMsg
         * @instance
         */
        SymbolLookupRespMsg.prototype.Symbols = $util.emptyArray;

        /**
         * Creates a new SymbolLookupRespMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.SymbolLookupRespMsg
         * @static
         * @param {PropTradingProtocol.ISymbolLookupRespMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.SymbolLookupRespMsg} SymbolLookupRespMsg instance
         */
        SymbolLookupRespMsg.create = function create(properties) {
            return new SymbolLookupRespMsg(properties);
        };

        /**
         * Encodes the specified SymbolLookupRespMsg message. Does not implicitly {@link PropTradingProtocol.SymbolLookupRespMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.SymbolLookupRespMsg
         * @static
         * @param {PropTradingProtocol.ISymbolLookupRespMsg} message SymbolLookupRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolLookupRespMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Symbols != null && message.Symbols.length)
                for (let i = 0; i < message.Symbols.length; ++i)
                    $root.PropTradingProtocol.SymbolLookupInfo.encode(message.Symbols[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SymbolLookupRespMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.SymbolLookupRespMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.SymbolLookupRespMsg
         * @static
         * @param {PropTradingProtocol.ISymbolLookupRespMsg} message SymbolLookupRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolLookupRespMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SymbolLookupRespMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.SymbolLookupRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.SymbolLookupRespMsg} SymbolLookupRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolLookupRespMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.SymbolLookupRespMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        if (!(message.Symbols && message.Symbols.length))
                            message.Symbols = [];
                        message.Symbols.push($root.PropTradingProtocol.SymbolLookupInfo.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SymbolLookupRespMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.SymbolLookupRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.SymbolLookupRespMsg} SymbolLookupRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolLookupRespMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SymbolLookupRespMsg message.
         * @function verify
         * @memberof PropTradingProtocol.SymbolLookupRespMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SymbolLookupRespMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Symbols != null && message.hasOwnProperty("Symbols")) {
                if (!Array.isArray(message.Symbols))
                    return "Symbols: array expected";
                for (let i = 0; i < message.Symbols.length; ++i) {
                    let error = $root.PropTradingProtocol.SymbolLookupInfo.verify(message.Symbols[i]);
                    if (error)
                        return "Symbols." + error;
                }
            }
            return null;
        };

        /**
         * Creates a SymbolLookupRespMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.SymbolLookupRespMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.SymbolLookupRespMsg} SymbolLookupRespMsg
         */
        SymbolLookupRespMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.SymbolLookupRespMsg)
                return object;
            let message = new $root.PropTradingProtocol.SymbolLookupRespMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Symbols) {
                if (!Array.isArray(object.Symbols))
                    throw TypeError(".PropTradingProtocol.SymbolLookupRespMsg.Symbols: array expected");
                message.Symbols = [];
                for (let i = 0; i < object.Symbols.length; ++i) {
                    if (typeof object.Symbols[i] !== "object")
                        throw TypeError(".PropTradingProtocol.SymbolLookupRespMsg.Symbols: object expected");
                    message.Symbols[i] = $root.PropTradingProtocol.SymbolLookupInfo.fromObject(object.Symbols[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a SymbolLookupRespMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.SymbolLookupRespMsg
         * @static
         * @param {PropTradingProtocol.SymbolLookupRespMsg} message SymbolLookupRespMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SymbolLookupRespMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.Symbols = [];
            if (options.defaults)
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Symbols && message.Symbols.length) {
                object.Symbols = [];
                for (let j = 0; j < message.Symbols.length; ++j)
                    object.Symbols[j] = $root.PropTradingProtocol.SymbolLookupInfo.toObject(message.Symbols[j], options);
            }
            return object;
        };

        /**
         * Converts this SymbolLookupRespMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.SymbolLookupRespMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SymbolLookupRespMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SymbolLookupRespMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.SymbolLookupRespMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SymbolLookupRespMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.SymbolLookupRespMsg";
        };

        return SymbolLookupRespMsg;
    })();

    PropTradingProtocol.SymbolLookupInfo = (function() {

        /**
         * Properties of a SymbolLookupInfo.
         * @memberof PropTradingProtocol
         * @interface ISymbolLookupInfo
         * @property {string|null} [Symbol] SymbolLookupInfo Symbol
         * @property {string|null} [Description] SymbolLookupInfo Description
         * @property {string|null} [Exchange] SymbolLookupInfo Exchange
         * @property {number|null} [TickSize] SymbolLookupInfo TickSize
         * @property {number|null} [OrderCommission] SymbolLookupInfo OrderCommission
         * @property {PropTradingProtocol.SymbolCategoryEnum|null} [Category] SymbolLookupInfo Category
         * @property {string|null} [DataFeedProduct] SymbolLookupInfo DataFeedProduct
         * @property {number|Long|null} [ContractId] SymbolLookupInfo ContractId
         * @property {boolean|null} [TradingInhibited] SymbolLookupInfo TradingInhibited
         * @property {number|null} [TradableQuantityFractionable] SymbolLookupInfo TradableQuantityFractionable
         * @property {number|null} [TradableQuantityMinimum] SymbolLookupInfo TradableQuantityMinimum
         */

        /**
         * Constructs a new SymbolLookupInfo.
         * @memberof PropTradingProtocol
         * @classdesc Represents a SymbolLookupInfo.
         * @implements ISymbolLookupInfo
         * @constructor
         * @param {PropTradingProtocol.ISymbolLookupInfo=} [properties] Properties to set
         */
        function SymbolLookupInfo(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SymbolLookupInfo Symbol.
         * @member {string} Symbol
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @instance
         */
        SymbolLookupInfo.prototype.Symbol = "";

        /**
         * SymbolLookupInfo Description.
         * @member {string} Description
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @instance
         */
        SymbolLookupInfo.prototype.Description = "";

        /**
         * SymbolLookupInfo Exchange.
         * @member {string} Exchange
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @instance
         */
        SymbolLookupInfo.prototype.Exchange = "";

        /**
         * SymbolLookupInfo TickSize.
         * @member {number} TickSize
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @instance
         */
        SymbolLookupInfo.prototype.TickSize = 0;

        /**
         * SymbolLookupInfo OrderCommission.
         * @member {number} OrderCommission
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @instance
         */
        SymbolLookupInfo.prototype.OrderCommission = 0;

        /**
         * SymbolLookupInfo Category.
         * @member {PropTradingProtocol.SymbolCategoryEnum} Category
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @instance
         */
        SymbolLookupInfo.prototype.Category = 1;

        /**
         * SymbolLookupInfo DataFeedProduct.
         * @member {string} DataFeedProduct
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @instance
         */
        SymbolLookupInfo.prototype.DataFeedProduct = "";

        /**
         * SymbolLookupInfo ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @instance
         */
        SymbolLookupInfo.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SymbolLookupInfo TradingInhibited.
         * @member {boolean} TradingInhibited
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @instance
         */
        SymbolLookupInfo.prototype.TradingInhibited = false;

        /**
         * SymbolLookupInfo TradableQuantityFractionable.
         * @member {number} TradableQuantityFractionable
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @instance
         */
        SymbolLookupInfo.prototype.TradableQuantityFractionable = 0;

        /**
         * SymbolLookupInfo TradableQuantityMinimum.
         * @member {number} TradableQuantityMinimum
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @instance
         */
        SymbolLookupInfo.prototype.TradableQuantityMinimum = 0;

        /**
         * Creates a new SymbolLookupInfo instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @static
         * @param {PropTradingProtocol.ISymbolLookupInfo=} [properties] Properties to set
         * @returns {PropTradingProtocol.SymbolLookupInfo} SymbolLookupInfo instance
         */
        SymbolLookupInfo.create = function create(properties) {
            return new SymbolLookupInfo(properties);
        };

        /**
         * Encodes the specified SymbolLookupInfo message. Does not implicitly {@link PropTradingProtocol.SymbolLookupInfo.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @static
         * @param {PropTradingProtocol.ISymbolLookupInfo} message SymbolLookupInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolLookupInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Symbol != null && Object.hasOwnProperty.call(message, "Symbol"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Symbol);
            if (message.Description != null && Object.hasOwnProperty.call(message, "Description"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Description);
            if (message.Exchange != null && Object.hasOwnProperty.call(message, "Exchange"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Exchange);
            if (message.TickSize != null && Object.hasOwnProperty.call(message, "TickSize"))
                writer.uint32(/* id 4, wireType 1 =*/33).double(message.TickSize);
            if (message.OrderCommission != null && Object.hasOwnProperty.call(message, "OrderCommission"))
                writer.uint32(/* id 5, wireType 1 =*/41).double(message.OrderCommission);
            if (message.Category != null && Object.hasOwnProperty.call(message, "Category"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Category);
            if (message.DataFeedProduct != null && Object.hasOwnProperty.call(message, "DataFeedProduct"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.DataFeedProduct);
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 8, wireType 0 =*/64).sint64(message.ContractId);
            if (message.TradingInhibited != null && Object.hasOwnProperty.call(message, "TradingInhibited"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.TradingInhibited);
            if (message.TradableQuantityFractionable != null && Object.hasOwnProperty.call(message, "TradableQuantityFractionable"))
                writer.uint32(/* id 10, wireType 0 =*/80).sint32(message.TradableQuantityFractionable);
            if (message.TradableQuantityMinimum != null && Object.hasOwnProperty.call(message, "TradableQuantityMinimum"))
                writer.uint32(/* id 11, wireType 0 =*/88).sint32(message.TradableQuantityMinimum);
            return writer;
        };

        /**
         * Encodes the specified SymbolLookupInfo message, length delimited. Does not implicitly {@link PropTradingProtocol.SymbolLookupInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @static
         * @param {PropTradingProtocol.ISymbolLookupInfo} message SymbolLookupInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SymbolLookupInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SymbolLookupInfo message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.SymbolLookupInfo} SymbolLookupInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolLookupInfo.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.SymbolLookupInfo();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.Symbol = reader.string();
                        break;
                    }
                case 2: {
                        message.Description = reader.string();
                        break;
                    }
                case 3: {
                        message.Exchange = reader.string();
                        break;
                    }
                case 4: {
                        message.TickSize = reader.double();
                        break;
                    }
                case 5: {
                        message.OrderCommission = reader.double();
                        break;
                    }
                case 6: {
                        message.Category = reader.int32();
                        break;
                    }
                case 7: {
                        message.DataFeedProduct = reader.string();
                        break;
                    }
                case 8: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 9: {
                        message.TradingInhibited = reader.bool();
                        break;
                    }
                case 10: {
                        message.TradableQuantityFractionable = reader.sint32();
                        break;
                    }
                case 11: {
                        message.TradableQuantityMinimum = reader.sint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SymbolLookupInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.SymbolLookupInfo} SymbolLookupInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SymbolLookupInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SymbolLookupInfo message.
         * @function verify
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SymbolLookupInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Symbol != null && message.hasOwnProperty("Symbol"))
                if (!$util.isString(message.Symbol))
                    return "Symbol: string expected";
            if (message.Description != null && message.hasOwnProperty("Description"))
                if (!$util.isString(message.Description))
                    return "Description: string expected";
            if (message.Exchange != null && message.hasOwnProperty("Exchange"))
                if (!$util.isString(message.Exchange))
                    return "Exchange: string expected";
            if (message.TickSize != null && message.hasOwnProperty("TickSize"))
                if (typeof message.TickSize !== "number")
                    return "TickSize: number expected";
            if (message.OrderCommission != null && message.hasOwnProperty("OrderCommission"))
                if (typeof message.OrderCommission !== "number")
                    return "OrderCommission: number expected";
            if (message.Category != null && message.hasOwnProperty("Category"))
                switch (message.Category) {
                default:
                    return "Category: enum value expected";
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.DataFeedProduct != null && message.hasOwnProperty("DataFeedProduct"))
                if (!$util.isString(message.DataFeedProduct))
                    return "DataFeedProduct: string expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.TradingInhibited != null && message.hasOwnProperty("TradingInhibited"))
                if (typeof message.TradingInhibited !== "boolean")
                    return "TradingInhibited: boolean expected";
            if (message.TradableQuantityFractionable != null && message.hasOwnProperty("TradableQuantityFractionable"))
                if (!$util.isInteger(message.TradableQuantityFractionable))
                    return "TradableQuantityFractionable: integer expected";
            if (message.TradableQuantityMinimum != null && message.hasOwnProperty("TradableQuantityMinimum"))
                if (!$util.isInteger(message.TradableQuantityMinimum))
                    return "TradableQuantityMinimum: integer expected";
            return null;
        };

        /**
         * Creates a SymbolLookupInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.SymbolLookupInfo} SymbolLookupInfo
         */
        SymbolLookupInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.SymbolLookupInfo)
                return object;
            let message = new $root.PropTradingProtocol.SymbolLookupInfo();
            if (object.Symbol != null)
                message.Symbol = String(object.Symbol);
            if (object.Description != null)
                message.Description = String(object.Description);
            if (object.Exchange != null)
                message.Exchange = String(object.Exchange);
            if (object.TickSize != null)
                message.TickSize = Number(object.TickSize);
            if (object.OrderCommission != null)
                message.OrderCommission = Number(object.OrderCommission);
            switch (object.Category) {
            default:
                if (typeof object.Category === "number") {
                    message.Category = object.Category;
                    break;
                }
                break;
            case "Future":
            case 1:
                message.Category = 1;
                break;
            case "Forex":
            case 2:
                message.Category = 2;
                break;
            case "Index":
            case 3:
                message.Category = 3;
                break;
            case "Option":
            case 4:
                message.Category = 4;
                break;
            case "Stock":
            case 5:
                message.Category = 5;
                break;
            case "CryptoPerpetual":
            case 6:
                message.Category = 6;
                break;
            case "Spot":
            case 7:
                message.Category = 7;
                break;
            case "Etf":
            case 8:
                message.Category = 8;
                break;
            }
            if (object.DataFeedProduct != null)
                message.DataFeedProduct = String(object.DataFeedProduct);
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.TradingInhibited != null)
                message.TradingInhibited = Boolean(object.TradingInhibited);
            if (object.TradableQuantityFractionable != null)
                message.TradableQuantityFractionable = object.TradableQuantityFractionable | 0;
            if (object.TradableQuantityMinimum != null)
                message.TradableQuantityMinimum = object.TradableQuantityMinimum | 0;
            return message;
        };

        /**
         * Creates a plain object from a SymbolLookupInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @static
         * @param {PropTradingProtocol.SymbolLookupInfo} message SymbolLookupInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SymbolLookupInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.Symbol = "";
                object.Description = "";
                object.Exchange = "";
                object.TickSize = 0;
                object.OrderCommission = 0;
                object.Category = options.enums === String ? "Future" : 1;
                object.DataFeedProduct = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                object.TradingInhibited = false;
                object.TradableQuantityFractionable = 0;
                object.TradableQuantityMinimum = 0;
            }
            if (message.Symbol != null && message.hasOwnProperty("Symbol"))
                object.Symbol = message.Symbol;
            if (message.Description != null && message.hasOwnProperty("Description"))
                object.Description = message.Description;
            if (message.Exchange != null && message.hasOwnProperty("Exchange"))
                object.Exchange = message.Exchange;
            if (message.TickSize != null && message.hasOwnProperty("TickSize"))
                object.TickSize = options.json && !isFinite(message.TickSize) ? String(message.TickSize) : message.TickSize;
            if (message.OrderCommission != null && message.hasOwnProperty("OrderCommission"))
                object.OrderCommission = options.json && !isFinite(message.OrderCommission) ? String(message.OrderCommission) : message.OrderCommission;
            if (message.Category != null && message.hasOwnProperty("Category"))
                object.Category = options.enums === String ? $root.PropTradingProtocol.SymbolCategoryEnum[message.Category] === undefined ? message.Category : $root.PropTradingProtocol.SymbolCategoryEnum[message.Category] : message.Category;
            if (message.DataFeedProduct != null && message.hasOwnProperty("DataFeedProduct"))
                object.DataFeedProduct = message.DataFeedProduct;
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.TradingInhibited != null && message.hasOwnProperty("TradingInhibited"))
                object.TradingInhibited = message.TradingInhibited;
            if (message.TradableQuantityFractionable != null && message.hasOwnProperty("TradableQuantityFractionable"))
                object.TradableQuantityFractionable = message.TradableQuantityFractionable;
            if (message.TradableQuantityMinimum != null && message.hasOwnProperty("TradableQuantityMinimum"))
                object.TradableQuantityMinimum = message.TradableQuantityMinimum;
            return object;
        };

        /**
         * Converts this SymbolLookupInfo to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SymbolLookupInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SymbolLookupInfo
         * @function getTypeUrl
         * @memberof PropTradingProtocol.SymbolLookupInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SymbolLookupInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.SymbolLookupInfo";
        };

        return SymbolLookupInfo;
    })();

    /**
     * OrderPositionFilterEnum enum.
     * @name PropTradingProtocol.OrderPositionFilterEnum
     * @enum {number}
     * @property {number} ALL=0 ALL value
     * @property {number} BUY=1 BUY value
     * @property {number} SELL=2 SELL value
     * @property {number} WINNER=3 WINNER value
     * @property {number} LOOSER=4 LOOSER value
     */
    PropTradingProtocol.OrderPositionFilterEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "ALL"] = 0;
        values[valuesById[1] = "BUY"] = 1;
        values[valuesById[2] = "SELL"] = 2;
        values[valuesById[3] = "WINNER"] = 3;
        values[valuesById[4] = "LOOSER"] = 4;
        return values;
    })();

    PropTradingProtocol.CancelFlatReqMsg = (function() {

        /**
         * Properties of a CancelFlatReqMsg.
         * @memberof PropTradingProtocol
         * @interface ICancelFlatReqMsg
         * @property {number|Long|null} [RequestId] CancelFlatReqMsg RequestId
         * @property {number|Long|null} [AccNumber] CancelFlatReqMsg AccNumber
         * @property {Array.<number|Long>|null} [ContractsId] CancelFlatReqMsg ContractsId
         * @property {PropTradingProtocol.CancelFlatReqMsg.ActionEnum|null} [Action] CancelFlatReqMsg Action
         * @property {PropTradingProtocol.RequestSourceEnum|null} [Source] CancelFlatReqMsg Source
         * @property {PropTradingProtocol.OrderPositionFilterEnum|null} [Filter] CancelFlatReqMsg Filter
         * @property {boolean|null} [CancelExcludeOco] CancelFlatReqMsg CancelExcludeOco
         */

        /**
         * Constructs a new CancelFlatReqMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a CancelFlatReqMsg.
         * @implements ICancelFlatReqMsg
         * @constructor
         * @param {PropTradingProtocol.ICancelFlatReqMsg=} [properties] Properties to set
         */
        function CancelFlatReqMsg(properties) {
            this.ContractsId = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CancelFlatReqMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @instance
         */
        CancelFlatReqMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CancelFlatReqMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @instance
         */
        CancelFlatReqMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CancelFlatReqMsg ContractsId.
         * @member {Array.<number|Long>} ContractsId
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @instance
         */
        CancelFlatReqMsg.prototype.ContractsId = $util.emptyArray;

        /**
         * CancelFlatReqMsg Action.
         * @member {PropTradingProtocol.CancelFlatReqMsg.ActionEnum} Action
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @instance
         */
        CancelFlatReqMsg.prototype.Action = 0;

        /**
         * CancelFlatReqMsg Source.
         * @member {PropTradingProtocol.RequestSourceEnum} Source
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @instance
         */
        CancelFlatReqMsg.prototype.Source = 0;

        /**
         * CancelFlatReqMsg Filter.
         * @member {PropTradingProtocol.OrderPositionFilterEnum} Filter
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @instance
         */
        CancelFlatReqMsg.prototype.Filter = 0;

        /**
         * CancelFlatReqMsg CancelExcludeOco.
         * @member {boolean} CancelExcludeOco
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @instance
         */
        CancelFlatReqMsg.prototype.CancelExcludeOco = false;

        /**
         * Creates a new CancelFlatReqMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @static
         * @param {PropTradingProtocol.ICancelFlatReqMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.CancelFlatReqMsg} CancelFlatReqMsg instance
         */
        CancelFlatReqMsg.create = function create(properties) {
            return new CancelFlatReqMsg(properties);
        };

        /**
         * Encodes the specified CancelFlatReqMsg message. Does not implicitly {@link PropTradingProtocol.CancelFlatReqMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @static
         * @param {PropTradingProtocol.ICancelFlatReqMsg} message CancelFlatReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelFlatReqMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccNumber);
            if (message.ContractsId != null && message.ContractsId.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (let i = 0; i < message.ContractsId.length; ++i)
                    writer.sint64(message.ContractsId[i]);
                writer.ldelim();
            }
            if (message.Action != null && Object.hasOwnProperty.call(message, "Action"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Action);
            if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Source);
            if (message.Filter != null && Object.hasOwnProperty.call(message, "Filter"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Filter);
            if (message.CancelExcludeOco != null && Object.hasOwnProperty.call(message, "CancelExcludeOco"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.CancelExcludeOco);
            return writer;
        };

        /**
         * Encodes the specified CancelFlatReqMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.CancelFlatReqMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @static
         * @param {PropTradingProtocol.ICancelFlatReqMsg} message CancelFlatReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelFlatReqMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CancelFlatReqMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.CancelFlatReqMsg} CancelFlatReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelFlatReqMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.CancelFlatReqMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 3: {
                        if (!(message.ContractsId && message.ContractsId.length))
                            message.ContractsId = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.ContractsId.push(reader.sint64());
                        } else
                            message.ContractsId.push(reader.sint64());
                        break;
                    }
                case 4: {
                        message.Action = reader.int32();
                        break;
                    }
                case 5: {
                        message.Source = reader.int32();
                        break;
                    }
                case 6: {
                        message.Filter = reader.int32();
                        break;
                    }
                case 7: {
                        message.CancelExcludeOco = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CancelFlatReqMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.CancelFlatReqMsg} CancelFlatReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelFlatReqMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CancelFlatReqMsg message.
         * @function verify
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelFlatReqMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.ContractsId != null && message.hasOwnProperty("ContractsId")) {
                if (!Array.isArray(message.ContractsId))
                    return "ContractsId: array expected";
                for (let i = 0; i < message.ContractsId.length; ++i)
                    if (!$util.isInteger(message.ContractsId[i]) && !(message.ContractsId[i] && $util.isInteger(message.ContractsId[i].low) && $util.isInteger(message.ContractsId[i].high)))
                        return "ContractsId: integer|Long[] expected";
            }
            if (message.Action != null && message.hasOwnProperty("Action"))
                switch (message.Action) {
                default:
                    return "Action: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.Source != null && message.hasOwnProperty("Source"))
                switch (message.Source) {
                default:
                    return "Source: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.Filter != null && message.hasOwnProperty("Filter"))
                switch (message.Filter) {
                default:
                    return "Filter: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.CancelExcludeOco != null && message.hasOwnProperty("CancelExcludeOco"))
                if (typeof message.CancelExcludeOco !== "boolean")
                    return "CancelExcludeOco: boolean expected";
            return null;
        };

        /**
         * Creates a CancelFlatReqMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.CancelFlatReqMsg} CancelFlatReqMsg
         */
        CancelFlatReqMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.CancelFlatReqMsg)
                return object;
            let message = new $root.PropTradingProtocol.CancelFlatReqMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            if (object.ContractsId) {
                if (!Array.isArray(object.ContractsId))
                    throw TypeError(".PropTradingProtocol.CancelFlatReqMsg.ContractsId: array expected");
                message.ContractsId = [];
                for (let i = 0; i < object.ContractsId.length; ++i)
                    if ($util.Long)
                        (message.ContractsId[i] = $util.Long.fromValue(object.ContractsId[i])).unsigned = false;
                    else if (typeof object.ContractsId[i] === "string")
                        message.ContractsId[i] = parseInt(object.ContractsId[i], 10);
                    else if (typeof object.ContractsId[i] === "number")
                        message.ContractsId[i] = object.ContractsId[i];
                    else if (typeof object.ContractsId[i] === "object")
                        message.ContractsId[i] = new $util.LongBits(object.ContractsId[i].low >>> 0, object.ContractsId[i].high >>> 0).toNumber();
            }
            switch (object.Action) {
            default:
                if (typeof object.Action === "number") {
                    message.Action = object.Action;
                    break;
                }
                break;
            case "FLAT":
            case 0:
                message.Action = 0;
                break;
            case "CANCEL":
            case 1:
                message.Action = 1;
                break;
            case "FLAT_CANCEL":
            case 2:
                message.Action = 2;
                break;
            }
            switch (object.Source) {
            default:
                if (typeof object.Source === "number") {
                    message.Source = object.Source;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.Source = 0;
                break;
            case "Manual":
            case 1:
                message.Source = 1;
                break;
            case "Automatic":
            case 2:
                message.Source = 2;
                break;
            case "Copy":
            case 3:
                message.Source = 3;
                break;
            }
            switch (object.Filter) {
            default:
                if (typeof object.Filter === "number") {
                    message.Filter = object.Filter;
                    break;
                }
                break;
            case "ALL":
            case 0:
                message.Filter = 0;
                break;
            case "BUY":
            case 1:
                message.Filter = 1;
                break;
            case "SELL":
            case 2:
                message.Filter = 2;
                break;
            case "WINNER":
            case 3:
                message.Filter = 3;
                break;
            case "LOOSER":
            case 4:
                message.Filter = 4;
                break;
            }
            if (object.CancelExcludeOco != null)
                message.CancelExcludeOco = Boolean(object.CancelExcludeOco);
            return message;
        };

        /**
         * Creates a plain object from a CancelFlatReqMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @static
         * @param {PropTradingProtocol.CancelFlatReqMsg} message CancelFlatReqMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CancelFlatReqMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.ContractsId = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                object.Action = options.enums === String ? "FLAT" : 0;
                object.Source = options.enums === String ? "Unknown" : 0;
                object.Filter = options.enums === String ? "ALL" : 0;
                object.CancelExcludeOco = false;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.ContractsId && message.ContractsId.length) {
                object.ContractsId = [];
                for (let j = 0; j < message.ContractsId.length; ++j)
                    if (typeof message.ContractsId[j] === "number")
                        object.ContractsId[j] = options.longs === String ? String(message.ContractsId[j]) : message.ContractsId[j];
                    else
                        object.ContractsId[j] = options.longs === String ? $util.Long.prototype.toString.call(message.ContractsId[j]) : options.longs === Number ? new $util.LongBits(message.ContractsId[j].low >>> 0, message.ContractsId[j].high >>> 0).toNumber() : message.ContractsId[j];
            }
            if (message.Action != null && message.hasOwnProperty("Action"))
                object.Action = options.enums === String ? $root.PropTradingProtocol.CancelFlatReqMsg.ActionEnum[message.Action] === undefined ? message.Action : $root.PropTradingProtocol.CancelFlatReqMsg.ActionEnum[message.Action] : message.Action;
            if (message.Source != null && message.hasOwnProperty("Source"))
                object.Source = options.enums === String ? $root.PropTradingProtocol.RequestSourceEnum[message.Source] === undefined ? message.Source : $root.PropTradingProtocol.RequestSourceEnum[message.Source] : message.Source;
            if (message.Filter != null && message.hasOwnProperty("Filter"))
                object.Filter = options.enums === String ? $root.PropTradingProtocol.OrderPositionFilterEnum[message.Filter] === undefined ? message.Filter : $root.PropTradingProtocol.OrderPositionFilterEnum[message.Filter] : message.Filter;
            if (message.CancelExcludeOco != null && message.hasOwnProperty("CancelExcludeOco"))
                object.CancelExcludeOco = message.CancelExcludeOco;
            return object;
        };

        /**
         * Converts this CancelFlatReqMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CancelFlatReqMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CancelFlatReqMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.CancelFlatReqMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CancelFlatReqMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.CancelFlatReqMsg";
        };

        /**
         * ActionEnum enum.
         * @name PropTradingProtocol.CancelFlatReqMsg.ActionEnum
         * @enum {number}
         * @property {number} FLAT=0 FLAT value
         * @property {number} CANCEL=1 CANCEL value
         * @property {number} FLAT_CANCEL=2 FLAT_CANCEL value
         */
        CancelFlatReqMsg.ActionEnum = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "FLAT"] = 0;
            values[valuesById[1] = "CANCEL"] = 1;
            values[valuesById[2] = "FLAT_CANCEL"] = 2;
            return values;
        })();

        return CancelFlatReqMsg;
    })();

    PropTradingProtocol.CancelFlatRespMsg = (function() {

        /**
         * Properties of a CancelFlatRespMsg.
         * @memberof PropTradingProtocol
         * @interface ICancelFlatRespMsg
         * @property {number|Long|null} [RequestId] CancelFlatRespMsg RequestId
         * @property {number|Long|null} [AccNumber] CancelFlatRespMsg AccNumber
         * @property {Array.<PropTradingProtocol.ICancelFlatErrorDetail>|null} [Errors] CancelFlatRespMsg Errors
         * @property {Array.<PropTradingProtocol.ICancelFlatItemDetail>|null} [Items] CancelFlatRespMsg Items
         */

        /**
         * Constructs a new CancelFlatRespMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a CancelFlatRespMsg.
         * @implements ICancelFlatRespMsg
         * @constructor
         * @param {PropTradingProtocol.ICancelFlatRespMsg=} [properties] Properties to set
         */
        function CancelFlatRespMsg(properties) {
            this.Errors = [];
            this.Items = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CancelFlatRespMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.CancelFlatRespMsg
         * @instance
         */
        CancelFlatRespMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CancelFlatRespMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.CancelFlatRespMsg
         * @instance
         */
        CancelFlatRespMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CancelFlatRespMsg Errors.
         * @member {Array.<PropTradingProtocol.ICancelFlatErrorDetail>} Errors
         * @memberof PropTradingProtocol.CancelFlatRespMsg
         * @instance
         */
        CancelFlatRespMsg.prototype.Errors = $util.emptyArray;

        /**
         * CancelFlatRespMsg Items.
         * @member {Array.<PropTradingProtocol.ICancelFlatItemDetail>} Items
         * @memberof PropTradingProtocol.CancelFlatRespMsg
         * @instance
         */
        CancelFlatRespMsg.prototype.Items = $util.emptyArray;

        /**
         * Creates a new CancelFlatRespMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.CancelFlatRespMsg
         * @static
         * @param {PropTradingProtocol.ICancelFlatRespMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.CancelFlatRespMsg} CancelFlatRespMsg instance
         */
        CancelFlatRespMsg.create = function create(properties) {
            return new CancelFlatRespMsg(properties);
        };

        /**
         * Encodes the specified CancelFlatRespMsg message. Does not implicitly {@link PropTradingProtocol.CancelFlatRespMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.CancelFlatRespMsg
         * @static
         * @param {PropTradingProtocol.ICancelFlatRespMsg} message CancelFlatRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelFlatRespMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccNumber);
            if (message.Errors != null && message.Errors.length)
                for (let i = 0; i < message.Errors.length; ++i)
                    $root.PropTradingProtocol.CancelFlatErrorDetail.encode(message.Errors[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.Items != null && message.Items.length)
                for (let i = 0; i < message.Items.length; ++i)
                    $root.PropTradingProtocol.CancelFlatItemDetail.encode(message.Items[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CancelFlatRespMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.CancelFlatRespMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.CancelFlatRespMsg
         * @static
         * @param {PropTradingProtocol.ICancelFlatRespMsg} message CancelFlatRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelFlatRespMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CancelFlatRespMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.CancelFlatRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.CancelFlatRespMsg} CancelFlatRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelFlatRespMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.CancelFlatRespMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 3: {
                        if (!(message.Errors && message.Errors.length))
                            message.Errors = [];
                        message.Errors.push($root.PropTradingProtocol.CancelFlatErrorDetail.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.Items && message.Items.length))
                            message.Items = [];
                        message.Items.push($root.PropTradingProtocol.CancelFlatItemDetail.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CancelFlatRespMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.CancelFlatRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.CancelFlatRespMsg} CancelFlatRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelFlatRespMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CancelFlatRespMsg message.
         * @function verify
         * @memberof PropTradingProtocol.CancelFlatRespMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelFlatRespMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.Errors != null && message.hasOwnProperty("Errors")) {
                if (!Array.isArray(message.Errors))
                    return "Errors: array expected";
                for (let i = 0; i < message.Errors.length; ++i) {
                    let error = $root.PropTradingProtocol.CancelFlatErrorDetail.verify(message.Errors[i]);
                    if (error)
                        return "Errors." + error;
                }
            }
            if (message.Items != null && message.hasOwnProperty("Items")) {
                if (!Array.isArray(message.Items))
                    return "Items: array expected";
                for (let i = 0; i < message.Items.length; ++i) {
                    let error = $root.PropTradingProtocol.CancelFlatItemDetail.verify(message.Items[i]);
                    if (error)
                        return "Items." + error;
                }
            }
            return null;
        };

        /**
         * Creates a CancelFlatRespMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.CancelFlatRespMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.CancelFlatRespMsg} CancelFlatRespMsg
         */
        CancelFlatRespMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.CancelFlatRespMsg)
                return object;
            let message = new $root.PropTradingProtocol.CancelFlatRespMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            if (object.Errors) {
                if (!Array.isArray(object.Errors))
                    throw TypeError(".PropTradingProtocol.CancelFlatRespMsg.Errors: array expected");
                message.Errors = [];
                for (let i = 0; i < object.Errors.length; ++i) {
                    if (typeof object.Errors[i] !== "object")
                        throw TypeError(".PropTradingProtocol.CancelFlatRespMsg.Errors: object expected");
                    message.Errors[i] = $root.PropTradingProtocol.CancelFlatErrorDetail.fromObject(object.Errors[i]);
                }
            }
            if (object.Items) {
                if (!Array.isArray(object.Items))
                    throw TypeError(".PropTradingProtocol.CancelFlatRespMsg.Items: array expected");
                message.Items = [];
                for (let i = 0; i < object.Items.length; ++i) {
                    if (typeof object.Items[i] !== "object")
                        throw TypeError(".PropTradingProtocol.CancelFlatRespMsg.Items: object expected");
                    message.Items[i] = $root.PropTradingProtocol.CancelFlatItemDetail.fromObject(object.Items[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a CancelFlatRespMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.CancelFlatRespMsg
         * @static
         * @param {PropTradingProtocol.CancelFlatRespMsg} message CancelFlatRespMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CancelFlatRespMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.Errors = [];
                object.Items = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.Errors && message.Errors.length) {
                object.Errors = [];
                for (let j = 0; j < message.Errors.length; ++j)
                    object.Errors[j] = $root.PropTradingProtocol.CancelFlatErrorDetail.toObject(message.Errors[j], options);
            }
            if (message.Items && message.Items.length) {
                object.Items = [];
                for (let j = 0; j < message.Items.length; ++j)
                    object.Items[j] = $root.PropTradingProtocol.CancelFlatItemDetail.toObject(message.Items[j], options);
            }
            return object;
        };

        /**
         * Converts this CancelFlatRespMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.CancelFlatRespMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CancelFlatRespMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CancelFlatRespMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.CancelFlatRespMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CancelFlatRespMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.CancelFlatRespMsg";
        };

        return CancelFlatRespMsg;
    })();

    PropTradingProtocol.CancelFlatItemDetail = (function() {

        /**
         * Properties of a CancelFlatItemDetail.
         * @memberof PropTradingProtocol
         * @interface ICancelFlatItemDetail
         * @property {boolean|null} [IsPosition] CancelFlatItemDetail IsPosition
         * @property {string|null} [FeedSymbol] CancelFlatItemDetail FeedSymbol
         * @property {number|Long|null} [ContractId] CancelFlatItemDetail ContractId
         * @property {number|Long|null} [PositionId] CancelFlatItemDetail PositionId
         * @property {number|Long|null} [OrderId] ORDER***************
         */

        /**
         * Constructs a new CancelFlatItemDetail.
         * @memberof PropTradingProtocol
         * @classdesc Represents a CancelFlatItemDetail.
         * @implements ICancelFlatItemDetail
         * @constructor
         * @param {PropTradingProtocol.ICancelFlatItemDetail=} [properties] Properties to set
         */
        function CancelFlatItemDetail(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CancelFlatItemDetail IsPosition.
         * @member {boolean} IsPosition
         * @memberof PropTradingProtocol.CancelFlatItemDetail
         * @instance
         */
        CancelFlatItemDetail.prototype.IsPosition = false;

        /**
         * CancelFlatItemDetail FeedSymbol.
         * @member {string} FeedSymbol
         * @memberof PropTradingProtocol.CancelFlatItemDetail
         * @instance
         */
        CancelFlatItemDetail.prototype.FeedSymbol = "";

        /**
         * CancelFlatItemDetail ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.CancelFlatItemDetail
         * @instance
         */
        CancelFlatItemDetail.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CancelFlatItemDetail PositionId.
         * @member {number|Long} PositionId
         * @memberof PropTradingProtocol.CancelFlatItemDetail
         * @instance
         */
        CancelFlatItemDetail.prototype.PositionId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ORDER***************
         * @member {number|Long} OrderId
         * @memberof PropTradingProtocol.CancelFlatItemDetail
         * @instance
         */
        CancelFlatItemDetail.prototype.OrderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new CancelFlatItemDetail instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.CancelFlatItemDetail
         * @static
         * @param {PropTradingProtocol.ICancelFlatItemDetail=} [properties] Properties to set
         * @returns {PropTradingProtocol.CancelFlatItemDetail} CancelFlatItemDetail instance
         */
        CancelFlatItemDetail.create = function create(properties) {
            return new CancelFlatItemDetail(properties);
        };

        /**
         * Encodes the specified CancelFlatItemDetail message. Does not implicitly {@link PropTradingProtocol.CancelFlatItemDetail.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.CancelFlatItemDetail
         * @static
         * @param {PropTradingProtocol.ICancelFlatItemDetail} message CancelFlatItemDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelFlatItemDetail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.IsPosition != null && Object.hasOwnProperty.call(message, "IsPosition"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.IsPosition);
            if (message.FeedSymbol != null && Object.hasOwnProperty.call(message, "FeedSymbol"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.FeedSymbol);
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint64(message.ContractId);
            if (message.PositionId != null && Object.hasOwnProperty.call(message, "PositionId"))
                writer.uint32(/* id 4, wireType 0 =*/32).sint64(message.PositionId);
            if (message.OrderId != null && Object.hasOwnProperty.call(message, "OrderId"))
                writer.uint32(/* id 5, wireType 0 =*/40).sint64(message.OrderId);
            return writer;
        };

        /**
         * Encodes the specified CancelFlatItemDetail message, length delimited. Does not implicitly {@link PropTradingProtocol.CancelFlatItemDetail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.CancelFlatItemDetail
         * @static
         * @param {PropTradingProtocol.ICancelFlatItemDetail} message CancelFlatItemDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelFlatItemDetail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CancelFlatItemDetail message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.CancelFlatItemDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.CancelFlatItemDetail} CancelFlatItemDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelFlatItemDetail.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.CancelFlatItemDetail();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.IsPosition = reader.bool();
                        break;
                    }
                case 2: {
                        message.FeedSymbol = reader.string();
                        break;
                    }
                case 3: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 4: {
                        message.PositionId = reader.sint64();
                        break;
                    }
                case 5: {
                        message.OrderId = reader.sint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CancelFlatItemDetail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.CancelFlatItemDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.CancelFlatItemDetail} CancelFlatItemDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelFlatItemDetail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CancelFlatItemDetail message.
         * @function verify
         * @memberof PropTradingProtocol.CancelFlatItemDetail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelFlatItemDetail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.IsPosition != null && message.hasOwnProperty("IsPosition"))
                if (typeof message.IsPosition !== "boolean")
                    return "IsPosition: boolean expected";
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                if (!$util.isString(message.FeedSymbol))
                    return "FeedSymbol: string expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.PositionId != null && message.hasOwnProperty("PositionId"))
                if (!$util.isInteger(message.PositionId) && !(message.PositionId && $util.isInteger(message.PositionId.low) && $util.isInteger(message.PositionId.high)))
                    return "PositionId: integer|Long expected";
            if (message.OrderId != null && message.hasOwnProperty("OrderId"))
                if (!$util.isInteger(message.OrderId) && !(message.OrderId && $util.isInteger(message.OrderId.low) && $util.isInteger(message.OrderId.high)))
                    return "OrderId: integer|Long expected";
            return null;
        };

        /**
         * Creates a CancelFlatItemDetail message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.CancelFlatItemDetail
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.CancelFlatItemDetail} CancelFlatItemDetail
         */
        CancelFlatItemDetail.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.CancelFlatItemDetail)
                return object;
            let message = new $root.PropTradingProtocol.CancelFlatItemDetail();
            if (object.IsPosition != null)
                message.IsPosition = Boolean(object.IsPosition);
            if (object.FeedSymbol != null)
                message.FeedSymbol = String(object.FeedSymbol);
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.PositionId != null)
                if ($util.Long)
                    (message.PositionId = $util.Long.fromValue(object.PositionId)).unsigned = false;
                else if (typeof object.PositionId === "string")
                    message.PositionId = parseInt(object.PositionId, 10);
                else if (typeof object.PositionId === "number")
                    message.PositionId = object.PositionId;
                else if (typeof object.PositionId === "object")
                    message.PositionId = new $util.LongBits(object.PositionId.low >>> 0, object.PositionId.high >>> 0).toNumber();
            if (object.OrderId != null)
                if ($util.Long)
                    (message.OrderId = $util.Long.fromValue(object.OrderId)).unsigned = false;
                else if (typeof object.OrderId === "string")
                    message.OrderId = parseInt(object.OrderId, 10);
                else if (typeof object.OrderId === "number")
                    message.OrderId = object.OrderId;
                else if (typeof object.OrderId === "object")
                    message.OrderId = new $util.LongBits(object.OrderId.low >>> 0, object.OrderId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a CancelFlatItemDetail message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.CancelFlatItemDetail
         * @static
         * @param {PropTradingProtocol.CancelFlatItemDetail} message CancelFlatItemDetail
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CancelFlatItemDetail.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.IsPosition = false;
                object.FeedSymbol = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.PositionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.PositionId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OrderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OrderId = options.longs === String ? "0" : 0;
            }
            if (message.IsPosition != null && message.hasOwnProperty("IsPosition"))
                object.IsPosition = message.IsPosition;
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                object.FeedSymbol = message.FeedSymbol;
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.PositionId != null && message.hasOwnProperty("PositionId"))
                if (typeof message.PositionId === "number")
                    object.PositionId = options.longs === String ? String(message.PositionId) : message.PositionId;
                else
                    object.PositionId = options.longs === String ? $util.Long.prototype.toString.call(message.PositionId) : options.longs === Number ? new $util.LongBits(message.PositionId.low >>> 0, message.PositionId.high >>> 0).toNumber() : message.PositionId;
            if (message.OrderId != null && message.hasOwnProperty("OrderId"))
                if (typeof message.OrderId === "number")
                    object.OrderId = options.longs === String ? String(message.OrderId) : message.OrderId;
                else
                    object.OrderId = options.longs === String ? $util.Long.prototype.toString.call(message.OrderId) : options.longs === Number ? new $util.LongBits(message.OrderId.low >>> 0, message.OrderId.high >>> 0).toNumber() : message.OrderId;
            return object;
        };

        /**
         * Converts this CancelFlatItemDetail to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.CancelFlatItemDetail
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CancelFlatItemDetail.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CancelFlatItemDetail
         * @function getTypeUrl
         * @memberof PropTradingProtocol.CancelFlatItemDetail
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CancelFlatItemDetail.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.CancelFlatItemDetail";
        };

        return CancelFlatItemDetail;
    })();

    PropTradingProtocol.CancelFlatErrorDetail = (function() {

        /**
         * Properties of a CancelFlatErrorDetail.
         * @memberof PropTradingProtocol
         * @interface ICancelFlatErrorDetail
         * @property {number|Long|null} [ContractId] CancelFlatErrorDetail ContractId
         * @property {string|null} [Error] CancelFlatErrorDetail Error
         */

        /**
         * Constructs a new CancelFlatErrorDetail.
         * @memberof PropTradingProtocol
         * @classdesc Represents a CancelFlatErrorDetail.
         * @implements ICancelFlatErrorDetail
         * @constructor
         * @param {PropTradingProtocol.ICancelFlatErrorDetail=} [properties] Properties to set
         */
        function CancelFlatErrorDetail(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CancelFlatErrorDetail ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.CancelFlatErrorDetail
         * @instance
         */
        CancelFlatErrorDetail.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CancelFlatErrorDetail Error.
         * @member {string} Error
         * @memberof PropTradingProtocol.CancelFlatErrorDetail
         * @instance
         */
        CancelFlatErrorDetail.prototype.Error = "";

        /**
         * Creates a new CancelFlatErrorDetail instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.CancelFlatErrorDetail
         * @static
         * @param {PropTradingProtocol.ICancelFlatErrorDetail=} [properties] Properties to set
         * @returns {PropTradingProtocol.CancelFlatErrorDetail} CancelFlatErrorDetail instance
         */
        CancelFlatErrorDetail.create = function create(properties) {
            return new CancelFlatErrorDetail(properties);
        };

        /**
         * Encodes the specified CancelFlatErrorDetail message. Does not implicitly {@link PropTradingProtocol.CancelFlatErrorDetail.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.CancelFlatErrorDetail
         * @static
         * @param {PropTradingProtocol.ICancelFlatErrorDetail} message CancelFlatErrorDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelFlatErrorDetail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.ContractId);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Error);
            return writer;
        };

        /**
         * Encodes the specified CancelFlatErrorDetail message, length delimited. Does not implicitly {@link PropTradingProtocol.CancelFlatErrorDetail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.CancelFlatErrorDetail
         * @static
         * @param {PropTradingProtocol.ICancelFlatErrorDetail} message CancelFlatErrorDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelFlatErrorDetail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CancelFlatErrorDetail message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.CancelFlatErrorDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.CancelFlatErrorDetail} CancelFlatErrorDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelFlatErrorDetail.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.CancelFlatErrorDetail();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.Error = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CancelFlatErrorDetail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.CancelFlatErrorDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.CancelFlatErrorDetail} CancelFlatErrorDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelFlatErrorDetail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CancelFlatErrorDetail message.
         * @function verify
         * @memberof PropTradingProtocol.CancelFlatErrorDetail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelFlatErrorDetail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isString(message.Error))
                    return "Error: string expected";
            return null;
        };

        /**
         * Creates a CancelFlatErrorDetail message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.CancelFlatErrorDetail
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.CancelFlatErrorDetail} CancelFlatErrorDetail
         */
        CancelFlatErrorDetail.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.CancelFlatErrorDetail)
                return object;
            let message = new $root.PropTradingProtocol.CancelFlatErrorDetail();
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.Error != null)
                message.Error = String(object.Error);
            return message;
        };

        /**
         * Creates a plain object from a CancelFlatErrorDetail message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.CancelFlatErrorDetail
         * @static
         * @param {PropTradingProtocol.CancelFlatErrorDetail} message CancelFlatErrorDetail
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CancelFlatErrorDetail.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                object.Error = "";
            }
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            return object;
        };

        /**
         * Converts this CancelFlatErrorDetail to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.CancelFlatErrorDetail
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CancelFlatErrorDetail.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CancelFlatErrorDetail
         * @function getTypeUrl
         * @memberof PropTradingProtocol.CancelFlatErrorDetail
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CancelFlatErrorDetail.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.CancelFlatErrorDetail";
        };

        return CancelFlatErrorDetail;
    })();

    PropTradingProtocol.CancelReverseReqMsg = (function() {

        /**
         * Properties of a CancelReverseReqMsg.
         * @memberof PropTradingProtocol
         * @interface ICancelReverseReqMsg
         * @property {number|Long|null} [RequestId] CancelReverseReqMsg RequestId
         * @property {number|Long|null} [AccNumber] CancelReverseReqMsg AccNumber
         * @property {number|Long|null} [ContractId] CancelReverseReqMsg ContractId
         * @property {PropTradingProtocol.CancelReverseReqMsg.ActionEnum|null} [Action] CancelReverseReqMsg Action
         * @property {PropTradingProtocol.RequestSourceEnum|null} [Source] CancelReverseReqMsg Source
         */

        /**
         * Constructs a new CancelReverseReqMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a CancelReverseReqMsg.
         * @implements ICancelReverseReqMsg
         * @constructor
         * @param {PropTradingProtocol.ICancelReverseReqMsg=} [properties] Properties to set
         */
        function CancelReverseReqMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CancelReverseReqMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.CancelReverseReqMsg
         * @instance
         */
        CancelReverseReqMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CancelReverseReqMsg AccNumber.
         * @member {number|Long} AccNumber
         * @memberof PropTradingProtocol.CancelReverseReqMsg
         * @instance
         */
        CancelReverseReqMsg.prototype.AccNumber = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CancelReverseReqMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.CancelReverseReqMsg
         * @instance
         */
        CancelReverseReqMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CancelReverseReqMsg Action.
         * @member {PropTradingProtocol.CancelReverseReqMsg.ActionEnum} Action
         * @memberof PropTradingProtocol.CancelReverseReqMsg
         * @instance
         */
        CancelReverseReqMsg.prototype.Action = 0;

        /**
         * CancelReverseReqMsg Source.
         * @member {PropTradingProtocol.RequestSourceEnum} Source
         * @memberof PropTradingProtocol.CancelReverseReqMsg
         * @instance
         */
        CancelReverseReqMsg.prototype.Source = 0;

        /**
         * Creates a new CancelReverseReqMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.CancelReverseReqMsg
         * @static
         * @param {PropTradingProtocol.ICancelReverseReqMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.CancelReverseReqMsg} CancelReverseReqMsg instance
         */
        CancelReverseReqMsg.create = function create(properties) {
            return new CancelReverseReqMsg(properties);
        };

        /**
         * Encodes the specified CancelReverseReqMsg message. Does not implicitly {@link PropTradingProtocol.CancelReverseReqMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.CancelReverseReqMsg
         * @static
         * @param {PropTradingProtocol.ICancelReverseReqMsg} message CancelReverseReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelReverseReqMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.AccNumber != null && Object.hasOwnProperty.call(message, "AccNumber"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccNumber);
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint64(message.ContractId);
            if (message.Action != null && Object.hasOwnProperty.call(message, "Action"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Action);
            if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Source);
            return writer;
        };

        /**
         * Encodes the specified CancelReverseReqMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.CancelReverseReqMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.CancelReverseReqMsg
         * @static
         * @param {PropTradingProtocol.ICancelReverseReqMsg} message CancelReverseReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelReverseReqMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CancelReverseReqMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.CancelReverseReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.CancelReverseReqMsg} CancelReverseReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelReverseReqMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.CancelReverseReqMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.AccNumber = reader.sint64();
                        break;
                    }
                case 3: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 4: {
                        message.Action = reader.int32();
                        break;
                    }
                case 5: {
                        message.Source = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CancelReverseReqMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.CancelReverseReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.CancelReverseReqMsg} CancelReverseReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelReverseReqMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CancelReverseReqMsg message.
         * @function verify
         * @memberof PropTradingProtocol.CancelReverseReqMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelReverseReqMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (!$util.isInteger(message.AccNumber) && !(message.AccNumber && $util.isInteger(message.AccNumber.low) && $util.isInteger(message.AccNumber.high)))
                    return "AccNumber: integer|Long expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.Action != null && message.hasOwnProperty("Action"))
                switch (message.Action) {
                default:
                    return "Action: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.Source != null && message.hasOwnProperty("Source"))
                switch (message.Source) {
                default:
                    return "Source: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            return null;
        };

        /**
         * Creates a CancelReverseReqMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.CancelReverseReqMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.CancelReverseReqMsg} CancelReverseReqMsg
         */
        CancelReverseReqMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.CancelReverseReqMsg)
                return object;
            let message = new $root.PropTradingProtocol.CancelReverseReqMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.AccNumber != null)
                if ($util.Long)
                    (message.AccNumber = $util.Long.fromValue(object.AccNumber)).unsigned = false;
                else if (typeof object.AccNumber === "string")
                    message.AccNumber = parseInt(object.AccNumber, 10);
                else if (typeof object.AccNumber === "number")
                    message.AccNumber = object.AccNumber;
                else if (typeof object.AccNumber === "object")
                    message.AccNumber = new $util.LongBits(object.AccNumber.low >>> 0, object.AccNumber.high >>> 0).toNumber();
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            switch (object.Action) {
            default:
                if (typeof object.Action === "number") {
                    message.Action = object.Action;
                    break;
                }
                break;
            case "REVERSE":
            case 0:
                message.Action = 0;
                break;
            case "CANCEL":
            case 1:
                message.Action = 1;
                break;
            case "REVERSE_CANCEL":
            case 2:
                message.Action = 2;
                break;
            }
            switch (object.Source) {
            default:
                if (typeof object.Source === "number") {
                    message.Source = object.Source;
                    break;
                }
                break;
            case "Unknown":
            case 0:
                message.Source = 0;
                break;
            case "Manual":
            case 1:
                message.Source = 1;
                break;
            case "Automatic":
            case 2:
                message.Source = 2;
                break;
            case "Copy":
            case 3:
                message.Source = 3;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a CancelReverseReqMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.CancelReverseReqMsg
         * @static
         * @param {PropTradingProtocol.CancelReverseReqMsg} message CancelReverseReqMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CancelReverseReqMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccNumber = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccNumber = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                object.Action = options.enums === String ? "REVERSE" : 0;
                object.Source = options.enums === String ? "Unknown" : 0;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.AccNumber != null && message.hasOwnProperty("AccNumber"))
                if (typeof message.AccNumber === "number")
                    object.AccNumber = options.longs === String ? String(message.AccNumber) : message.AccNumber;
                else
                    object.AccNumber = options.longs === String ? $util.Long.prototype.toString.call(message.AccNumber) : options.longs === Number ? new $util.LongBits(message.AccNumber.low >>> 0, message.AccNumber.high >>> 0).toNumber() : message.AccNumber;
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.Action != null && message.hasOwnProperty("Action"))
                object.Action = options.enums === String ? $root.PropTradingProtocol.CancelReverseReqMsg.ActionEnum[message.Action] === undefined ? message.Action : $root.PropTradingProtocol.CancelReverseReqMsg.ActionEnum[message.Action] : message.Action;
            if (message.Source != null && message.hasOwnProperty("Source"))
                object.Source = options.enums === String ? $root.PropTradingProtocol.RequestSourceEnum[message.Source] === undefined ? message.Source : $root.PropTradingProtocol.RequestSourceEnum[message.Source] : message.Source;
            return object;
        };

        /**
         * Converts this CancelReverseReqMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.CancelReverseReqMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CancelReverseReqMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CancelReverseReqMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.CancelReverseReqMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CancelReverseReqMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.CancelReverseReqMsg";
        };

        /**
         * ActionEnum enum.
         * @name PropTradingProtocol.CancelReverseReqMsg.ActionEnum
         * @enum {number}
         * @property {number} REVERSE=0 REVERSE value
         * @property {number} CANCEL=1 CANCEL value
         * @property {number} REVERSE_CANCEL=2 REVERSE_CANCEL value
         */
        CancelReverseReqMsg.ActionEnum = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "REVERSE"] = 0;
            values[valuesById[1] = "CANCEL"] = 1;
            values[valuesById[2] = "REVERSE_CANCEL"] = 2;
            return values;
        })();

        return CancelReverseReqMsg;
    })();

    PropTradingProtocol.CancelReverseRespMsg = (function() {

        /**
         * Properties of a CancelReverseRespMsg.
         * @memberof PropTradingProtocol
         * @interface ICancelReverseRespMsg
         * @property {number|Long|null} [RequestId] CancelReverseRespMsg RequestId
         * @property {boolean|null} [Success] CancelReverseRespMsg Success
         * @property {string|null} [Error] CancelReverseRespMsg Error
         */

        /**
         * Constructs a new CancelReverseRespMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a CancelReverseRespMsg.
         * @implements ICancelReverseRespMsg
         * @constructor
         * @param {PropTradingProtocol.ICancelReverseRespMsg=} [properties] Properties to set
         */
        function CancelReverseRespMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CancelReverseRespMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.CancelReverseRespMsg
         * @instance
         */
        CancelReverseRespMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CancelReverseRespMsg Success.
         * @member {boolean} Success
         * @memberof PropTradingProtocol.CancelReverseRespMsg
         * @instance
         */
        CancelReverseRespMsg.prototype.Success = false;

        /**
         * CancelReverseRespMsg Error.
         * @member {string} Error
         * @memberof PropTradingProtocol.CancelReverseRespMsg
         * @instance
         */
        CancelReverseRespMsg.prototype.Error = "";

        /**
         * Creates a new CancelReverseRespMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.CancelReverseRespMsg
         * @static
         * @param {PropTradingProtocol.ICancelReverseRespMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.CancelReverseRespMsg} CancelReverseRespMsg instance
         */
        CancelReverseRespMsg.create = function create(properties) {
            return new CancelReverseRespMsg(properties);
        };

        /**
         * Encodes the specified CancelReverseRespMsg message. Does not implicitly {@link PropTradingProtocol.CancelReverseRespMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.CancelReverseRespMsg
         * @static
         * @param {PropTradingProtocol.ICancelReverseRespMsg} message CancelReverseRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelReverseRespMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Success != null && Object.hasOwnProperty.call(message, "Success"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.Success);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Error);
            return writer;
        };

        /**
         * Encodes the specified CancelReverseRespMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.CancelReverseRespMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.CancelReverseRespMsg
         * @static
         * @param {PropTradingProtocol.ICancelReverseRespMsg} message CancelReverseRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelReverseRespMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CancelReverseRespMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.CancelReverseRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.CancelReverseRespMsg} CancelReverseRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelReverseRespMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.CancelReverseRespMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.Success = reader.bool();
                        break;
                    }
                case 3: {
                        message.Error = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CancelReverseRespMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.CancelReverseRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.CancelReverseRespMsg} CancelReverseRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelReverseRespMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CancelReverseRespMsg message.
         * @function verify
         * @memberof PropTradingProtocol.CancelReverseRespMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelReverseRespMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Success != null && message.hasOwnProperty("Success"))
                if (typeof message.Success !== "boolean")
                    return "Success: boolean expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isString(message.Error))
                    return "Error: string expected";
            return null;
        };

        /**
         * Creates a CancelReverseRespMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.CancelReverseRespMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.CancelReverseRespMsg} CancelReverseRespMsg
         */
        CancelReverseRespMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.CancelReverseRespMsg)
                return object;
            let message = new $root.PropTradingProtocol.CancelReverseRespMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Success != null)
                message.Success = Boolean(object.Success);
            if (object.Error != null)
                message.Error = String(object.Error);
            return message;
        };

        /**
         * Creates a plain object from a CancelReverseRespMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.CancelReverseRespMsg
         * @static
         * @param {PropTradingProtocol.CancelReverseRespMsg} message CancelReverseRespMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CancelReverseRespMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.Success = false;
                object.Error = "";
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Success != null && message.hasOwnProperty("Success"))
                object.Success = message.Success;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            return object;
        };

        /**
         * Converts this CancelReverseRespMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.CancelReverseRespMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CancelReverseRespMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CancelReverseRespMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.CancelReverseRespMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CancelReverseRespMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.CancelReverseRespMsg";
        };

        return CancelReverseRespMsg;
    })();

    PropTradingProtocol.BracketInsertReportMsg = (function() {

        /**
         * Properties of a BracketInsertReportMsg.
         * @memberof PropTradingProtocol
         * @interface IBracketInsertReportMsg
         * @property {number|Long|null} [RequestId] BracketInsertReportMsg RequestId
         * @property {boolean|null} [Success] BracketInsertReportMsg Success
         * @property {string|null} [Reason] BracketInsertReportMsg Reason
         */

        /**
         * Constructs a new BracketInsertReportMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a BracketInsertReportMsg.
         * @implements IBracketInsertReportMsg
         * @constructor
         * @param {PropTradingProtocol.IBracketInsertReportMsg=} [properties] Properties to set
         */
        function BracketInsertReportMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BracketInsertReportMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.BracketInsertReportMsg
         * @instance
         */
        BracketInsertReportMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * BracketInsertReportMsg Success.
         * @member {boolean} Success
         * @memberof PropTradingProtocol.BracketInsertReportMsg
         * @instance
         */
        BracketInsertReportMsg.prototype.Success = false;

        /**
         * BracketInsertReportMsg Reason.
         * @member {string} Reason
         * @memberof PropTradingProtocol.BracketInsertReportMsg
         * @instance
         */
        BracketInsertReportMsg.prototype.Reason = "";

        /**
         * Creates a new BracketInsertReportMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.BracketInsertReportMsg
         * @static
         * @param {PropTradingProtocol.IBracketInsertReportMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.BracketInsertReportMsg} BracketInsertReportMsg instance
         */
        BracketInsertReportMsg.create = function create(properties) {
            return new BracketInsertReportMsg(properties);
        };

        /**
         * Encodes the specified BracketInsertReportMsg message. Does not implicitly {@link PropTradingProtocol.BracketInsertReportMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.BracketInsertReportMsg
         * @static
         * @param {PropTradingProtocol.IBracketInsertReportMsg} message BracketInsertReportMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketInsertReportMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Success != null && Object.hasOwnProperty.call(message, "Success"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.Success);
            if (message.Reason != null && Object.hasOwnProperty.call(message, "Reason"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Reason);
            return writer;
        };

        /**
         * Encodes the specified BracketInsertReportMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.BracketInsertReportMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.BracketInsertReportMsg
         * @static
         * @param {PropTradingProtocol.IBracketInsertReportMsg} message BracketInsertReportMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BracketInsertReportMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BracketInsertReportMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.BracketInsertReportMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.BracketInsertReportMsg} BracketInsertReportMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketInsertReportMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.BracketInsertReportMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.Success = reader.bool();
                        break;
                    }
                case 3: {
                        message.Reason = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BracketInsertReportMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.BracketInsertReportMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.BracketInsertReportMsg} BracketInsertReportMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BracketInsertReportMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BracketInsertReportMsg message.
         * @function verify
         * @memberof PropTradingProtocol.BracketInsertReportMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BracketInsertReportMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Success != null && message.hasOwnProperty("Success"))
                if (typeof message.Success !== "boolean")
                    return "Success: boolean expected";
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                if (!$util.isString(message.Reason))
                    return "Reason: string expected";
            return null;
        };

        /**
         * Creates a BracketInsertReportMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.BracketInsertReportMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.BracketInsertReportMsg} BracketInsertReportMsg
         */
        BracketInsertReportMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.BracketInsertReportMsg)
                return object;
            let message = new $root.PropTradingProtocol.BracketInsertReportMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Success != null)
                message.Success = Boolean(object.Success);
            if (object.Reason != null)
                message.Reason = String(object.Reason);
            return message;
        };

        /**
         * Creates a plain object from a BracketInsertReportMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.BracketInsertReportMsg
         * @static
         * @param {PropTradingProtocol.BracketInsertReportMsg} message BracketInsertReportMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BracketInsertReportMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.Success = false;
                object.Reason = "";
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Success != null && message.hasOwnProperty("Success"))
                object.Success = message.Success;
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                object.Reason = message.Reason;
            return object;
        };

        /**
         * Converts this BracketInsertReportMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.BracketInsertReportMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BracketInsertReportMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for BracketInsertReportMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.BracketInsertReportMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        BracketInsertReportMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.BracketInsertReportMsg";
        };

        return BracketInsertReportMsg;
    })();

    /**
     * EntityActionEnum enum.
     * @name PropTradingProtocol.EntityActionEnum
     * @enum {number}
     * @property {number} SNAPSHOT=0 SNAPSHOT value
     * @property {number} ADD=1 ADD value
     * @property {number} UPDATE=2 UPDATE value
     * @property {number} REMOVE=3 REMOVE value
     */
    PropTradingProtocol.EntityActionEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SNAPSHOT"] = 0;
        values[valuesById[1] = "ADD"] = 1;
        values[valuesById[2] = "UPDATE"] = 2;
        values[valuesById[3] = "REMOVE"] = 3;
        return values;
    })();

    PropTradingProtocol.AccountStatusUpdateMsg = (function() {

        /**
         * Properties of an AccountStatusUpdateMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountStatusUpdateMsg
         * @property {number|Long|null} [AccountId] AccountStatusUpdateMsg AccountId
         * @property {PropTradingProtocol.EntityActionEnum|null} [Action] AccountStatusUpdateMsg Action
         * @property {PropTradingProtocol.IAccountHeaderMsg|null} [Info] AccountStatusUpdateMsg Info
         */

        /**
         * Constructs a new AccountStatusUpdateMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountStatusUpdateMsg.
         * @implements IAccountStatusUpdateMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountStatusUpdateMsg=} [properties] Properties to set
         */
        function AccountStatusUpdateMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountStatusUpdateMsg AccountId.
         * @member {number|Long} AccountId
         * @memberof PropTradingProtocol.AccountStatusUpdateMsg
         * @instance
         */
        AccountStatusUpdateMsg.prototype.AccountId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountStatusUpdateMsg Action.
         * @member {PropTradingProtocol.EntityActionEnum} Action
         * @memberof PropTradingProtocol.AccountStatusUpdateMsg
         * @instance
         */
        AccountStatusUpdateMsg.prototype.Action = 0;

        /**
         * AccountStatusUpdateMsg Info.
         * @member {PropTradingProtocol.IAccountHeaderMsg|null|undefined} Info
         * @memberof PropTradingProtocol.AccountStatusUpdateMsg
         * @instance
         */
        AccountStatusUpdateMsg.prototype.Info = null;

        /**
         * Creates a new AccountStatusUpdateMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountStatusUpdateMsg
         * @static
         * @param {PropTradingProtocol.IAccountStatusUpdateMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountStatusUpdateMsg} AccountStatusUpdateMsg instance
         */
        AccountStatusUpdateMsg.create = function create(properties) {
            return new AccountStatusUpdateMsg(properties);
        };

        /**
         * Encodes the specified AccountStatusUpdateMsg message. Does not implicitly {@link PropTradingProtocol.AccountStatusUpdateMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountStatusUpdateMsg
         * @static
         * @param {PropTradingProtocol.IAccountStatusUpdateMsg} message AccountStatusUpdateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountStatusUpdateMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AccountId != null && Object.hasOwnProperty.call(message, "AccountId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.AccountId);
            if (message.Action != null && Object.hasOwnProperty.call(message, "Action"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Action);
            if (message.Info != null && Object.hasOwnProperty.call(message, "Info"))
                $root.PropTradingProtocol.AccountHeaderMsg.encode(message.Info, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccountStatusUpdateMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountStatusUpdateMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountStatusUpdateMsg
         * @static
         * @param {PropTradingProtocol.IAccountStatusUpdateMsg} message AccountStatusUpdateMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountStatusUpdateMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountStatusUpdateMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountStatusUpdateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountStatusUpdateMsg} AccountStatusUpdateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountStatusUpdateMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountStatusUpdateMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.AccountId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.Action = reader.int32();
                        break;
                    }
                case 3: {
                        message.Info = $root.PropTradingProtocol.AccountHeaderMsg.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountStatusUpdateMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountStatusUpdateMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountStatusUpdateMsg} AccountStatusUpdateMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountStatusUpdateMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountStatusUpdateMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountStatusUpdateMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountStatusUpdateMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (!$util.isInteger(message.AccountId) && !(message.AccountId && $util.isInteger(message.AccountId.low) && $util.isInteger(message.AccountId.high)))
                    return "AccountId: integer|Long expected";
            if (message.Action != null && message.hasOwnProperty("Action"))
                switch (message.Action) {
                default:
                    return "Action: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.Info != null && message.hasOwnProperty("Info")) {
                let error = $root.PropTradingProtocol.AccountHeaderMsg.verify(message.Info);
                if (error)
                    return "Info." + error;
            }
            return null;
        };

        /**
         * Creates an AccountStatusUpdateMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountStatusUpdateMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountStatusUpdateMsg} AccountStatusUpdateMsg
         */
        AccountStatusUpdateMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountStatusUpdateMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountStatusUpdateMsg();
            if (object.AccountId != null)
                if ($util.Long)
                    (message.AccountId = $util.Long.fromValue(object.AccountId)).unsigned = false;
                else if (typeof object.AccountId === "string")
                    message.AccountId = parseInt(object.AccountId, 10);
                else if (typeof object.AccountId === "number")
                    message.AccountId = object.AccountId;
                else if (typeof object.AccountId === "object")
                    message.AccountId = new $util.LongBits(object.AccountId.low >>> 0, object.AccountId.high >>> 0).toNumber();
            switch (object.Action) {
            default:
                if (typeof object.Action === "number") {
                    message.Action = object.Action;
                    break;
                }
                break;
            case "SNAPSHOT":
            case 0:
                message.Action = 0;
                break;
            case "ADD":
            case 1:
                message.Action = 1;
                break;
            case "UPDATE":
            case 2:
                message.Action = 2;
                break;
            case "REMOVE":
            case 3:
                message.Action = 3;
                break;
            }
            if (object.Info != null) {
                if (typeof object.Info !== "object")
                    throw TypeError(".PropTradingProtocol.AccountStatusUpdateMsg.Info: object expected");
                message.Info = $root.PropTradingProtocol.AccountHeaderMsg.fromObject(object.Info);
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountStatusUpdateMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountStatusUpdateMsg
         * @static
         * @param {PropTradingProtocol.AccountStatusUpdateMsg} message AccountStatusUpdateMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountStatusUpdateMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccountId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccountId = options.longs === String ? "0" : 0;
                object.Action = options.enums === String ? "SNAPSHOT" : 0;
                object.Info = null;
            }
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (typeof message.AccountId === "number")
                    object.AccountId = options.longs === String ? String(message.AccountId) : message.AccountId;
                else
                    object.AccountId = options.longs === String ? $util.Long.prototype.toString.call(message.AccountId) : options.longs === Number ? new $util.LongBits(message.AccountId.low >>> 0, message.AccountId.high >>> 0).toNumber() : message.AccountId;
            if (message.Action != null && message.hasOwnProperty("Action"))
                object.Action = options.enums === String ? $root.PropTradingProtocol.EntityActionEnum[message.Action] === undefined ? message.Action : $root.PropTradingProtocol.EntityActionEnum[message.Action] : message.Action;
            if (message.Info != null && message.hasOwnProperty("Info"))
                object.Info = $root.PropTradingProtocol.AccountHeaderMsg.toObject(message.Info, options);
            return object;
        };

        /**
         * Converts this AccountStatusUpdateMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountStatusUpdateMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountStatusUpdateMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountStatusUpdateMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountStatusUpdateMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountStatusUpdateMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountStatusUpdateMsg";
        };

        return AccountStatusUpdateMsg;
    })();

    PropTradingProtocol.FillReportMsg = (function() {

        /**
         * Properties of a FillReportMsg.
         * @memberof PropTradingProtocol
         * @interface IFillReportMsg
         * @property {number|Long|null} [AccountId] FillReportMsg AccountId
         * @property {number|Long|null} [FillId] FillReportMsg FillId
         * @property {number|Long|null} [ContractId] FillReportMsg ContractId
         * @property {string|null} [FeedSymbol] FillReportMsg FeedSymbol
         * @property {number|Long|null} [Utc] FillReportMsg Utc
         * @property {number|null} [Price] FillReportMsg Price
         * @property {number|null} [Quantity] FillReportMsg Quantity
         * @property {number|null} [Commissions] FillReportMsg Commissions
         * @property {number|Long|null} [SourceOrderId] FillReportMsg SourceOrderId
         * @property {string|null} [SourceOrderIp] FillReportMsg SourceOrderIp
         */

        /**
         * Constructs a new FillReportMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a FillReportMsg.
         * @implements IFillReportMsg
         * @constructor
         * @param {PropTradingProtocol.IFillReportMsg=} [properties] Properties to set
         */
        function FillReportMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FillReportMsg AccountId.
         * @member {number|Long} AccountId
         * @memberof PropTradingProtocol.FillReportMsg
         * @instance
         */
        FillReportMsg.prototype.AccountId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FillReportMsg FillId.
         * @member {number|Long} FillId
         * @memberof PropTradingProtocol.FillReportMsg
         * @instance
         */
        FillReportMsg.prototype.FillId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FillReportMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.FillReportMsg
         * @instance
         */
        FillReportMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FillReportMsg FeedSymbol.
         * @member {string} FeedSymbol
         * @memberof PropTradingProtocol.FillReportMsg
         * @instance
         */
        FillReportMsg.prototype.FeedSymbol = "";

        /**
         * FillReportMsg Utc.
         * @member {number|Long} Utc
         * @memberof PropTradingProtocol.FillReportMsg
         * @instance
         */
        FillReportMsg.prototype.Utc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FillReportMsg Price.
         * @member {number} Price
         * @memberof PropTradingProtocol.FillReportMsg
         * @instance
         */
        FillReportMsg.prototype.Price = 0;

        /**
         * FillReportMsg Quantity.
         * @member {number} Quantity
         * @memberof PropTradingProtocol.FillReportMsg
         * @instance
         */
        FillReportMsg.prototype.Quantity = 0;

        /**
         * FillReportMsg Commissions.
         * @member {number} Commissions
         * @memberof PropTradingProtocol.FillReportMsg
         * @instance
         */
        FillReportMsg.prototype.Commissions = 0;

        /**
         * FillReportMsg SourceOrderId.
         * @member {number|Long} SourceOrderId
         * @memberof PropTradingProtocol.FillReportMsg
         * @instance
         */
        FillReportMsg.prototype.SourceOrderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FillReportMsg SourceOrderIp.
         * @member {string} SourceOrderIp
         * @memberof PropTradingProtocol.FillReportMsg
         * @instance
         */
        FillReportMsg.prototype.SourceOrderIp = "";

        /**
         * Creates a new FillReportMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.FillReportMsg
         * @static
         * @param {PropTradingProtocol.IFillReportMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.FillReportMsg} FillReportMsg instance
         */
        FillReportMsg.create = function create(properties) {
            return new FillReportMsg(properties);
        };

        /**
         * Encodes the specified FillReportMsg message. Does not implicitly {@link PropTradingProtocol.FillReportMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.FillReportMsg
         * @static
         * @param {PropTradingProtocol.IFillReportMsg} message FillReportMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FillReportMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AccountId != null && Object.hasOwnProperty.call(message, "AccountId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.AccountId);
            if (message.FillId != null && Object.hasOwnProperty.call(message, "FillId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.FillId);
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint64(message.ContractId);
            if (message.FeedSymbol != null && Object.hasOwnProperty.call(message, "FeedSymbol"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.FeedSymbol);
            if (message.Utc != null && Object.hasOwnProperty.call(message, "Utc"))
                writer.uint32(/* id 5, wireType 0 =*/40).sint64(message.Utc);
            if (message.Price != null && Object.hasOwnProperty.call(message, "Price"))
                writer.uint32(/* id 6, wireType 1 =*/49).double(message.Price);
            if (message.Quantity != null && Object.hasOwnProperty.call(message, "Quantity"))
                writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.Quantity);
            if (message.Commissions != null && Object.hasOwnProperty.call(message, "Commissions"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.Commissions);
            if (message.SourceOrderId != null && Object.hasOwnProperty.call(message, "SourceOrderId"))
                writer.uint32(/* id 9, wireType 0 =*/72).sint64(message.SourceOrderId);
            if (message.SourceOrderIp != null && Object.hasOwnProperty.call(message, "SourceOrderIp"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.SourceOrderIp);
            return writer;
        };

        /**
         * Encodes the specified FillReportMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.FillReportMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.FillReportMsg
         * @static
         * @param {PropTradingProtocol.IFillReportMsg} message FillReportMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FillReportMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FillReportMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.FillReportMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.FillReportMsg} FillReportMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FillReportMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.FillReportMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.AccountId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.FillId = reader.sint64();
                        break;
                    }
                case 3: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 4: {
                        message.FeedSymbol = reader.string();
                        break;
                    }
                case 5: {
                        message.Utc = reader.sint64();
                        break;
                    }
                case 6: {
                        message.Price = reader.double();
                        break;
                    }
                case 7: {
                        message.Quantity = reader.sint32();
                        break;
                    }
                case 8: {
                        message.Commissions = reader.double();
                        break;
                    }
                case 9: {
                        message.SourceOrderId = reader.sint64();
                        break;
                    }
                case 10: {
                        message.SourceOrderIp = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FillReportMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.FillReportMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.FillReportMsg} FillReportMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FillReportMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FillReportMsg message.
         * @function verify
         * @memberof PropTradingProtocol.FillReportMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FillReportMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (!$util.isInteger(message.AccountId) && !(message.AccountId && $util.isInteger(message.AccountId.low) && $util.isInteger(message.AccountId.high)))
                    return "AccountId: integer|Long expected";
            if (message.FillId != null && message.hasOwnProperty("FillId"))
                if (!$util.isInteger(message.FillId) && !(message.FillId && $util.isInteger(message.FillId.low) && $util.isInteger(message.FillId.high)))
                    return "FillId: integer|Long expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                if (!$util.isString(message.FeedSymbol))
                    return "FeedSymbol: string expected";
            if (message.Utc != null && message.hasOwnProperty("Utc"))
                if (!$util.isInteger(message.Utc) && !(message.Utc && $util.isInteger(message.Utc.low) && $util.isInteger(message.Utc.high)))
                    return "Utc: integer|Long expected";
            if (message.Price != null && message.hasOwnProperty("Price"))
                if (typeof message.Price !== "number")
                    return "Price: number expected";
            if (message.Quantity != null && message.hasOwnProperty("Quantity"))
                if (!$util.isInteger(message.Quantity))
                    return "Quantity: integer expected";
            if (message.Commissions != null && message.hasOwnProperty("Commissions"))
                if (typeof message.Commissions !== "number")
                    return "Commissions: number expected";
            if (message.SourceOrderId != null && message.hasOwnProperty("SourceOrderId"))
                if (!$util.isInteger(message.SourceOrderId) && !(message.SourceOrderId && $util.isInteger(message.SourceOrderId.low) && $util.isInteger(message.SourceOrderId.high)))
                    return "SourceOrderId: integer|Long expected";
            if (message.SourceOrderIp != null && message.hasOwnProperty("SourceOrderIp"))
                if (!$util.isString(message.SourceOrderIp))
                    return "SourceOrderIp: string expected";
            return null;
        };

        /**
         * Creates a FillReportMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.FillReportMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.FillReportMsg} FillReportMsg
         */
        FillReportMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.FillReportMsg)
                return object;
            let message = new $root.PropTradingProtocol.FillReportMsg();
            if (object.AccountId != null)
                if ($util.Long)
                    (message.AccountId = $util.Long.fromValue(object.AccountId)).unsigned = false;
                else if (typeof object.AccountId === "string")
                    message.AccountId = parseInt(object.AccountId, 10);
                else if (typeof object.AccountId === "number")
                    message.AccountId = object.AccountId;
                else if (typeof object.AccountId === "object")
                    message.AccountId = new $util.LongBits(object.AccountId.low >>> 0, object.AccountId.high >>> 0).toNumber();
            if (object.FillId != null)
                if ($util.Long)
                    (message.FillId = $util.Long.fromValue(object.FillId)).unsigned = false;
                else if (typeof object.FillId === "string")
                    message.FillId = parseInt(object.FillId, 10);
                else if (typeof object.FillId === "number")
                    message.FillId = object.FillId;
                else if (typeof object.FillId === "object")
                    message.FillId = new $util.LongBits(object.FillId.low >>> 0, object.FillId.high >>> 0).toNumber();
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.FeedSymbol != null)
                message.FeedSymbol = String(object.FeedSymbol);
            if (object.Utc != null)
                if ($util.Long)
                    (message.Utc = $util.Long.fromValue(object.Utc)).unsigned = false;
                else if (typeof object.Utc === "string")
                    message.Utc = parseInt(object.Utc, 10);
                else if (typeof object.Utc === "number")
                    message.Utc = object.Utc;
                else if (typeof object.Utc === "object")
                    message.Utc = new $util.LongBits(object.Utc.low >>> 0, object.Utc.high >>> 0).toNumber();
            if (object.Price != null)
                message.Price = Number(object.Price);
            if (object.Quantity != null)
                message.Quantity = object.Quantity | 0;
            if (object.Commissions != null)
                message.Commissions = Number(object.Commissions);
            if (object.SourceOrderId != null)
                if ($util.Long)
                    (message.SourceOrderId = $util.Long.fromValue(object.SourceOrderId)).unsigned = false;
                else if (typeof object.SourceOrderId === "string")
                    message.SourceOrderId = parseInt(object.SourceOrderId, 10);
                else if (typeof object.SourceOrderId === "number")
                    message.SourceOrderId = object.SourceOrderId;
                else if (typeof object.SourceOrderId === "object")
                    message.SourceOrderId = new $util.LongBits(object.SourceOrderId.low >>> 0, object.SourceOrderId.high >>> 0).toNumber();
            if (object.SourceOrderIp != null)
                message.SourceOrderIp = String(object.SourceOrderIp);
            return message;
        };

        /**
         * Creates a plain object from a FillReportMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.FillReportMsg
         * @static
         * @param {PropTradingProtocol.FillReportMsg} message FillReportMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FillReportMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccountId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccountId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.FillId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.FillId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                object.FeedSymbol = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.Utc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.Utc = options.longs === String ? "0" : 0;
                object.Price = 0;
                object.Quantity = 0;
                object.Commissions = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.SourceOrderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.SourceOrderId = options.longs === String ? "0" : 0;
                object.SourceOrderIp = "";
            }
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (typeof message.AccountId === "number")
                    object.AccountId = options.longs === String ? String(message.AccountId) : message.AccountId;
                else
                    object.AccountId = options.longs === String ? $util.Long.prototype.toString.call(message.AccountId) : options.longs === Number ? new $util.LongBits(message.AccountId.low >>> 0, message.AccountId.high >>> 0).toNumber() : message.AccountId;
            if (message.FillId != null && message.hasOwnProperty("FillId"))
                if (typeof message.FillId === "number")
                    object.FillId = options.longs === String ? String(message.FillId) : message.FillId;
                else
                    object.FillId = options.longs === String ? $util.Long.prototype.toString.call(message.FillId) : options.longs === Number ? new $util.LongBits(message.FillId.low >>> 0, message.FillId.high >>> 0).toNumber() : message.FillId;
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                object.FeedSymbol = message.FeedSymbol;
            if (message.Utc != null && message.hasOwnProperty("Utc"))
                if (typeof message.Utc === "number")
                    object.Utc = options.longs === String ? String(message.Utc) : message.Utc;
                else
                    object.Utc = options.longs === String ? $util.Long.prototype.toString.call(message.Utc) : options.longs === Number ? new $util.LongBits(message.Utc.low >>> 0, message.Utc.high >>> 0).toNumber() : message.Utc;
            if (message.Price != null && message.hasOwnProperty("Price"))
                object.Price = options.json && !isFinite(message.Price) ? String(message.Price) : message.Price;
            if (message.Quantity != null && message.hasOwnProperty("Quantity"))
                object.Quantity = message.Quantity;
            if (message.Commissions != null && message.hasOwnProperty("Commissions"))
                object.Commissions = options.json && !isFinite(message.Commissions) ? String(message.Commissions) : message.Commissions;
            if (message.SourceOrderId != null && message.hasOwnProperty("SourceOrderId"))
                if (typeof message.SourceOrderId === "number")
                    object.SourceOrderId = options.longs === String ? String(message.SourceOrderId) : message.SourceOrderId;
                else
                    object.SourceOrderId = options.longs === String ? $util.Long.prototype.toString.call(message.SourceOrderId) : options.longs === Number ? new $util.LongBits(message.SourceOrderId.low >>> 0, message.SourceOrderId.high >>> 0).toNumber() : message.SourceOrderId;
            if (message.SourceOrderIp != null && message.hasOwnProperty("SourceOrderIp"))
                object.SourceOrderIp = message.SourceOrderIp;
            return object;
        };

        /**
         * Converts this FillReportMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.FillReportMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FillReportMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FillReportMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.FillReportMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FillReportMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.FillReportMsg";
        };

        return FillReportMsg;
    })();

    PropTradingProtocol.TradeReportMsg = (function() {

        /**
         * Properties of a TradeReportMsg.
         * @memberof PropTradingProtocol
         * @interface ITradeReportMsg
         * @property {number|Long|null} [AccountId] TradeReportMsg AccountId
         * @property {number|Long|null} [TradeId] TradeReportMsg TradeId
         * @property {number|Long|null} [ContractId] TradeReportMsg ContractId
         * @property {string|null} [FeedSymbol] TradeReportMsg FeedSymbol
         * @property {number|null} [Quantity] TradeReportMsg Quantity
         * @property {number|Long|null} [EntryUtc] TradeReportMsg EntryUtc
         * @property {number|Long|null} [ExitUtc] TradeReportMsg ExitUtc
         * @property {number|null} [OpenPrice] TradeReportMsg OpenPrice
         * @property {number|null} [ClosePrice] TradeReportMsg ClosePrice
         * @property {number|null} [GrossPL] TradeReportMsg GrossPL
         * @property {number|null} [Commissions] TradeReportMsg Commissions
         * @property {boolean|null} [Unaccounted] TradeReportMsg Unaccounted
         * @property {Array.<PropTradingProtocol.TradeReportMsg.Flag>|null} [Flags] TradeReportMsg Flags
         */

        /**
         * Constructs a new TradeReportMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a TradeReportMsg.
         * @implements ITradeReportMsg
         * @constructor
         * @param {PropTradingProtocol.ITradeReportMsg=} [properties] Properties to set
         */
        function TradeReportMsg(properties) {
            this.Flags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TradeReportMsg AccountId.
         * @member {number|Long} AccountId
         * @memberof PropTradingProtocol.TradeReportMsg
         * @instance
         */
        TradeReportMsg.prototype.AccountId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TradeReportMsg TradeId.
         * @member {number|Long} TradeId
         * @memberof PropTradingProtocol.TradeReportMsg
         * @instance
         */
        TradeReportMsg.prototype.TradeId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TradeReportMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.TradeReportMsg
         * @instance
         */
        TradeReportMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TradeReportMsg FeedSymbol.
         * @member {string} FeedSymbol
         * @memberof PropTradingProtocol.TradeReportMsg
         * @instance
         */
        TradeReportMsg.prototype.FeedSymbol = "";

        /**
         * TradeReportMsg Quantity.
         * @member {number} Quantity
         * @memberof PropTradingProtocol.TradeReportMsg
         * @instance
         */
        TradeReportMsg.prototype.Quantity = 0;

        /**
         * TradeReportMsg EntryUtc.
         * @member {number|Long} EntryUtc
         * @memberof PropTradingProtocol.TradeReportMsg
         * @instance
         */
        TradeReportMsg.prototype.EntryUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TradeReportMsg ExitUtc.
         * @member {number|Long} ExitUtc
         * @memberof PropTradingProtocol.TradeReportMsg
         * @instance
         */
        TradeReportMsg.prototype.ExitUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * TradeReportMsg OpenPrice.
         * @member {number} OpenPrice
         * @memberof PropTradingProtocol.TradeReportMsg
         * @instance
         */
        TradeReportMsg.prototype.OpenPrice = 0;

        /**
         * TradeReportMsg ClosePrice.
         * @member {number} ClosePrice
         * @memberof PropTradingProtocol.TradeReportMsg
         * @instance
         */
        TradeReportMsg.prototype.ClosePrice = 0;

        /**
         * TradeReportMsg GrossPL.
         * @member {number} GrossPL
         * @memberof PropTradingProtocol.TradeReportMsg
         * @instance
         */
        TradeReportMsg.prototype.GrossPL = 0;

        /**
         * TradeReportMsg Commissions.
         * @member {number} Commissions
         * @memberof PropTradingProtocol.TradeReportMsg
         * @instance
         */
        TradeReportMsg.prototype.Commissions = 0;

        /**
         * TradeReportMsg Unaccounted.
         * @member {boolean} Unaccounted
         * @memberof PropTradingProtocol.TradeReportMsg
         * @instance
         */
        TradeReportMsg.prototype.Unaccounted = false;

        /**
         * TradeReportMsg Flags.
         * @member {Array.<PropTradingProtocol.TradeReportMsg.Flag>} Flags
         * @memberof PropTradingProtocol.TradeReportMsg
         * @instance
         */
        TradeReportMsg.prototype.Flags = $util.emptyArray;

        /**
         * Creates a new TradeReportMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.TradeReportMsg
         * @static
         * @param {PropTradingProtocol.ITradeReportMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.TradeReportMsg} TradeReportMsg instance
         */
        TradeReportMsg.create = function create(properties) {
            return new TradeReportMsg(properties);
        };

        /**
         * Encodes the specified TradeReportMsg message. Does not implicitly {@link PropTradingProtocol.TradeReportMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.TradeReportMsg
         * @static
         * @param {PropTradingProtocol.ITradeReportMsg} message TradeReportMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeReportMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AccountId != null && Object.hasOwnProperty.call(message, "AccountId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.AccountId);
            if (message.TradeId != null && Object.hasOwnProperty.call(message, "TradeId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.TradeId);
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint64(message.ContractId);
            if (message.FeedSymbol != null && Object.hasOwnProperty.call(message, "FeedSymbol"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.FeedSymbol);
            if (message.Quantity != null && Object.hasOwnProperty.call(message, "Quantity"))
                writer.uint32(/* id 5, wireType 0 =*/40).sint32(message.Quantity);
            if (message.EntryUtc != null && Object.hasOwnProperty.call(message, "EntryUtc"))
                writer.uint32(/* id 6, wireType 0 =*/48).sint64(message.EntryUtc);
            if (message.ExitUtc != null && Object.hasOwnProperty.call(message, "ExitUtc"))
                writer.uint32(/* id 7, wireType 0 =*/56).sint64(message.ExitUtc);
            if (message.OpenPrice != null && Object.hasOwnProperty.call(message, "OpenPrice"))
                writer.uint32(/* id 8, wireType 1 =*/65).double(message.OpenPrice);
            if (message.ClosePrice != null && Object.hasOwnProperty.call(message, "ClosePrice"))
                writer.uint32(/* id 9, wireType 1 =*/73).double(message.ClosePrice);
            if (message.GrossPL != null && Object.hasOwnProperty.call(message, "GrossPL"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.GrossPL);
            if (message.Commissions != null && Object.hasOwnProperty.call(message, "Commissions"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.Commissions);
            if (message.Unaccounted != null && Object.hasOwnProperty.call(message, "Unaccounted"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.Unaccounted);
            if (message.Flags != null && message.Flags.length) {
                writer.uint32(/* id 13, wireType 2 =*/106).fork();
                for (let i = 0; i < message.Flags.length; ++i)
                    writer.int32(message.Flags[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified TradeReportMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.TradeReportMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.TradeReportMsg
         * @static
         * @param {PropTradingProtocol.ITradeReportMsg} message TradeReportMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TradeReportMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TradeReportMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.TradeReportMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.TradeReportMsg} TradeReportMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeReportMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.TradeReportMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.AccountId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.TradeId = reader.sint64();
                        break;
                    }
                case 3: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 4: {
                        message.FeedSymbol = reader.string();
                        break;
                    }
                case 5: {
                        message.Quantity = reader.sint32();
                        break;
                    }
                case 6: {
                        message.EntryUtc = reader.sint64();
                        break;
                    }
                case 7: {
                        message.ExitUtc = reader.sint64();
                        break;
                    }
                case 8: {
                        message.OpenPrice = reader.double();
                        break;
                    }
                case 9: {
                        message.ClosePrice = reader.double();
                        break;
                    }
                case 10: {
                        message.GrossPL = reader.double();
                        break;
                    }
                case 11: {
                        message.Commissions = reader.double();
                        break;
                    }
                case 12: {
                        message.Unaccounted = reader.bool();
                        break;
                    }
                case 13: {
                        if (!(message.Flags && message.Flags.length))
                            message.Flags = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.Flags.push(reader.int32());
                        } else
                            message.Flags.push(reader.int32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TradeReportMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.TradeReportMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.TradeReportMsg} TradeReportMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TradeReportMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TradeReportMsg message.
         * @function verify
         * @memberof PropTradingProtocol.TradeReportMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TradeReportMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (!$util.isInteger(message.AccountId) && !(message.AccountId && $util.isInteger(message.AccountId.low) && $util.isInteger(message.AccountId.high)))
                    return "AccountId: integer|Long expected";
            if (message.TradeId != null && message.hasOwnProperty("TradeId"))
                if (!$util.isInteger(message.TradeId) && !(message.TradeId && $util.isInteger(message.TradeId.low) && $util.isInteger(message.TradeId.high)))
                    return "TradeId: integer|Long expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                if (!$util.isString(message.FeedSymbol))
                    return "FeedSymbol: string expected";
            if (message.Quantity != null && message.hasOwnProperty("Quantity"))
                if (!$util.isInteger(message.Quantity))
                    return "Quantity: integer expected";
            if (message.EntryUtc != null && message.hasOwnProperty("EntryUtc"))
                if (!$util.isInteger(message.EntryUtc) && !(message.EntryUtc && $util.isInteger(message.EntryUtc.low) && $util.isInteger(message.EntryUtc.high)))
                    return "EntryUtc: integer|Long expected";
            if (message.ExitUtc != null && message.hasOwnProperty("ExitUtc"))
                if (!$util.isInteger(message.ExitUtc) && !(message.ExitUtc && $util.isInteger(message.ExitUtc.low) && $util.isInteger(message.ExitUtc.high)))
                    return "ExitUtc: integer|Long expected";
            if (message.OpenPrice != null && message.hasOwnProperty("OpenPrice"))
                if (typeof message.OpenPrice !== "number")
                    return "OpenPrice: number expected";
            if (message.ClosePrice != null && message.hasOwnProperty("ClosePrice"))
                if (typeof message.ClosePrice !== "number")
                    return "ClosePrice: number expected";
            if (message.GrossPL != null && message.hasOwnProperty("GrossPL"))
                if (typeof message.GrossPL !== "number")
                    return "GrossPL: number expected";
            if (message.Commissions != null && message.hasOwnProperty("Commissions"))
                if (typeof message.Commissions !== "number")
                    return "Commissions: number expected";
            if (message.Unaccounted != null && message.hasOwnProperty("Unaccounted"))
                if (typeof message.Unaccounted !== "boolean")
                    return "Unaccounted: boolean expected";
            if (message.Flags != null && message.hasOwnProperty("Flags")) {
                if (!Array.isArray(message.Flags))
                    return "Flags: array expected";
                for (let i = 0; i < message.Flags.length; ++i)
                    switch (message.Flags[i]) {
                    default:
                        return "Flags: enum value[] expected";
                    case 1:
                    case 2:
                    case 4:
                        break;
                    }
            }
            return null;
        };

        /**
         * Creates a TradeReportMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.TradeReportMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.TradeReportMsg} TradeReportMsg
         */
        TradeReportMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.TradeReportMsg)
                return object;
            let message = new $root.PropTradingProtocol.TradeReportMsg();
            if (object.AccountId != null)
                if ($util.Long)
                    (message.AccountId = $util.Long.fromValue(object.AccountId)).unsigned = false;
                else if (typeof object.AccountId === "string")
                    message.AccountId = parseInt(object.AccountId, 10);
                else if (typeof object.AccountId === "number")
                    message.AccountId = object.AccountId;
                else if (typeof object.AccountId === "object")
                    message.AccountId = new $util.LongBits(object.AccountId.low >>> 0, object.AccountId.high >>> 0).toNumber();
            if (object.TradeId != null)
                if ($util.Long)
                    (message.TradeId = $util.Long.fromValue(object.TradeId)).unsigned = false;
                else if (typeof object.TradeId === "string")
                    message.TradeId = parseInt(object.TradeId, 10);
                else if (typeof object.TradeId === "number")
                    message.TradeId = object.TradeId;
                else if (typeof object.TradeId === "object")
                    message.TradeId = new $util.LongBits(object.TradeId.low >>> 0, object.TradeId.high >>> 0).toNumber();
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.FeedSymbol != null)
                message.FeedSymbol = String(object.FeedSymbol);
            if (object.Quantity != null)
                message.Quantity = object.Quantity | 0;
            if (object.EntryUtc != null)
                if ($util.Long)
                    (message.EntryUtc = $util.Long.fromValue(object.EntryUtc)).unsigned = false;
                else if (typeof object.EntryUtc === "string")
                    message.EntryUtc = parseInt(object.EntryUtc, 10);
                else if (typeof object.EntryUtc === "number")
                    message.EntryUtc = object.EntryUtc;
                else if (typeof object.EntryUtc === "object")
                    message.EntryUtc = new $util.LongBits(object.EntryUtc.low >>> 0, object.EntryUtc.high >>> 0).toNumber();
            if (object.ExitUtc != null)
                if ($util.Long)
                    (message.ExitUtc = $util.Long.fromValue(object.ExitUtc)).unsigned = false;
                else if (typeof object.ExitUtc === "string")
                    message.ExitUtc = parseInt(object.ExitUtc, 10);
                else if (typeof object.ExitUtc === "number")
                    message.ExitUtc = object.ExitUtc;
                else if (typeof object.ExitUtc === "object")
                    message.ExitUtc = new $util.LongBits(object.ExitUtc.low >>> 0, object.ExitUtc.high >>> 0).toNumber();
            if (object.OpenPrice != null)
                message.OpenPrice = Number(object.OpenPrice);
            if (object.ClosePrice != null)
                message.ClosePrice = Number(object.ClosePrice);
            if (object.GrossPL != null)
                message.GrossPL = Number(object.GrossPL);
            if (object.Commissions != null)
                message.Commissions = Number(object.Commissions);
            if (object.Unaccounted != null)
                message.Unaccounted = Boolean(object.Unaccounted);
            if (object.Flags) {
                if (!Array.isArray(object.Flags))
                    throw TypeError(".PropTradingProtocol.TradeReportMsg.Flags: array expected");
                message.Flags = [];
                for (let i = 0; i < object.Flags.length; ++i)
                    switch (object.Flags[i]) {
                    default:
                        if (typeof object.Flags[i] === "number") {
                            message.Flags[i] = object.Flags[i];
                            break;
                        }
                    case "SCALP":
                    case 1:
                        message.Flags[i] = 1;
                        break;
                    case "CLOSED_TOO_CLOSE_TO_ENTRY":
                    case 2:
                        message.Flags[i] = 2;
                        break;
                    case "TRADING_NEWS":
                    case 4:
                        message.Flags[i] = 4;
                        break;
                    }
            }
            return message;
        };

        /**
         * Creates a plain object from a TradeReportMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.TradeReportMsg
         * @static
         * @param {PropTradingProtocol.TradeReportMsg} message TradeReportMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TradeReportMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.Flags = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccountId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccountId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.TradeId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.TradeId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                object.FeedSymbol = "";
                object.Quantity = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.EntryUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.EntryUtc = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ExitUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ExitUtc = options.longs === String ? "0" : 0;
                object.OpenPrice = 0;
                object.ClosePrice = 0;
                object.GrossPL = 0;
                object.Commissions = 0;
                object.Unaccounted = false;
            }
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (typeof message.AccountId === "number")
                    object.AccountId = options.longs === String ? String(message.AccountId) : message.AccountId;
                else
                    object.AccountId = options.longs === String ? $util.Long.prototype.toString.call(message.AccountId) : options.longs === Number ? new $util.LongBits(message.AccountId.low >>> 0, message.AccountId.high >>> 0).toNumber() : message.AccountId;
            if (message.TradeId != null && message.hasOwnProperty("TradeId"))
                if (typeof message.TradeId === "number")
                    object.TradeId = options.longs === String ? String(message.TradeId) : message.TradeId;
                else
                    object.TradeId = options.longs === String ? $util.Long.prototype.toString.call(message.TradeId) : options.longs === Number ? new $util.LongBits(message.TradeId.low >>> 0, message.TradeId.high >>> 0).toNumber() : message.TradeId;
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                object.FeedSymbol = message.FeedSymbol;
            if (message.Quantity != null && message.hasOwnProperty("Quantity"))
                object.Quantity = message.Quantity;
            if (message.EntryUtc != null && message.hasOwnProperty("EntryUtc"))
                if (typeof message.EntryUtc === "number")
                    object.EntryUtc = options.longs === String ? String(message.EntryUtc) : message.EntryUtc;
                else
                    object.EntryUtc = options.longs === String ? $util.Long.prototype.toString.call(message.EntryUtc) : options.longs === Number ? new $util.LongBits(message.EntryUtc.low >>> 0, message.EntryUtc.high >>> 0).toNumber() : message.EntryUtc;
            if (message.ExitUtc != null && message.hasOwnProperty("ExitUtc"))
                if (typeof message.ExitUtc === "number")
                    object.ExitUtc = options.longs === String ? String(message.ExitUtc) : message.ExitUtc;
                else
                    object.ExitUtc = options.longs === String ? $util.Long.prototype.toString.call(message.ExitUtc) : options.longs === Number ? new $util.LongBits(message.ExitUtc.low >>> 0, message.ExitUtc.high >>> 0).toNumber() : message.ExitUtc;
            if (message.OpenPrice != null && message.hasOwnProperty("OpenPrice"))
                object.OpenPrice = options.json && !isFinite(message.OpenPrice) ? String(message.OpenPrice) : message.OpenPrice;
            if (message.ClosePrice != null && message.hasOwnProperty("ClosePrice"))
                object.ClosePrice = options.json && !isFinite(message.ClosePrice) ? String(message.ClosePrice) : message.ClosePrice;
            if (message.GrossPL != null && message.hasOwnProperty("GrossPL"))
                object.GrossPL = options.json && !isFinite(message.GrossPL) ? String(message.GrossPL) : message.GrossPL;
            if (message.Commissions != null && message.hasOwnProperty("Commissions"))
                object.Commissions = options.json && !isFinite(message.Commissions) ? String(message.Commissions) : message.Commissions;
            if (message.Unaccounted != null && message.hasOwnProperty("Unaccounted"))
                object.Unaccounted = message.Unaccounted;
            if (message.Flags && message.Flags.length) {
                object.Flags = [];
                for (let j = 0; j < message.Flags.length; ++j)
                    object.Flags[j] = options.enums === String ? $root.PropTradingProtocol.TradeReportMsg.Flag[message.Flags[j]] === undefined ? message.Flags[j] : $root.PropTradingProtocol.TradeReportMsg.Flag[message.Flags[j]] : message.Flags[j];
            }
            return object;
        };

        /**
         * Converts this TradeReportMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.TradeReportMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TradeReportMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TradeReportMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.TradeReportMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TradeReportMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.TradeReportMsg";
        };

        /**
         * Flag enum.
         * @name PropTradingProtocol.TradeReportMsg.Flag
         * @enum {number}
         * @property {number} SCALP=1 SCALP value
         * @property {number} CLOSED_TOO_CLOSE_TO_ENTRY=2 CLOSED_TOO_CLOSE_TO_ENTRY value
         * @property {number} TRADING_NEWS=4 TRADING_NEWS value
         */
        TradeReportMsg.Flag = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[1] = "SCALP"] = 1;
            values[valuesById[2] = "CLOSED_TOO_CLOSE_TO_ENTRY"] = 2;
            values[valuesById[4] = "TRADING_NEWS"] = 4;
            return values;
        })();

        return TradeReportMsg;
    })();

    PropTradingProtocol.FillTradeReportMsg = (function() {

        /**
         * Properties of a FillTradeReportMsg.
         * @memberof PropTradingProtocol
         * @interface IFillTradeReportMsg
         * @property {PropTradingProtocol.FillTradeReportMsg.FillTradeTypeEnum|null} [FillType] FillTradeReportMsg FillType
         * @property {number|Long|null} [AccountId] FillTradeReportMsg AccountId
         * @property {number|Long|null} [PositionId] FillTradeReportMsg PositionId
         * @property {number|Long|null} [OrderId] FillTradeReportMsg OrderId
         * @property {number|Long|null} [ContractId] FillTradeReportMsg ContractId
         * @property {string|null} [FeedSymbol] FillTradeReportMsg FeedSymbol
         * @property {number|null} [Quantity] FillTradeReportMsg Quantity
         * @property {number|Long|null} [EntryUtc] FillTradeReportMsg EntryUtc
         * @property {number|Long|null} [ExitUtc] FillTradeReportMsg ExitUtc
         * @property {number|null} [OpenPrice] FillTradeReportMsg OpenPrice
         * @property {number|null} [ClosePrice] FillTradeReportMsg ClosePrice
         * @property {number|null} [ConvertedGrossPL] FillTradeReportMsg ConvertedGrossPL
         * @property {number|null} [ConvertedCommissions] FillTradeReportMsg ConvertedCommissions
         */

        /**
         * Constructs a new FillTradeReportMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a FillTradeReportMsg.
         * @implements IFillTradeReportMsg
         * @constructor
         * @param {PropTradingProtocol.IFillTradeReportMsg=} [properties] Properties to set
         */
        function FillTradeReportMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FillTradeReportMsg FillType.
         * @member {PropTradingProtocol.FillTradeReportMsg.FillTradeTypeEnum} FillType
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @instance
         */
        FillTradeReportMsg.prototype.FillType = 0;

        /**
         * FillTradeReportMsg AccountId.
         * @member {number|Long} AccountId
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @instance
         */
        FillTradeReportMsg.prototype.AccountId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FillTradeReportMsg PositionId.
         * @member {number|Long} PositionId
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @instance
         */
        FillTradeReportMsg.prototype.PositionId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FillTradeReportMsg OrderId.
         * @member {number|Long} OrderId
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @instance
         */
        FillTradeReportMsg.prototype.OrderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FillTradeReportMsg ContractId.
         * @member {number|Long} ContractId
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @instance
         */
        FillTradeReportMsg.prototype.ContractId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FillTradeReportMsg FeedSymbol.
         * @member {string} FeedSymbol
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @instance
         */
        FillTradeReportMsg.prototype.FeedSymbol = "";

        /**
         * FillTradeReportMsg Quantity.
         * @member {number} Quantity
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @instance
         */
        FillTradeReportMsg.prototype.Quantity = 0;

        /**
         * FillTradeReportMsg EntryUtc.
         * @member {number|Long} EntryUtc
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @instance
         */
        FillTradeReportMsg.prototype.EntryUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FillTradeReportMsg ExitUtc.
         * @member {number|Long} ExitUtc
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @instance
         */
        FillTradeReportMsg.prototype.ExitUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FillTradeReportMsg OpenPrice.
         * @member {number} OpenPrice
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @instance
         */
        FillTradeReportMsg.prototype.OpenPrice = 0;

        /**
         * FillTradeReportMsg ClosePrice.
         * @member {number} ClosePrice
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @instance
         */
        FillTradeReportMsg.prototype.ClosePrice = 0;

        /**
         * FillTradeReportMsg ConvertedGrossPL.
         * @member {number} ConvertedGrossPL
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @instance
         */
        FillTradeReportMsg.prototype.ConvertedGrossPL = 0;

        /**
         * FillTradeReportMsg ConvertedCommissions.
         * @member {number} ConvertedCommissions
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @instance
         */
        FillTradeReportMsg.prototype.ConvertedCommissions = 0;

        /**
         * Creates a new FillTradeReportMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @static
         * @param {PropTradingProtocol.IFillTradeReportMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.FillTradeReportMsg} FillTradeReportMsg instance
         */
        FillTradeReportMsg.create = function create(properties) {
            return new FillTradeReportMsg(properties);
        };

        /**
         * Encodes the specified FillTradeReportMsg message. Does not implicitly {@link PropTradingProtocol.FillTradeReportMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @static
         * @param {PropTradingProtocol.IFillTradeReportMsg} message FillTradeReportMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FillTradeReportMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.FillType != null && Object.hasOwnProperty.call(message, "FillType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.FillType);
            if (message.AccountId != null && Object.hasOwnProperty.call(message, "AccountId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccountId);
            if (message.PositionId != null && Object.hasOwnProperty.call(message, "PositionId"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint64(message.PositionId);
            if (message.OrderId != null && Object.hasOwnProperty.call(message, "OrderId"))
                writer.uint32(/* id 4, wireType 0 =*/32).sint64(message.OrderId);
            if (message.ContractId != null && Object.hasOwnProperty.call(message, "ContractId"))
                writer.uint32(/* id 5, wireType 0 =*/40).sint64(message.ContractId);
            if (message.FeedSymbol != null && Object.hasOwnProperty.call(message, "FeedSymbol"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.FeedSymbol);
            if (message.Quantity != null && Object.hasOwnProperty.call(message, "Quantity"))
                writer.uint32(/* id 7, wireType 0 =*/56).sint32(message.Quantity);
            if (message.EntryUtc != null && Object.hasOwnProperty.call(message, "EntryUtc"))
                writer.uint32(/* id 8, wireType 0 =*/64).sint64(message.EntryUtc);
            if (message.ExitUtc != null && Object.hasOwnProperty.call(message, "ExitUtc"))
                writer.uint32(/* id 9, wireType 0 =*/72).sint64(message.ExitUtc);
            if (message.OpenPrice != null && Object.hasOwnProperty.call(message, "OpenPrice"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.OpenPrice);
            if (message.ClosePrice != null && Object.hasOwnProperty.call(message, "ClosePrice"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.ClosePrice);
            if (message.ConvertedGrossPL != null && Object.hasOwnProperty.call(message, "ConvertedGrossPL"))
                writer.uint32(/* id 12, wireType 1 =*/97).double(message.ConvertedGrossPL);
            if (message.ConvertedCommissions != null && Object.hasOwnProperty.call(message, "ConvertedCommissions"))
                writer.uint32(/* id 13, wireType 1 =*/105).double(message.ConvertedCommissions);
            return writer;
        };

        /**
         * Encodes the specified FillTradeReportMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.FillTradeReportMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @static
         * @param {PropTradingProtocol.IFillTradeReportMsg} message FillTradeReportMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FillTradeReportMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FillTradeReportMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.FillTradeReportMsg} FillTradeReportMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FillTradeReportMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.FillTradeReportMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.FillType = reader.int32();
                        break;
                    }
                case 2: {
                        message.AccountId = reader.sint64();
                        break;
                    }
                case 3: {
                        message.PositionId = reader.sint64();
                        break;
                    }
                case 4: {
                        message.OrderId = reader.sint64();
                        break;
                    }
                case 5: {
                        message.ContractId = reader.sint64();
                        break;
                    }
                case 6: {
                        message.FeedSymbol = reader.string();
                        break;
                    }
                case 7: {
                        message.Quantity = reader.sint32();
                        break;
                    }
                case 8: {
                        message.EntryUtc = reader.sint64();
                        break;
                    }
                case 9: {
                        message.ExitUtc = reader.sint64();
                        break;
                    }
                case 10: {
                        message.OpenPrice = reader.double();
                        break;
                    }
                case 11: {
                        message.ClosePrice = reader.double();
                        break;
                    }
                case 12: {
                        message.ConvertedGrossPL = reader.double();
                        break;
                    }
                case 13: {
                        message.ConvertedCommissions = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FillTradeReportMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.FillTradeReportMsg} FillTradeReportMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FillTradeReportMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FillTradeReportMsg message.
         * @function verify
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FillTradeReportMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.FillType != null && message.hasOwnProperty("FillType"))
                switch (message.FillType) {
                default:
                    return "FillType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (!$util.isInteger(message.AccountId) && !(message.AccountId && $util.isInteger(message.AccountId.low) && $util.isInteger(message.AccountId.high)))
                    return "AccountId: integer|Long expected";
            if (message.PositionId != null && message.hasOwnProperty("PositionId"))
                if (!$util.isInteger(message.PositionId) && !(message.PositionId && $util.isInteger(message.PositionId.low) && $util.isInteger(message.PositionId.high)))
                    return "PositionId: integer|Long expected";
            if (message.OrderId != null && message.hasOwnProperty("OrderId"))
                if (!$util.isInteger(message.OrderId) && !(message.OrderId && $util.isInteger(message.OrderId.low) && $util.isInteger(message.OrderId.high)))
                    return "OrderId: integer|Long expected";
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (!$util.isInteger(message.ContractId) && !(message.ContractId && $util.isInteger(message.ContractId.low) && $util.isInteger(message.ContractId.high)))
                    return "ContractId: integer|Long expected";
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                if (!$util.isString(message.FeedSymbol))
                    return "FeedSymbol: string expected";
            if (message.Quantity != null && message.hasOwnProperty("Quantity"))
                if (!$util.isInteger(message.Quantity))
                    return "Quantity: integer expected";
            if (message.EntryUtc != null && message.hasOwnProperty("EntryUtc"))
                if (!$util.isInteger(message.EntryUtc) && !(message.EntryUtc && $util.isInteger(message.EntryUtc.low) && $util.isInteger(message.EntryUtc.high)))
                    return "EntryUtc: integer|Long expected";
            if (message.ExitUtc != null && message.hasOwnProperty("ExitUtc"))
                if (!$util.isInteger(message.ExitUtc) && !(message.ExitUtc && $util.isInteger(message.ExitUtc.low) && $util.isInteger(message.ExitUtc.high)))
                    return "ExitUtc: integer|Long expected";
            if (message.OpenPrice != null && message.hasOwnProperty("OpenPrice"))
                if (typeof message.OpenPrice !== "number")
                    return "OpenPrice: number expected";
            if (message.ClosePrice != null && message.hasOwnProperty("ClosePrice"))
                if (typeof message.ClosePrice !== "number")
                    return "ClosePrice: number expected";
            if (message.ConvertedGrossPL != null && message.hasOwnProperty("ConvertedGrossPL"))
                if (typeof message.ConvertedGrossPL !== "number")
                    return "ConvertedGrossPL: number expected";
            if (message.ConvertedCommissions != null && message.hasOwnProperty("ConvertedCommissions"))
                if (typeof message.ConvertedCommissions !== "number")
                    return "ConvertedCommissions: number expected";
            return null;
        };

        /**
         * Creates a FillTradeReportMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.FillTradeReportMsg} FillTradeReportMsg
         */
        FillTradeReportMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.FillTradeReportMsg)
                return object;
            let message = new $root.PropTradingProtocol.FillTradeReportMsg();
            switch (object.FillType) {
            default:
                if (typeof object.FillType === "number") {
                    message.FillType = object.FillType;
                    break;
                }
                break;
            case "OPEN":
            case 0:
                message.FillType = 0;
                break;
            case "CLOSE":
            case 1:
                message.FillType = 1;
                break;
            }
            if (object.AccountId != null)
                if ($util.Long)
                    (message.AccountId = $util.Long.fromValue(object.AccountId)).unsigned = false;
                else if (typeof object.AccountId === "string")
                    message.AccountId = parseInt(object.AccountId, 10);
                else if (typeof object.AccountId === "number")
                    message.AccountId = object.AccountId;
                else if (typeof object.AccountId === "object")
                    message.AccountId = new $util.LongBits(object.AccountId.low >>> 0, object.AccountId.high >>> 0).toNumber();
            if (object.PositionId != null)
                if ($util.Long)
                    (message.PositionId = $util.Long.fromValue(object.PositionId)).unsigned = false;
                else if (typeof object.PositionId === "string")
                    message.PositionId = parseInt(object.PositionId, 10);
                else if (typeof object.PositionId === "number")
                    message.PositionId = object.PositionId;
                else if (typeof object.PositionId === "object")
                    message.PositionId = new $util.LongBits(object.PositionId.low >>> 0, object.PositionId.high >>> 0).toNumber();
            if (object.OrderId != null)
                if ($util.Long)
                    (message.OrderId = $util.Long.fromValue(object.OrderId)).unsigned = false;
                else if (typeof object.OrderId === "string")
                    message.OrderId = parseInt(object.OrderId, 10);
                else if (typeof object.OrderId === "number")
                    message.OrderId = object.OrderId;
                else if (typeof object.OrderId === "object")
                    message.OrderId = new $util.LongBits(object.OrderId.low >>> 0, object.OrderId.high >>> 0).toNumber();
            if (object.ContractId != null)
                if ($util.Long)
                    (message.ContractId = $util.Long.fromValue(object.ContractId)).unsigned = false;
                else if (typeof object.ContractId === "string")
                    message.ContractId = parseInt(object.ContractId, 10);
                else if (typeof object.ContractId === "number")
                    message.ContractId = object.ContractId;
                else if (typeof object.ContractId === "object")
                    message.ContractId = new $util.LongBits(object.ContractId.low >>> 0, object.ContractId.high >>> 0).toNumber();
            if (object.FeedSymbol != null)
                message.FeedSymbol = String(object.FeedSymbol);
            if (object.Quantity != null)
                message.Quantity = object.Quantity | 0;
            if (object.EntryUtc != null)
                if ($util.Long)
                    (message.EntryUtc = $util.Long.fromValue(object.EntryUtc)).unsigned = false;
                else if (typeof object.EntryUtc === "string")
                    message.EntryUtc = parseInt(object.EntryUtc, 10);
                else if (typeof object.EntryUtc === "number")
                    message.EntryUtc = object.EntryUtc;
                else if (typeof object.EntryUtc === "object")
                    message.EntryUtc = new $util.LongBits(object.EntryUtc.low >>> 0, object.EntryUtc.high >>> 0).toNumber();
            if (object.ExitUtc != null)
                if ($util.Long)
                    (message.ExitUtc = $util.Long.fromValue(object.ExitUtc)).unsigned = false;
                else if (typeof object.ExitUtc === "string")
                    message.ExitUtc = parseInt(object.ExitUtc, 10);
                else if (typeof object.ExitUtc === "number")
                    message.ExitUtc = object.ExitUtc;
                else if (typeof object.ExitUtc === "object")
                    message.ExitUtc = new $util.LongBits(object.ExitUtc.low >>> 0, object.ExitUtc.high >>> 0).toNumber();
            if (object.OpenPrice != null)
                message.OpenPrice = Number(object.OpenPrice);
            if (object.ClosePrice != null)
                message.ClosePrice = Number(object.ClosePrice);
            if (object.ConvertedGrossPL != null)
                message.ConvertedGrossPL = Number(object.ConvertedGrossPL);
            if (object.ConvertedCommissions != null)
                message.ConvertedCommissions = Number(object.ConvertedCommissions);
            return message;
        };

        /**
         * Creates a plain object from a FillTradeReportMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @static
         * @param {PropTradingProtocol.FillTradeReportMsg} message FillTradeReportMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FillTradeReportMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.FillType = options.enums === String ? "OPEN" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccountId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccountId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.PositionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.PositionId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.OrderId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.OrderId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ContractId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ContractId = options.longs === String ? "0" : 0;
                object.FeedSymbol = "";
                object.Quantity = 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.EntryUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.EntryUtc = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ExitUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ExitUtc = options.longs === String ? "0" : 0;
                object.OpenPrice = 0;
                object.ClosePrice = 0;
                object.ConvertedGrossPL = 0;
                object.ConvertedCommissions = 0;
            }
            if (message.FillType != null && message.hasOwnProperty("FillType"))
                object.FillType = options.enums === String ? $root.PropTradingProtocol.FillTradeReportMsg.FillTradeTypeEnum[message.FillType] === undefined ? message.FillType : $root.PropTradingProtocol.FillTradeReportMsg.FillTradeTypeEnum[message.FillType] : message.FillType;
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (typeof message.AccountId === "number")
                    object.AccountId = options.longs === String ? String(message.AccountId) : message.AccountId;
                else
                    object.AccountId = options.longs === String ? $util.Long.prototype.toString.call(message.AccountId) : options.longs === Number ? new $util.LongBits(message.AccountId.low >>> 0, message.AccountId.high >>> 0).toNumber() : message.AccountId;
            if (message.PositionId != null && message.hasOwnProperty("PositionId"))
                if (typeof message.PositionId === "number")
                    object.PositionId = options.longs === String ? String(message.PositionId) : message.PositionId;
                else
                    object.PositionId = options.longs === String ? $util.Long.prototype.toString.call(message.PositionId) : options.longs === Number ? new $util.LongBits(message.PositionId.low >>> 0, message.PositionId.high >>> 0).toNumber() : message.PositionId;
            if (message.OrderId != null && message.hasOwnProperty("OrderId"))
                if (typeof message.OrderId === "number")
                    object.OrderId = options.longs === String ? String(message.OrderId) : message.OrderId;
                else
                    object.OrderId = options.longs === String ? $util.Long.prototype.toString.call(message.OrderId) : options.longs === Number ? new $util.LongBits(message.OrderId.low >>> 0, message.OrderId.high >>> 0).toNumber() : message.OrderId;
            if (message.ContractId != null && message.hasOwnProperty("ContractId"))
                if (typeof message.ContractId === "number")
                    object.ContractId = options.longs === String ? String(message.ContractId) : message.ContractId;
                else
                    object.ContractId = options.longs === String ? $util.Long.prototype.toString.call(message.ContractId) : options.longs === Number ? new $util.LongBits(message.ContractId.low >>> 0, message.ContractId.high >>> 0).toNumber() : message.ContractId;
            if (message.FeedSymbol != null && message.hasOwnProperty("FeedSymbol"))
                object.FeedSymbol = message.FeedSymbol;
            if (message.Quantity != null && message.hasOwnProperty("Quantity"))
                object.Quantity = message.Quantity;
            if (message.EntryUtc != null && message.hasOwnProperty("EntryUtc"))
                if (typeof message.EntryUtc === "number")
                    object.EntryUtc = options.longs === String ? String(message.EntryUtc) : message.EntryUtc;
                else
                    object.EntryUtc = options.longs === String ? $util.Long.prototype.toString.call(message.EntryUtc) : options.longs === Number ? new $util.LongBits(message.EntryUtc.low >>> 0, message.EntryUtc.high >>> 0).toNumber() : message.EntryUtc;
            if (message.ExitUtc != null && message.hasOwnProperty("ExitUtc"))
                if (typeof message.ExitUtc === "number")
                    object.ExitUtc = options.longs === String ? String(message.ExitUtc) : message.ExitUtc;
                else
                    object.ExitUtc = options.longs === String ? $util.Long.prototype.toString.call(message.ExitUtc) : options.longs === Number ? new $util.LongBits(message.ExitUtc.low >>> 0, message.ExitUtc.high >>> 0).toNumber() : message.ExitUtc;
            if (message.OpenPrice != null && message.hasOwnProperty("OpenPrice"))
                object.OpenPrice = options.json && !isFinite(message.OpenPrice) ? String(message.OpenPrice) : message.OpenPrice;
            if (message.ClosePrice != null && message.hasOwnProperty("ClosePrice"))
                object.ClosePrice = options.json && !isFinite(message.ClosePrice) ? String(message.ClosePrice) : message.ClosePrice;
            if (message.ConvertedGrossPL != null && message.hasOwnProperty("ConvertedGrossPL"))
                object.ConvertedGrossPL = options.json && !isFinite(message.ConvertedGrossPL) ? String(message.ConvertedGrossPL) : message.ConvertedGrossPL;
            if (message.ConvertedCommissions != null && message.hasOwnProperty("ConvertedCommissions"))
                object.ConvertedCommissions = options.json && !isFinite(message.ConvertedCommissions) ? String(message.ConvertedCommissions) : message.ConvertedCommissions;
            return object;
        };

        /**
         * Converts this FillTradeReportMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FillTradeReportMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FillTradeReportMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.FillTradeReportMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FillTradeReportMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.FillTradeReportMsg";
        };

        /**
         * FillTradeTypeEnum enum.
         * @name PropTradingProtocol.FillTradeReportMsg.FillTradeTypeEnum
         * @enum {number}
         * @property {number} OPEN=0 OPEN value
         * @property {number} CLOSE=1 CLOSE value
         */
        FillTradeReportMsg.FillTradeTypeEnum = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OPEN"] = 0;
            values[valuesById[1] = "CLOSE"] = 1;
            return values;
        })();

        return FillTradeReportMsg;
    })();

    PropTradingProtocol.UserSessionLogMsg = (function() {

        /**
         * Properties of a UserSessionLogMsg.
         * @memberof PropTradingProtocol
         * @interface IUserSessionLogMsg
         * @property {string|null} [SessionId] UserSessionLogMsg SessionId
         * @property {string|null} [UserId] UserSessionLogMsg UserId
         * @property {number|Long|null} [StartUtc] UserSessionLogMsg StartUtc
         * @property {number|Long|null} [EndUtc] UserSessionLogMsg EndUtc
         * @property {string|null} [Ip] UserSessionLogMsg Ip
         * @property {string|null} [Source] UserSessionLogMsg Source
         * @property {number|Long|null} [ClientSessionId] UserSessionLogMsg ClientSessionId
         */

        /**
         * Constructs a new UserSessionLogMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a UserSessionLogMsg.
         * @implements IUserSessionLogMsg
         * @constructor
         * @param {PropTradingProtocol.IUserSessionLogMsg=} [properties] Properties to set
         */
        function UserSessionLogMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSessionLogMsg SessionId.
         * @member {string} SessionId
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @instance
         */
        UserSessionLogMsg.prototype.SessionId = "";

        /**
         * UserSessionLogMsg UserId.
         * @member {string} UserId
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @instance
         */
        UserSessionLogMsg.prototype.UserId = "";

        /**
         * UserSessionLogMsg StartUtc.
         * @member {number|Long} StartUtc
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @instance
         */
        UserSessionLogMsg.prototype.StartUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserSessionLogMsg EndUtc.
         * @member {number|Long} EndUtc
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @instance
         */
        UserSessionLogMsg.prototype.EndUtc = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * UserSessionLogMsg Ip.
         * @member {string} Ip
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @instance
         */
        UserSessionLogMsg.prototype.Ip = "";

        /**
         * UserSessionLogMsg Source.
         * @member {string} Source
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @instance
         */
        UserSessionLogMsg.prototype.Source = "";

        /**
         * UserSessionLogMsg ClientSessionId.
         * @member {number|Long} ClientSessionId
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @instance
         */
        UserSessionLogMsg.prototype.ClientSessionId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new UserSessionLogMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @static
         * @param {PropTradingProtocol.IUserSessionLogMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.UserSessionLogMsg} UserSessionLogMsg instance
         */
        UserSessionLogMsg.create = function create(properties) {
            return new UserSessionLogMsg(properties);
        };

        /**
         * Encodes the specified UserSessionLogMsg message. Does not implicitly {@link PropTradingProtocol.UserSessionLogMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @static
         * @param {PropTradingProtocol.IUserSessionLogMsg} message UserSessionLogMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSessionLogMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.SessionId != null && Object.hasOwnProperty.call(message, "SessionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.SessionId);
            if (message.UserId != null && Object.hasOwnProperty.call(message, "UserId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.UserId);
            if (message.StartUtc != null && Object.hasOwnProperty.call(message, "StartUtc"))
                writer.uint32(/* id 3, wireType 0 =*/24).sint64(message.StartUtc);
            if (message.EndUtc != null && Object.hasOwnProperty.call(message, "EndUtc"))
                writer.uint32(/* id 4, wireType 0 =*/32).sint64(message.EndUtc);
            if (message.Ip != null && Object.hasOwnProperty.call(message, "Ip"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.Ip);
            if (message.Source != null && Object.hasOwnProperty.call(message, "Source"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.Source);
            if (message.ClientSessionId != null && Object.hasOwnProperty.call(message, "ClientSessionId"))
                writer.uint32(/* id 7, wireType 0 =*/56).sint64(message.ClientSessionId);
            return writer;
        };

        /**
         * Encodes the specified UserSessionLogMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.UserSessionLogMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @static
         * @param {PropTradingProtocol.IUserSessionLogMsg} message UserSessionLogMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSessionLogMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserSessionLogMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.UserSessionLogMsg} UserSessionLogMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSessionLogMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.UserSessionLogMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.SessionId = reader.string();
                        break;
                    }
                case 2: {
                        message.UserId = reader.string();
                        break;
                    }
                case 3: {
                        message.StartUtc = reader.sint64();
                        break;
                    }
                case 4: {
                        message.EndUtc = reader.sint64();
                        break;
                    }
                case 5: {
                        message.Ip = reader.string();
                        break;
                    }
                case 6: {
                        message.Source = reader.string();
                        break;
                    }
                case 7: {
                        message.ClientSessionId = reader.sint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserSessionLogMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.UserSessionLogMsg} UserSessionLogMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSessionLogMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserSessionLogMsg message.
         * @function verify
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserSessionLogMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.SessionId != null && message.hasOwnProperty("SessionId"))
                if (!$util.isString(message.SessionId))
                    return "SessionId: string expected";
            if (message.UserId != null && message.hasOwnProperty("UserId"))
                if (!$util.isString(message.UserId))
                    return "UserId: string expected";
            if (message.StartUtc != null && message.hasOwnProperty("StartUtc"))
                if (!$util.isInteger(message.StartUtc) && !(message.StartUtc && $util.isInteger(message.StartUtc.low) && $util.isInteger(message.StartUtc.high)))
                    return "StartUtc: integer|Long expected";
            if (message.EndUtc != null && message.hasOwnProperty("EndUtc"))
                if (!$util.isInteger(message.EndUtc) && !(message.EndUtc && $util.isInteger(message.EndUtc.low) && $util.isInteger(message.EndUtc.high)))
                    return "EndUtc: integer|Long expected";
            if (message.Ip != null && message.hasOwnProperty("Ip"))
                if (!$util.isString(message.Ip))
                    return "Ip: string expected";
            if (message.Source != null && message.hasOwnProperty("Source"))
                if (!$util.isString(message.Source))
                    return "Source: string expected";
            if (message.ClientSessionId != null && message.hasOwnProperty("ClientSessionId"))
                if (!$util.isInteger(message.ClientSessionId) && !(message.ClientSessionId && $util.isInteger(message.ClientSessionId.low) && $util.isInteger(message.ClientSessionId.high)))
                    return "ClientSessionId: integer|Long expected";
            return null;
        };

        /**
         * Creates a UserSessionLogMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.UserSessionLogMsg} UserSessionLogMsg
         */
        UserSessionLogMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.UserSessionLogMsg)
                return object;
            let message = new $root.PropTradingProtocol.UserSessionLogMsg();
            if (object.SessionId != null)
                message.SessionId = String(object.SessionId);
            if (object.UserId != null)
                message.UserId = String(object.UserId);
            if (object.StartUtc != null)
                if ($util.Long)
                    (message.StartUtc = $util.Long.fromValue(object.StartUtc)).unsigned = false;
                else if (typeof object.StartUtc === "string")
                    message.StartUtc = parseInt(object.StartUtc, 10);
                else if (typeof object.StartUtc === "number")
                    message.StartUtc = object.StartUtc;
                else if (typeof object.StartUtc === "object")
                    message.StartUtc = new $util.LongBits(object.StartUtc.low >>> 0, object.StartUtc.high >>> 0).toNumber();
            if (object.EndUtc != null)
                if ($util.Long)
                    (message.EndUtc = $util.Long.fromValue(object.EndUtc)).unsigned = false;
                else if (typeof object.EndUtc === "string")
                    message.EndUtc = parseInt(object.EndUtc, 10);
                else if (typeof object.EndUtc === "number")
                    message.EndUtc = object.EndUtc;
                else if (typeof object.EndUtc === "object")
                    message.EndUtc = new $util.LongBits(object.EndUtc.low >>> 0, object.EndUtc.high >>> 0).toNumber();
            if (object.Ip != null)
                message.Ip = String(object.Ip);
            if (object.Source != null)
                message.Source = String(object.Source);
            if (object.ClientSessionId != null)
                if ($util.Long)
                    (message.ClientSessionId = $util.Long.fromValue(object.ClientSessionId)).unsigned = false;
                else if (typeof object.ClientSessionId === "string")
                    message.ClientSessionId = parseInt(object.ClientSessionId, 10);
                else if (typeof object.ClientSessionId === "number")
                    message.ClientSessionId = object.ClientSessionId;
                else if (typeof object.ClientSessionId === "object")
                    message.ClientSessionId = new $util.LongBits(object.ClientSessionId.low >>> 0, object.ClientSessionId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a UserSessionLogMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @static
         * @param {PropTradingProtocol.UserSessionLogMsg} message UserSessionLogMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserSessionLogMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.SessionId = "";
                object.UserId = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.StartUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.StartUtc = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.EndUtc = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.EndUtc = options.longs === String ? "0" : 0;
                object.Ip = "";
                object.Source = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.ClientSessionId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.ClientSessionId = options.longs === String ? "0" : 0;
            }
            if (message.SessionId != null && message.hasOwnProperty("SessionId"))
                object.SessionId = message.SessionId;
            if (message.UserId != null && message.hasOwnProperty("UserId"))
                object.UserId = message.UserId;
            if (message.StartUtc != null && message.hasOwnProperty("StartUtc"))
                if (typeof message.StartUtc === "number")
                    object.StartUtc = options.longs === String ? String(message.StartUtc) : message.StartUtc;
                else
                    object.StartUtc = options.longs === String ? $util.Long.prototype.toString.call(message.StartUtc) : options.longs === Number ? new $util.LongBits(message.StartUtc.low >>> 0, message.StartUtc.high >>> 0).toNumber() : message.StartUtc;
            if (message.EndUtc != null && message.hasOwnProperty("EndUtc"))
                if (typeof message.EndUtc === "number")
                    object.EndUtc = options.longs === String ? String(message.EndUtc) : message.EndUtc;
                else
                    object.EndUtc = options.longs === String ? $util.Long.prototype.toString.call(message.EndUtc) : options.longs === Number ? new $util.LongBits(message.EndUtc.low >>> 0, message.EndUtc.high >>> 0).toNumber() : message.EndUtc;
            if (message.Ip != null && message.hasOwnProperty("Ip"))
                object.Ip = message.Ip;
            if (message.Source != null && message.hasOwnProperty("Source"))
                object.Source = message.Source;
            if (message.ClientSessionId != null && message.hasOwnProperty("ClientSessionId"))
                if (typeof message.ClientSessionId === "number")
                    object.ClientSessionId = options.longs === String ? String(message.ClientSessionId) : message.ClientSessionId;
                else
                    object.ClientSessionId = options.longs === String ? $util.Long.prototype.toString.call(message.ClientSessionId) : options.longs === Number ? new $util.LongBits(message.ClientSessionId.low >>> 0, message.ClientSessionId.high >>> 0).toNumber() : message.ClientSessionId;
            return object;
        };

        /**
         * Converts this UserSessionLogMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserSessionLogMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserSessionLogMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.UserSessionLogMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserSessionLogMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.UserSessionLogMsg";
        };

        return UserSessionLogMsg;
    })();

    /**
     * SubscribeModeEnum enum.
     * @name PropTradingProtocol.SubscribeModeEnum
     * @enum {number}
     * @property {number} SNAPSHOT=0 SNAPSHOT value
     * @property {number} SUBSCRIBE=1 SUBSCRIBE value
     * @property {number} UNSUBSCRIBE=2 UNSUBSCRIBE value
     */
    PropTradingProtocol.SubscribeModeEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SNAPSHOT"] = 0;
        values[valuesById[1] = "SUBSCRIBE"] = 1;
        values[valuesById[2] = "UNSUBSCRIBE"] = 2;
        return values;
    })();

    PropTradingProtocol.CurrencyRatesReqMsg = (function() {

        /**
         * Properties of a CurrencyRatesReqMsg.
         * @memberof PropTradingProtocol
         * @interface ICurrencyRatesReqMsg
         * @property {PropTradingProtocol.SubscribeModeEnum|null} [Mode] CurrencyRatesReqMsg Mode
         */

        /**
         * Constructs a new CurrencyRatesReqMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a CurrencyRatesReqMsg.
         * @implements ICurrencyRatesReqMsg
         * @constructor
         * @param {PropTradingProtocol.ICurrencyRatesReqMsg=} [properties] Properties to set
         */
        function CurrencyRatesReqMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CurrencyRatesReqMsg Mode.
         * @member {PropTradingProtocol.SubscribeModeEnum} Mode
         * @memberof PropTradingProtocol.CurrencyRatesReqMsg
         * @instance
         */
        CurrencyRatesReqMsg.prototype.Mode = 0;

        /**
         * Creates a new CurrencyRatesReqMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.CurrencyRatesReqMsg
         * @static
         * @param {PropTradingProtocol.ICurrencyRatesReqMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.CurrencyRatesReqMsg} CurrencyRatesReqMsg instance
         */
        CurrencyRatesReqMsg.create = function create(properties) {
            return new CurrencyRatesReqMsg(properties);
        };

        /**
         * Encodes the specified CurrencyRatesReqMsg message. Does not implicitly {@link PropTradingProtocol.CurrencyRatesReqMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.CurrencyRatesReqMsg
         * @static
         * @param {PropTradingProtocol.ICurrencyRatesReqMsg} message CurrencyRatesReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CurrencyRatesReqMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Mode != null && Object.hasOwnProperty.call(message, "Mode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Mode);
            return writer;
        };

        /**
         * Encodes the specified CurrencyRatesReqMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.CurrencyRatesReqMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.CurrencyRatesReqMsg
         * @static
         * @param {PropTradingProtocol.ICurrencyRatesReqMsg} message CurrencyRatesReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CurrencyRatesReqMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CurrencyRatesReqMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.CurrencyRatesReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.CurrencyRatesReqMsg} CurrencyRatesReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CurrencyRatesReqMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.CurrencyRatesReqMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.Mode = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CurrencyRatesReqMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.CurrencyRatesReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.CurrencyRatesReqMsg} CurrencyRatesReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CurrencyRatesReqMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CurrencyRatesReqMsg message.
         * @function verify
         * @memberof PropTradingProtocol.CurrencyRatesReqMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CurrencyRatesReqMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Mode != null && message.hasOwnProperty("Mode"))
                switch (message.Mode) {
                default:
                    return "Mode: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a CurrencyRatesReqMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.CurrencyRatesReqMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.CurrencyRatesReqMsg} CurrencyRatesReqMsg
         */
        CurrencyRatesReqMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.CurrencyRatesReqMsg)
                return object;
            let message = new $root.PropTradingProtocol.CurrencyRatesReqMsg();
            switch (object.Mode) {
            default:
                if (typeof object.Mode === "number") {
                    message.Mode = object.Mode;
                    break;
                }
                break;
            case "SNAPSHOT":
            case 0:
                message.Mode = 0;
                break;
            case "SUBSCRIBE":
            case 1:
                message.Mode = 1;
                break;
            case "UNSUBSCRIBE":
            case 2:
                message.Mode = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a CurrencyRatesReqMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.CurrencyRatesReqMsg
         * @static
         * @param {PropTradingProtocol.CurrencyRatesReqMsg} message CurrencyRatesReqMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CurrencyRatesReqMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.Mode = options.enums === String ? "SNAPSHOT" : 0;
            if (message.Mode != null && message.hasOwnProperty("Mode"))
                object.Mode = options.enums === String ? $root.PropTradingProtocol.SubscribeModeEnum[message.Mode] === undefined ? message.Mode : $root.PropTradingProtocol.SubscribeModeEnum[message.Mode] : message.Mode;
            return object;
        };

        /**
         * Converts this CurrencyRatesReqMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.CurrencyRatesReqMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CurrencyRatesReqMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CurrencyRatesReqMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.CurrencyRatesReqMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CurrencyRatesReqMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.CurrencyRatesReqMsg";
        };

        return CurrencyRatesReqMsg;
    })();

    PropTradingProtocol.CurrencyRateInfoMsg = (function() {

        /**
         * Properties of a CurrencyRateInfoMsg.
         * @memberof PropTradingProtocol
         * @interface ICurrencyRateInfoMsg
         * @property {string|null} [BaseCurrency] CurrencyRateInfoMsg BaseCurrency
         * @property {string|null} [QuoteCurrency] CurrencyRateInfoMsg QuoteCurrency
         * @property {number|null} [Rate] CurrencyRateInfoMsg Rate
         */

        /**
         * Constructs a new CurrencyRateInfoMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents a CurrencyRateInfoMsg.
         * @implements ICurrencyRateInfoMsg
         * @constructor
         * @param {PropTradingProtocol.ICurrencyRateInfoMsg=} [properties] Properties to set
         */
        function CurrencyRateInfoMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CurrencyRateInfoMsg BaseCurrency.
         * @member {string} BaseCurrency
         * @memberof PropTradingProtocol.CurrencyRateInfoMsg
         * @instance
         */
        CurrencyRateInfoMsg.prototype.BaseCurrency = "";

        /**
         * CurrencyRateInfoMsg QuoteCurrency.
         * @member {string} QuoteCurrency
         * @memberof PropTradingProtocol.CurrencyRateInfoMsg
         * @instance
         */
        CurrencyRateInfoMsg.prototype.QuoteCurrency = "";

        /**
         * CurrencyRateInfoMsg Rate.
         * @member {number} Rate
         * @memberof PropTradingProtocol.CurrencyRateInfoMsg
         * @instance
         */
        CurrencyRateInfoMsg.prototype.Rate = 0;

        /**
         * Creates a new CurrencyRateInfoMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.CurrencyRateInfoMsg
         * @static
         * @param {PropTradingProtocol.ICurrencyRateInfoMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.CurrencyRateInfoMsg} CurrencyRateInfoMsg instance
         */
        CurrencyRateInfoMsg.create = function create(properties) {
            return new CurrencyRateInfoMsg(properties);
        };

        /**
         * Encodes the specified CurrencyRateInfoMsg message. Does not implicitly {@link PropTradingProtocol.CurrencyRateInfoMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.CurrencyRateInfoMsg
         * @static
         * @param {PropTradingProtocol.ICurrencyRateInfoMsg} message CurrencyRateInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CurrencyRateInfoMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.BaseCurrency != null && Object.hasOwnProperty.call(message, "BaseCurrency"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.BaseCurrency);
            if (message.QuoteCurrency != null && Object.hasOwnProperty.call(message, "QuoteCurrency"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.QuoteCurrency);
            if (message.Rate != null && Object.hasOwnProperty.call(message, "Rate"))
                writer.uint32(/* id 3, wireType 1 =*/25).double(message.Rate);
            return writer;
        };

        /**
         * Encodes the specified CurrencyRateInfoMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.CurrencyRateInfoMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.CurrencyRateInfoMsg
         * @static
         * @param {PropTradingProtocol.ICurrencyRateInfoMsg} message CurrencyRateInfoMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CurrencyRateInfoMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CurrencyRateInfoMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.CurrencyRateInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.CurrencyRateInfoMsg} CurrencyRateInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CurrencyRateInfoMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.CurrencyRateInfoMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.BaseCurrency = reader.string();
                        break;
                    }
                case 2: {
                        message.QuoteCurrency = reader.string();
                        break;
                    }
                case 3: {
                        message.Rate = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CurrencyRateInfoMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.CurrencyRateInfoMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.CurrencyRateInfoMsg} CurrencyRateInfoMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CurrencyRateInfoMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CurrencyRateInfoMsg message.
         * @function verify
         * @memberof PropTradingProtocol.CurrencyRateInfoMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CurrencyRateInfoMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.BaseCurrency != null && message.hasOwnProperty("BaseCurrency"))
                if (!$util.isString(message.BaseCurrency))
                    return "BaseCurrency: string expected";
            if (message.QuoteCurrency != null && message.hasOwnProperty("QuoteCurrency"))
                if (!$util.isString(message.QuoteCurrency))
                    return "QuoteCurrency: string expected";
            if (message.Rate != null && message.hasOwnProperty("Rate"))
                if (typeof message.Rate !== "number")
                    return "Rate: number expected";
            return null;
        };

        /**
         * Creates a CurrencyRateInfoMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.CurrencyRateInfoMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.CurrencyRateInfoMsg} CurrencyRateInfoMsg
         */
        CurrencyRateInfoMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.CurrencyRateInfoMsg)
                return object;
            let message = new $root.PropTradingProtocol.CurrencyRateInfoMsg();
            if (object.BaseCurrency != null)
                message.BaseCurrency = String(object.BaseCurrency);
            if (object.QuoteCurrency != null)
                message.QuoteCurrency = String(object.QuoteCurrency);
            if (object.Rate != null)
                message.Rate = Number(object.Rate);
            return message;
        };

        /**
         * Creates a plain object from a CurrencyRateInfoMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.CurrencyRateInfoMsg
         * @static
         * @param {PropTradingProtocol.CurrencyRateInfoMsg} message CurrencyRateInfoMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CurrencyRateInfoMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.BaseCurrency = "";
                object.QuoteCurrency = "";
                object.Rate = 0;
            }
            if (message.BaseCurrency != null && message.hasOwnProperty("BaseCurrency"))
                object.BaseCurrency = message.BaseCurrency;
            if (message.QuoteCurrency != null && message.hasOwnProperty("QuoteCurrency"))
                object.QuoteCurrency = message.QuoteCurrency;
            if (message.Rate != null && message.hasOwnProperty("Rate"))
                object.Rate = options.json && !isFinite(message.Rate) ? String(message.Rate) : message.Rate;
            return object;
        };

        /**
         * Converts this CurrencyRateInfoMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.CurrencyRateInfoMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CurrencyRateInfoMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CurrencyRateInfoMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.CurrencyRateInfoMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CurrencyRateInfoMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.CurrencyRateInfoMsg";
        };

        return CurrencyRateInfoMsg;
    })();

    /**
     * LoginReasonsCodeEnum enum.
     * @name PropTradingProtocol.LoginReasonsCodeEnum
     * @enum {number}
     * @property {number} CREDENTIALS=0 CREDENTIALS value
     * @property {number} CONCURRENT_SESSION=1 CONCURRENT_SESSION value
     * @property {number} UNEXPECTED_ERROR=2 UNEXPECTED_ERROR value
     */
    PropTradingProtocol.LoginReasonsCodeEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CREDENTIALS"] = 0;
        values[valuesById[1] = "CONCURRENT_SESSION"] = 1;
        values[valuesById[2] = "UNEXPECTED_ERROR"] = 2;
        return values;
    })();

    /**
     * RiskUserLossModeEnum enum.
     * @name PropTradingProtocol.RiskUserLossModeEnum
     * @enum {number}
     * @property {number} TrailingMaxBalance=0 TrailingMaxBalance value
     * @property {number} StaticStartBalance=1 StaticStartBalance value
     * @property {number} TrailingMaxEquity=2 TrailingMaxEquity value
     * @property {number} StaticStartEquity=3 StaticStartEquity value
     * @property {number} StaticMininmumStartEquityBalance=4 StaticMininmumStartEquityBalance value
     */
    PropTradingProtocol.RiskUserLossModeEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "TrailingMaxBalance"] = 0;
        values[valuesById[1] = "StaticStartBalance"] = 1;
        values[valuesById[2] = "TrailingMaxEquity"] = 2;
        values[valuesById[3] = "StaticStartEquity"] = 3;
        values[valuesById[4] = "StaticMininmumStartEquityBalance"] = 4;
        return values;
    })();

    /**
     * RiskUserTargetModeEnum enum.
     * @name PropTradingProtocol.RiskUserTargetModeEnum
     * @enum {number}
     * @property {number} Balance=0 Balance value
     * @property {number} Equity=1 Equity value
     */
    PropTradingProtocol.RiskUserTargetModeEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Balance"] = 0;
        values[valuesById[1] = "Equity"] = 1;
        return values;
    })();

    PropTradingProtocol.AccountUserRiskRule = (function() {

        /**
         * Properties of an AccountUserRiskRule.
         * @memberof PropTradingProtocol
         * @interface IAccountUserRiskRule
         * @property {number|Long|null} [AccountId] AccountUserRiskRule AccountId
         * @property {boolean|null} [IsScheduled] AccountUserRiskRule IsScheduled
         * @property {boolean|null} [SetAsDefaultForAccountTradingRule] AccountUserRiskRule SetAsDefaultForAccountTradingRule
         * @property {boolean|null} [InhibitChangesUntilNextSession] AccountUserRiskRule InhibitChangesUntilNextSession
         * @property {boolean|null} [DailyLossLimitEnabled] AccountUserRiskRule DailyLossLimitEnabled
         * @property {PropTradingProtocol.RiskUserLossModeEnum|null} [DailyLossLimitMode] AccountUserRiskRule DailyLossLimitMode
         * @property {number|null} [DailyLossLimitValue] AccountUserRiskRule DailyLossLimitValue
         * @property {number|null} [DailyLossLimitPercentage] AccountUserRiskRule DailyLossLimitPercentage
         * @property {boolean|null} [DailyProfitLimitEnabled] AccountUserRiskRule DailyProfitLimitEnabled
         * @property {PropTradingProtocol.RiskUserTargetModeEnum|null} [DailyProfitLimitMode] AccountUserRiskRule DailyProfitLimitMode
         * @property {number|null} [DailyProfitLimitValue] AccountUserRiskRule DailyProfitLimitValue
         * @property {number|null} [DailyProfitLimitPercentage] AccountUserRiskRule DailyProfitLimitPercentage
         * @property {boolean|null} [WeeklyLossLimitEnabled] AccountUserRiskRule WeeklyLossLimitEnabled
         * @property {PropTradingProtocol.RiskUserLossModeEnum|null} [WeeklyLossLimitMode] AccountUserRiskRule WeeklyLossLimitMode
         * @property {number|null} [WeeklyLossLimitValue] AccountUserRiskRule WeeklyLossLimitValue
         * @property {number|null} [WeeklyLossLimitPercentage] AccountUserRiskRule WeeklyLossLimitPercentage
         * @property {boolean|null} [WeeklyProfitLimitEnabled] AccountUserRiskRule WeeklyProfitLimitEnabled
         * @property {PropTradingProtocol.RiskUserTargetModeEnum|null} [WeeklyProfitLimitMode] AccountUserRiskRule WeeklyProfitLimitMode
         * @property {number|null} [WeeklyProfitLimitValue] AccountUserRiskRule WeeklyProfitLimitValue
         * @property {number|null} [WeeklyProfitLimitPercentage] AccountUserRiskRule WeeklyProfitLimitPercentage
         */

        /**
         * Constructs a new AccountUserRiskRule.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountUserRiskRule.
         * @implements IAccountUserRiskRule
         * @constructor
         * @param {PropTradingProtocol.IAccountUserRiskRule=} [properties] Properties to set
         */
        function AccountUserRiskRule(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountUserRiskRule AccountId.
         * @member {number|Long} AccountId
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.AccountId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountUserRiskRule IsScheduled.
         * @member {boolean} IsScheduled
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.IsScheduled = false;

        /**
         * AccountUserRiskRule SetAsDefaultForAccountTradingRule.
         * @member {boolean} SetAsDefaultForAccountTradingRule
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.SetAsDefaultForAccountTradingRule = false;

        /**
         * AccountUserRiskRule InhibitChangesUntilNextSession.
         * @member {boolean} InhibitChangesUntilNextSession
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.InhibitChangesUntilNextSession = false;

        /**
         * AccountUserRiskRule DailyLossLimitEnabled.
         * @member {boolean} DailyLossLimitEnabled
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.DailyLossLimitEnabled = false;

        /**
         * AccountUserRiskRule DailyLossLimitMode.
         * @member {PropTradingProtocol.RiskUserLossModeEnum} DailyLossLimitMode
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.DailyLossLimitMode = 0;

        /**
         * AccountUserRiskRule DailyLossLimitValue.
         * @member {number} DailyLossLimitValue
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.DailyLossLimitValue = 0;

        /**
         * AccountUserRiskRule DailyLossLimitPercentage.
         * @member {number} DailyLossLimitPercentage
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.DailyLossLimitPercentage = 0;

        /**
         * AccountUserRiskRule DailyProfitLimitEnabled.
         * @member {boolean} DailyProfitLimitEnabled
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.DailyProfitLimitEnabled = false;

        /**
         * AccountUserRiskRule DailyProfitLimitMode.
         * @member {PropTradingProtocol.RiskUserTargetModeEnum} DailyProfitLimitMode
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.DailyProfitLimitMode = 0;

        /**
         * AccountUserRiskRule DailyProfitLimitValue.
         * @member {number} DailyProfitLimitValue
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.DailyProfitLimitValue = 0;

        /**
         * AccountUserRiskRule DailyProfitLimitPercentage.
         * @member {number} DailyProfitLimitPercentage
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.DailyProfitLimitPercentage = 0;

        /**
         * AccountUserRiskRule WeeklyLossLimitEnabled.
         * @member {boolean} WeeklyLossLimitEnabled
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.WeeklyLossLimitEnabled = false;

        /**
         * AccountUserRiskRule WeeklyLossLimitMode.
         * @member {PropTradingProtocol.RiskUserLossModeEnum} WeeklyLossLimitMode
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.WeeklyLossLimitMode = 0;

        /**
         * AccountUserRiskRule WeeklyLossLimitValue.
         * @member {number} WeeklyLossLimitValue
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.WeeklyLossLimitValue = 0;

        /**
         * AccountUserRiskRule WeeklyLossLimitPercentage.
         * @member {number} WeeklyLossLimitPercentage
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.WeeklyLossLimitPercentage = 0;

        /**
         * AccountUserRiskRule WeeklyProfitLimitEnabled.
         * @member {boolean} WeeklyProfitLimitEnabled
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.WeeklyProfitLimitEnabled = false;

        /**
         * AccountUserRiskRule WeeklyProfitLimitMode.
         * @member {PropTradingProtocol.RiskUserTargetModeEnum} WeeklyProfitLimitMode
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.WeeklyProfitLimitMode = 0;

        /**
         * AccountUserRiskRule WeeklyProfitLimitValue.
         * @member {number} WeeklyProfitLimitValue
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.WeeklyProfitLimitValue = 0;

        /**
         * AccountUserRiskRule WeeklyProfitLimitPercentage.
         * @member {number} WeeklyProfitLimitPercentage
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         */
        AccountUserRiskRule.prototype.WeeklyProfitLimitPercentage = 0;

        /**
         * Creates a new AccountUserRiskRule instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @static
         * @param {PropTradingProtocol.IAccountUserRiskRule=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountUserRiskRule} AccountUserRiskRule instance
         */
        AccountUserRiskRule.create = function create(properties) {
            return new AccountUserRiskRule(properties);
        };

        /**
         * Encodes the specified AccountUserRiskRule message. Does not implicitly {@link PropTradingProtocol.AccountUserRiskRule.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @static
         * @param {PropTradingProtocol.IAccountUserRiskRule} message AccountUserRiskRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserRiskRule.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AccountId != null && Object.hasOwnProperty.call(message, "AccountId"))
                writer.uint32(/* id 4, wireType 0 =*/32).sint64(message.AccountId);
            if (message.IsScheduled != null && Object.hasOwnProperty.call(message, "IsScheduled"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.IsScheduled);
            if (message.SetAsDefaultForAccountTradingRule != null && Object.hasOwnProperty.call(message, "SetAsDefaultForAccountTradingRule"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.SetAsDefaultForAccountTradingRule);
            if (message.InhibitChangesUntilNextSession != null && Object.hasOwnProperty.call(message, "InhibitChangesUntilNextSession"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.InhibitChangesUntilNextSession);
            if (message.DailyLossLimitEnabled != null && Object.hasOwnProperty.call(message, "DailyLossLimitEnabled"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.DailyLossLimitEnabled);
            if (message.DailyLossLimitMode != null && Object.hasOwnProperty.call(message, "DailyLossLimitMode"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.DailyLossLimitMode);
            if (message.DailyLossLimitValue != null && Object.hasOwnProperty.call(message, "DailyLossLimitValue"))
                writer.uint32(/* id 10, wireType 1 =*/81).double(message.DailyLossLimitValue);
            if (message.DailyLossLimitPercentage != null && Object.hasOwnProperty.call(message, "DailyLossLimitPercentage"))
                writer.uint32(/* id 11, wireType 1 =*/89).double(message.DailyLossLimitPercentage);
            if (message.DailyProfitLimitEnabled != null && Object.hasOwnProperty.call(message, "DailyProfitLimitEnabled"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.DailyProfitLimitEnabled);
            if (message.DailyProfitLimitMode != null && Object.hasOwnProperty.call(message, "DailyProfitLimitMode"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.DailyProfitLimitMode);
            if (message.DailyProfitLimitValue != null && Object.hasOwnProperty.call(message, "DailyProfitLimitValue"))
                writer.uint32(/* id 14, wireType 1 =*/113).double(message.DailyProfitLimitValue);
            if (message.DailyProfitLimitPercentage != null && Object.hasOwnProperty.call(message, "DailyProfitLimitPercentage"))
                writer.uint32(/* id 15, wireType 1 =*/121).double(message.DailyProfitLimitPercentage);
            if (message.WeeklyLossLimitEnabled != null && Object.hasOwnProperty.call(message, "WeeklyLossLimitEnabled"))
                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.WeeklyLossLimitEnabled);
            if (message.WeeklyLossLimitMode != null && Object.hasOwnProperty.call(message, "WeeklyLossLimitMode"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.WeeklyLossLimitMode);
            if (message.WeeklyLossLimitValue != null && Object.hasOwnProperty.call(message, "WeeklyLossLimitValue"))
                writer.uint32(/* id 18, wireType 1 =*/145).double(message.WeeklyLossLimitValue);
            if (message.WeeklyLossLimitPercentage != null && Object.hasOwnProperty.call(message, "WeeklyLossLimitPercentage"))
                writer.uint32(/* id 19, wireType 1 =*/153).double(message.WeeklyLossLimitPercentage);
            if (message.WeeklyProfitLimitEnabled != null && Object.hasOwnProperty.call(message, "WeeklyProfitLimitEnabled"))
                writer.uint32(/* id 20, wireType 0 =*/160).bool(message.WeeklyProfitLimitEnabled);
            if (message.WeeklyProfitLimitMode != null && Object.hasOwnProperty.call(message, "WeeklyProfitLimitMode"))
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.WeeklyProfitLimitMode);
            if (message.WeeklyProfitLimitValue != null && Object.hasOwnProperty.call(message, "WeeklyProfitLimitValue"))
                writer.uint32(/* id 22, wireType 1 =*/177).double(message.WeeklyProfitLimitValue);
            if (message.WeeklyProfitLimitPercentage != null && Object.hasOwnProperty.call(message, "WeeklyProfitLimitPercentage"))
                writer.uint32(/* id 23, wireType 1 =*/185).double(message.WeeklyProfitLimitPercentage);
            return writer;
        };

        /**
         * Encodes the specified AccountUserRiskRule message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountUserRiskRule.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @static
         * @param {PropTradingProtocol.IAccountUserRiskRule} message AccountUserRiskRule message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserRiskRule.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountUserRiskRule message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountUserRiskRule} AccountUserRiskRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserRiskRule.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountUserRiskRule();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 4: {
                        message.AccountId = reader.sint64();
                        break;
                    }
                case 5: {
                        message.IsScheduled = reader.bool();
                        break;
                    }
                case 6: {
                        message.SetAsDefaultForAccountTradingRule = reader.bool();
                        break;
                    }
                case 7: {
                        message.InhibitChangesUntilNextSession = reader.bool();
                        break;
                    }
                case 8: {
                        message.DailyLossLimitEnabled = reader.bool();
                        break;
                    }
                case 9: {
                        message.DailyLossLimitMode = reader.int32();
                        break;
                    }
                case 10: {
                        message.DailyLossLimitValue = reader.double();
                        break;
                    }
                case 11: {
                        message.DailyLossLimitPercentage = reader.double();
                        break;
                    }
                case 12: {
                        message.DailyProfitLimitEnabled = reader.bool();
                        break;
                    }
                case 13: {
                        message.DailyProfitLimitMode = reader.int32();
                        break;
                    }
                case 14: {
                        message.DailyProfitLimitValue = reader.double();
                        break;
                    }
                case 15: {
                        message.DailyProfitLimitPercentage = reader.double();
                        break;
                    }
                case 16: {
                        message.WeeklyLossLimitEnabled = reader.bool();
                        break;
                    }
                case 17: {
                        message.WeeklyLossLimitMode = reader.int32();
                        break;
                    }
                case 18: {
                        message.WeeklyLossLimitValue = reader.double();
                        break;
                    }
                case 19: {
                        message.WeeklyLossLimitPercentage = reader.double();
                        break;
                    }
                case 20: {
                        message.WeeklyProfitLimitEnabled = reader.bool();
                        break;
                    }
                case 21: {
                        message.WeeklyProfitLimitMode = reader.int32();
                        break;
                    }
                case 22: {
                        message.WeeklyProfitLimitValue = reader.double();
                        break;
                    }
                case 23: {
                        message.WeeklyProfitLimitPercentage = reader.double();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountUserRiskRule message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountUserRiskRule} AccountUserRiskRule
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserRiskRule.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountUserRiskRule message.
         * @function verify
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountUserRiskRule.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (!$util.isInteger(message.AccountId) && !(message.AccountId && $util.isInteger(message.AccountId.low) && $util.isInteger(message.AccountId.high)))
                    return "AccountId: integer|Long expected";
            if (message.IsScheduled != null && message.hasOwnProperty("IsScheduled"))
                if (typeof message.IsScheduled !== "boolean")
                    return "IsScheduled: boolean expected";
            if (message.SetAsDefaultForAccountTradingRule != null && message.hasOwnProperty("SetAsDefaultForAccountTradingRule"))
                if (typeof message.SetAsDefaultForAccountTradingRule !== "boolean")
                    return "SetAsDefaultForAccountTradingRule: boolean expected";
            if (message.InhibitChangesUntilNextSession != null && message.hasOwnProperty("InhibitChangesUntilNextSession"))
                if (typeof message.InhibitChangesUntilNextSession !== "boolean")
                    return "InhibitChangesUntilNextSession: boolean expected";
            if (message.DailyLossLimitEnabled != null && message.hasOwnProperty("DailyLossLimitEnabled"))
                if (typeof message.DailyLossLimitEnabled !== "boolean")
                    return "DailyLossLimitEnabled: boolean expected";
            if (message.DailyLossLimitMode != null && message.hasOwnProperty("DailyLossLimitMode"))
                switch (message.DailyLossLimitMode) {
                default:
                    return "DailyLossLimitMode: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.DailyLossLimitValue != null && message.hasOwnProperty("DailyLossLimitValue"))
                if (typeof message.DailyLossLimitValue !== "number")
                    return "DailyLossLimitValue: number expected";
            if (message.DailyLossLimitPercentage != null && message.hasOwnProperty("DailyLossLimitPercentage"))
                if (typeof message.DailyLossLimitPercentage !== "number")
                    return "DailyLossLimitPercentage: number expected";
            if (message.DailyProfitLimitEnabled != null && message.hasOwnProperty("DailyProfitLimitEnabled"))
                if (typeof message.DailyProfitLimitEnabled !== "boolean")
                    return "DailyProfitLimitEnabled: boolean expected";
            if (message.DailyProfitLimitMode != null && message.hasOwnProperty("DailyProfitLimitMode"))
                switch (message.DailyProfitLimitMode) {
                default:
                    return "DailyProfitLimitMode: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.DailyProfitLimitValue != null && message.hasOwnProperty("DailyProfitLimitValue"))
                if (typeof message.DailyProfitLimitValue !== "number")
                    return "DailyProfitLimitValue: number expected";
            if (message.DailyProfitLimitPercentage != null && message.hasOwnProperty("DailyProfitLimitPercentage"))
                if (typeof message.DailyProfitLimitPercentage !== "number")
                    return "DailyProfitLimitPercentage: number expected";
            if (message.WeeklyLossLimitEnabled != null && message.hasOwnProperty("WeeklyLossLimitEnabled"))
                if (typeof message.WeeklyLossLimitEnabled !== "boolean")
                    return "WeeklyLossLimitEnabled: boolean expected";
            if (message.WeeklyLossLimitMode != null && message.hasOwnProperty("WeeklyLossLimitMode"))
                switch (message.WeeklyLossLimitMode) {
                default:
                    return "WeeklyLossLimitMode: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.WeeklyLossLimitValue != null && message.hasOwnProperty("WeeklyLossLimitValue"))
                if (typeof message.WeeklyLossLimitValue !== "number")
                    return "WeeklyLossLimitValue: number expected";
            if (message.WeeklyLossLimitPercentage != null && message.hasOwnProperty("WeeklyLossLimitPercentage"))
                if (typeof message.WeeklyLossLimitPercentage !== "number")
                    return "WeeklyLossLimitPercentage: number expected";
            if (message.WeeklyProfitLimitEnabled != null && message.hasOwnProperty("WeeklyProfitLimitEnabled"))
                if (typeof message.WeeklyProfitLimitEnabled !== "boolean")
                    return "WeeklyProfitLimitEnabled: boolean expected";
            if (message.WeeklyProfitLimitMode != null && message.hasOwnProperty("WeeklyProfitLimitMode"))
                switch (message.WeeklyProfitLimitMode) {
                default:
                    return "WeeklyProfitLimitMode: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.WeeklyProfitLimitValue != null && message.hasOwnProperty("WeeklyProfitLimitValue"))
                if (typeof message.WeeklyProfitLimitValue !== "number")
                    return "WeeklyProfitLimitValue: number expected";
            if (message.WeeklyProfitLimitPercentage != null && message.hasOwnProperty("WeeklyProfitLimitPercentage"))
                if (typeof message.WeeklyProfitLimitPercentage !== "number")
                    return "WeeklyProfitLimitPercentage: number expected";
            return null;
        };

        /**
         * Creates an AccountUserRiskRule message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountUserRiskRule} AccountUserRiskRule
         */
        AccountUserRiskRule.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountUserRiskRule)
                return object;
            let message = new $root.PropTradingProtocol.AccountUserRiskRule();
            if (object.AccountId != null)
                if ($util.Long)
                    (message.AccountId = $util.Long.fromValue(object.AccountId)).unsigned = false;
                else if (typeof object.AccountId === "string")
                    message.AccountId = parseInt(object.AccountId, 10);
                else if (typeof object.AccountId === "number")
                    message.AccountId = object.AccountId;
                else if (typeof object.AccountId === "object")
                    message.AccountId = new $util.LongBits(object.AccountId.low >>> 0, object.AccountId.high >>> 0).toNumber();
            if (object.IsScheduled != null)
                message.IsScheduled = Boolean(object.IsScheduled);
            if (object.SetAsDefaultForAccountTradingRule != null)
                message.SetAsDefaultForAccountTradingRule = Boolean(object.SetAsDefaultForAccountTradingRule);
            if (object.InhibitChangesUntilNextSession != null)
                message.InhibitChangesUntilNextSession = Boolean(object.InhibitChangesUntilNextSession);
            if (object.DailyLossLimitEnabled != null)
                message.DailyLossLimitEnabled = Boolean(object.DailyLossLimitEnabled);
            switch (object.DailyLossLimitMode) {
            default:
                if (typeof object.DailyLossLimitMode === "number") {
                    message.DailyLossLimitMode = object.DailyLossLimitMode;
                    break;
                }
                break;
            case "TrailingMaxBalance":
            case 0:
                message.DailyLossLimitMode = 0;
                break;
            case "StaticStartBalance":
            case 1:
                message.DailyLossLimitMode = 1;
                break;
            case "TrailingMaxEquity":
            case 2:
                message.DailyLossLimitMode = 2;
                break;
            case "StaticStartEquity":
            case 3:
                message.DailyLossLimitMode = 3;
                break;
            case "StaticMininmumStartEquityBalance":
            case 4:
                message.DailyLossLimitMode = 4;
                break;
            }
            if (object.DailyLossLimitValue != null)
                message.DailyLossLimitValue = Number(object.DailyLossLimitValue);
            if (object.DailyLossLimitPercentage != null)
                message.DailyLossLimitPercentage = Number(object.DailyLossLimitPercentage);
            if (object.DailyProfitLimitEnabled != null)
                message.DailyProfitLimitEnabled = Boolean(object.DailyProfitLimitEnabled);
            switch (object.DailyProfitLimitMode) {
            default:
                if (typeof object.DailyProfitLimitMode === "number") {
                    message.DailyProfitLimitMode = object.DailyProfitLimitMode;
                    break;
                }
                break;
            case "Balance":
            case 0:
                message.DailyProfitLimitMode = 0;
                break;
            case "Equity":
            case 1:
                message.DailyProfitLimitMode = 1;
                break;
            }
            if (object.DailyProfitLimitValue != null)
                message.DailyProfitLimitValue = Number(object.DailyProfitLimitValue);
            if (object.DailyProfitLimitPercentage != null)
                message.DailyProfitLimitPercentage = Number(object.DailyProfitLimitPercentage);
            if (object.WeeklyLossLimitEnabled != null)
                message.WeeklyLossLimitEnabled = Boolean(object.WeeklyLossLimitEnabled);
            switch (object.WeeklyLossLimitMode) {
            default:
                if (typeof object.WeeklyLossLimitMode === "number") {
                    message.WeeklyLossLimitMode = object.WeeklyLossLimitMode;
                    break;
                }
                break;
            case "TrailingMaxBalance":
            case 0:
                message.WeeklyLossLimitMode = 0;
                break;
            case "StaticStartBalance":
            case 1:
                message.WeeklyLossLimitMode = 1;
                break;
            case "TrailingMaxEquity":
            case 2:
                message.WeeklyLossLimitMode = 2;
                break;
            case "StaticStartEquity":
            case 3:
                message.WeeklyLossLimitMode = 3;
                break;
            case "StaticMininmumStartEquityBalance":
            case 4:
                message.WeeklyLossLimitMode = 4;
                break;
            }
            if (object.WeeklyLossLimitValue != null)
                message.WeeklyLossLimitValue = Number(object.WeeklyLossLimitValue);
            if (object.WeeklyLossLimitPercentage != null)
                message.WeeklyLossLimitPercentage = Number(object.WeeklyLossLimitPercentage);
            if (object.WeeklyProfitLimitEnabled != null)
                message.WeeklyProfitLimitEnabled = Boolean(object.WeeklyProfitLimitEnabled);
            switch (object.WeeklyProfitLimitMode) {
            default:
                if (typeof object.WeeklyProfitLimitMode === "number") {
                    message.WeeklyProfitLimitMode = object.WeeklyProfitLimitMode;
                    break;
                }
                break;
            case "Balance":
            case 0:
                message.WeeklyProfitLimitMode = 0;
                break;
            case "Equity":
            case 1:
                message.WeeklyProfitLimitMode = 1;
                break;
            }
            if (object.WeeklyProfitLimitValue != null)
                message.WeeklyProfitLimitValue = Number(object.WeeklyProfitLimitValue);
            if (object.WeeklyProfitLimitPercentage != null)
                message.WeeklyProfitLimitPercentage = Number(object.WeeklyProfitLimitPercentage);
            return message;
        };

        /**
         * Creates a plain object from an AccountUserRiskRule message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @static
         * @param {PropTradingProtocol.AccountUserRiskRule} message AccountUserRiskRule
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountUserRiskRule.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccountId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccountId = options.longs === String ? "0" : 0;
                object.IsScheduled = false;
                object.SetAsDefaultForAccountTradingRule = false;
                object.InhibitChangesUntilNextSession = false;
                object.DailyLossLimitEnabled = false;
                object.DailyLossLimitMode = options.enums === String ? "TrailingMaxBalance" : 0;
                object.DailyLossLimitValue = 0;
                object.DailyLossLimitPercentage = 0;
                object.DailyProfitLimitEnabled = false;
                object.DailyProfitLimitMode = options.enums === String ? "Balance" : 0;
                object.DailyProfitLimitValue = 0;
                object.DailyProfitLimitPercentage = 0;
                object.WeeklyLossLimitEnabled = false;
                object.WeeklyLossLimitMode = options.enums === String ? "TrailingMaxBalance" : 0;
                object.WeeklyLossLimitValue = 0;
                object.WeeklyLossLimitPercentage = 0;
                object.WeeklyProfitLimitEnabled = false;
                object.WeeklyProfitLimitMode = options.enums === String ? "Balance" : 0;
                object.WeeklyProfitLimitValue = 0;
                object.WeeklyProfitLimitPercentage = 0;
            }
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (typeof message.AccountId === "number")
                    object.AccountId = options.longs === String ? String(message.AccountId) : message.AccountId;
                else
                    object.AccountId = options.longs === String ? $util.Long.prototype.toString.call(message.AccountId) : options.longs === Number ? new $util.LongBits(message.AccountId.low >>> 0, message.AccountId.high >>> 0).toNumber() : message.AccountId;
            if (message.IsScheduled != null && message.hasOwnProperty("IsScheduled"))
                object.IsScheduled = message.IsScheduled;
            if (message.SetAsDefaultForAccountTradingRule != null && message.hasOwnProperty("SetAsDefaultForAccountTradingRule"))
                object.SetAsDefaultForAccountTradingRule = message.SetAsDefaultForAccountTradingRule;
            if (message.InhibitChangesUntilNextSession != null && message.hasOwnProperty("InhibitChangesUntilNextSession"))
                object.InhibitChangesUntilNextSession = message.InhibitChangesUntilNextSession;
            if (message.DailyLossLimitEnabled != null && message.hasOwnProperty("DailyLossLimitEnabled"))
                object.DailyLossLimitEnabled = message.DailyLossLimitEnabled;
            if (message.DailyLossLimitMode != null && message.hasOwnProperty("DailyLossLimitMode"))
                object.DailyLossLimitMode = options.enums === String ? $root.PropTradingProtocol.RiskUserLossModeEnum[message.DailyLossLimitMode] === undefined ? message.DailyLossLimitMode : $root.PropTradingProtocol.RiskUserLossModeEnum[message.DailyLossLimitMode] : message.DailyLossLimitMode;
            if (message.DailyLossLimitValue != null && message.hasOwnProperty("DailyLossLimitValue"))
                object.DailyLossLimitValue = options.json && !isFinite(message.DailyLossLimitValue) ? String(message.DailyLossLimitValue) : message.DailyLossLimitValue;
            if (message.DailyLossLimitPercentage != null && message.hasOwnProperty("DailyLossLimitPercentage"))
                object.DailyLossLimitPercentage = options.json && !isFinite(message.DailyLossLimitPercentage) ? String(message.DailyLossLimitPercentage) : message.DailyLossLimitPercentage;
            if (message.DailyProfitLimitEnabled != null && message.hasOwnProperty("DailyProfitLimitEnabled"))
                object.DailyProfitLimitEnabled = message.DailyProfitLimitEnabled;
            if (message.DailyProfitLimitMode != null && message.hasOwnProperty("DailyProfitLimitMode"))
                object.DailyProfitLimitMode = options.enums === String ? $root.PropTradingProtocol.RiskUserTargetModeEnum[message.DailyProfitLimitMode] === undefined ? message.DailyProfitLimitMode : $root.PropTradingProtocol.RiskUserTargetModeEnum[message.DailyProfitLimitMode] : message.DailyProfitLimitMode;
            if (message.DailyProfitLimitValue != null && message.hasOwnProperty("DailyProfitLimitValue"))
                object.DailyProfitLimitValue = options.json && !isFinite(message.DailyProfitLimitValue) ? String(message.DailyProfitLimitValue) : message.DailyProfitLimitValue;
            if (message.DailyProfitLimitPercentage != null && message.hasOwnProperty("DailyProfitLimitPercentage"))
                object.DailyProfitLimitPercentage = options.json && !isFinite(message.DailyProfitLimitPercentage) ? String(message.DailyProfitLimitPercentage) : message.DailyProfitLimitPercentage;
            if (message.WeeklyLossLimitEnabled != null && message.hasOwnProperty("WeeklyLossLimitEnabled"))
                object.WeeklyLossLimitEnabled = message.WeeklyLossLimitEnabled;
            if (message.WeeklyLossLimitMode != null && message.hasOwnProperty("WeeklyLossLimitMode"))
                object.WeeklyLossLimitMode = options.enums === String ? $root.PropTradingProtocol.RiskUserLossModeEnum[message.WeeklyLossLimitMode] === undefined ? message.WeeklyLossLimitMode : $root.PropTradingProtocol.RiskUserLossModeEnum[message.WeeklyLossLimitMode] : message.WeeklyLossLimitMode;
            if (message.WeeklyLossLimitValue != null && message.hasOwnProperty("WeeklyLossLimitValue"))
                object.WeeklyLossLimitValue = options.json && !isFinite(message.WeeklyLossLimitValue) ? String(message.WeeklyLossLimitValue) : message.WeeklyLossLimitValue;
            if (message.WeeklyLossLimitPercentage != null && message.hasOwnProperty("WeeklyLossLimitPercentage"))
                object.WeeklyLossLimitPercentage = options.json && !isFinite(message.WeeklyLossLimitPercentage) ? String(message.WeeklyLossLimitPercentage) : message.WeeklyLossLimitPercentage;
            if (message.WeeklyProfitLimitEnabled != null && message.hasOwnProperty("WeeklyProfitLimitEnabled"))
                object.WeeklyProfitLimitEnabled = message.WeeklyProfitLimitEnabled;
            if (message.WeeklyProfitLimitMode != null && message.hasOwnProperty("WeeklyProfitLimitMode"))
                object.WeeklyProfitLimitMode = options.enums === String ? $root.PropTradingProtocol.RiskUserTargetModeEnum[message.WeeklyProfitLimitMode] === undefined ? message.WeeklyProfitLimitMode : $root.PropTradingProtocol.RiskUserTargetModeEnum[message.WeeklyProfitLimitMode] : message.WeeklyProfitLimitMode;
            if (message.WeeklyProfitLimitValue != null && message.hasOwnProperty("WeeklyProfitLimitValue"))
                object.WeeklyProfitLimitValue = options.json && !isFinite(message.WeeklyProfitLimitValue) ? String(message.WeeklyProfitLimitValue) : message.WeeklyProfitLimitValue;
            if (message.WeeklyProfitLimitPercentage != null && message.hasOwnProperty("WeeklyProfitLimitPercentage"))
                object.WeeklyProfitLimitPercentage = options.json && !isFinite(message.WeeklyProfitLimitPercentage) ? String(message.WeeklyProfitLimitPercentage) : message.WeeklyProfitLimitPercentage;
            return object;
        };

        /**
         * Converts this AccountUserRiskRule to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountUserRiskRule.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountUserRiskRule
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountUserRiskRule
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountUserRiskRule.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountUserRiskRule";
        };

        return AccountUserRiskRule;
    })();

    PropTradingProtocol.AccountUserRiskRuleInfoReqMsg = (function() {

        /**
         * Properties of an AccountUserRiskRuleInfoReqMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountUserRiskRuleInfoReqMsg
         * @property {number|Long|null} [RequestId] AccountUserRiskRuleInfoReqMsg RequestId
         * @property {number|Long|null} [AccountId] AccountUserRiskRuleInfoReqMsg AccountId
         */

        /**
         * Constructs a new AccountUserRiskRuleInfoReqMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountUserRiskRuleInfoReqMsg.
         * @implements IAccountUserRiskRuleInfoReqMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountUserRiskRuleInfoReqMsg=} [properties] Properties to set
         */
        function AccountUserRiskRuleInfoReqMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountUserRiskRuleInfoReqMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoReqMsg
         * @instance
         */
        AccountUserRiskRuleInfoReqMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountUserRiskRuleInfoReqMsg AccountId.
         * @member {number|Long} AccountId
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoReqMsg
         * @instance
         */
        AccountUserRiskRuleInfoReqMsg.prototype.AccountId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AccountUserRiskRuleInfoReqMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountUserRiskRuleInfoReqMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountUserRiskRuleInfoReqMsg} AccountUserRiskRuleInfoReqMsg instance
         */
        AccountUserRiskRuleInfoReqMsg.create = function create(properties) {
            return new AccountUserRiskRuleInfoReqMsg(properties);
        };

        /**
         * Encodes the specified AccountUserRiskRuleInfoReqMsg message. Does not implicitly {@link PropTradingProtocol.AccountUserRiskRuleInfoReqMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountUserRiskRuleInfoReqMsg} message AccountUserRiskRuleInfoReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserRiskRuleInfoReqMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.AccountId != null && Object.hasOwnProperty.call(message, "AccountId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccountId);
            return writer;
        };

        /**
         * Encodes the specified AccountUserRiskRuleInfoReqMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountUserRiskRuleInfoReqMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountUserRiskRuleInfoReqMsg} message AccountUserRiskRuleInfoReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserRiskRuleInfoReqMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountUserRiskRuleInfoReqMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountUserRiskRuleInfoReqMsg} AccountUserRiskRuleInfoReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserRiskRuleInfoReqMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountUserRiskRuleInfoReqMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.AccountId = reader.sint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountUserRiskRuleInfoReqMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountUserRiskRuleInfoReqMsg} AccountUserRiskRuleInfoReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserRiskRuleInfoReqMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountUserRiskRuleInfoReqMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoReqMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountUserRiskRuleInfoReqMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (!$util.isInteger(message.AccountId) && !(message.AccountId && $util.isInteger(message.AccountId.low) && $util.isInteger(message.AccountId.high)))
                    return "AccountId: integer|Long expected";
            return null;
        };

        /**
         * Creates an AccountUserRiskRuleInfoReqMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoReqMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountUserRiskRuleInfoReqMsg} AccountUserRiskRuleInfoReqMsg
         */
        AccountUserRiskRuleInfoReqMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountUserRiskRuleInfoReqMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountUserRiskRuleInfoReqMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.AccountId != null)
                if ($util.Long)
                    (message.AccountId = $util.Long.fromValue(object.AccountId)).unsigned = false;
                else if (typeof object.AccountId === "string")
                    message.AccountId = parseInt(object.AccountId, 10);
                else if (typeof object.AccountId === "number")
                    message.AccountId = object.AccountId;
                else if (typeof object.AccountId === "object")
                    message.AccountId = new $util.LongBits(object.AccountId.low >>> 0, object.AccountId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an AccountUserRiskRuleInfoReqMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoReqMsg
         * @static
         * @param {PropTradingProtocol.AccountUserRiskRuleInfoReqMsg} message AccountUserRiskRuleInfoReqMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountUserRiskRuleInfoReqMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccountId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccountId = options.longs === String ? "0" : 0;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (typeof message.AccountId === "number")
                    object.AccountId = options.longs === String ? String(message.AccountId) : message.AccountId;
                else
                    object.AccountId = options.longs === String ? $util.Long.prototype.toString.call(message.AccountId) : options.longs === Number ? new $util.LongBits(message.AccountId.low >>> 0, message.AccountId.high >>> 0).toNumber() : message.AccountId;
            return object;
        };

        /**
         * Converts this AccountUserRiskRuleInfoReqMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoReqMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountUserRiskRuleInfoReqMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountUserRiskRuleInfoReqMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoReqMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountUserRiskRuleInfoReqMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountUserRiskRuleInfoReqMsg";
        };

        return AccountUserRiskRuleInfoReqMsg;
    })();

    PropTradingProtocol.AccountUserRiskRuleInfoRespMsg = (function() {

        /**
         * Properties of an AccountUserRiskRuleInfoRespMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountUserRiskRuleInfoRespMsg
         * @property {number|Long|null} [RequestId] AccountUserRiskRuleInfoRespMsg RequestId
         * @property {boolean|null} [Success] AccountUserRiskRuleInfoRespMsg Success
         * @property {string|null} [Error] AccountUserRiskRuleInfoRespMsg Error
         * @property {PropTradingProtocol.IAccountUserRiskRule|null} [Rule] AccountUserRiskRuleInfoRespMsg Rule
         */

        /**
         * Constructs a new AccountUserRiskRuleInfoRespMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountUserRiskRuleInfoRespMsg.
         * @implements IAccountUserRiskRuleInfoRespMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountUserRiskRuleInfoRespMsg=} [properties] Properties to set
         */
        function AccountUserRiskRuleInfoRespMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountUserRiskRuleInfoRespMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoRespMsg
         * @instance
         */
        AccountUserRiskRuleInfoRespMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountUserRiskRuleInfoRespMsg Success.
         * @member {boolean} Success
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoRespMsg
         * @instance
         */
        AccountUserRiskRuleInfoRespMsg.prototype.Success = false;

        /**
         * AccountUserRiskRuleInfoRespMsg Error.
         * @member {string} Error
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoRespMsg
         * @instance
         */
        AccountUserRiskRuleInfoRespMsg.prototype.Error = "";

        /**
         * AccountUserRiskRuleInfoRespMsg Rule.
         * @member {PropTradingProtocol.IAccountUserRiskRule|null|undefined} Rule
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoRespMsg
         * @instance
         */
        AccountUserRiskRuleInfoRespMsg.prototype.Rule = null;

        /**
         * Creates a new AccountUserRiskRuleInfoRespMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountUserRiskRuleInfoRespMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountUserRiskRuleInfoRespMsg} AccountUserRiskRuleInfoRespMsg instance
         */
        AccountUserRiskRuleInfoRespMsg.create = function create(properties) {
            return new AccountUserRiskRuleInfoRespMsg(properties);
        };

        /**
         * Encodes the specified AccountUserRiskRuleInfoRespMsg message. Does not implicitly {@link PropTradingProtocol.AccountUserRiskRuleInfoRespMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountUserRiskRuleInfoRespMsg} message AccountUserRiskRuleInfoRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserRiskRuleInfoRespMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Success != null && Object.hasOwnProperty.call(message, "Success"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.Success);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Error);
            if (message.Rule != null && Object.hasOwnProperty.call(message, "Rule"))
                $root.PropTradingProtocol.AccountUserRiskRule.encode(message.Rule, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccountUserRiskRuleInfoRespMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountUserRiskRuleInfoRespMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountUserRiskRuleInfoRespMsg} message AccountUserRiskRuleInfoRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserRiskRuleInfoRespMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountUserRiskRuleInfoRespMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountUserRiskRuleInfoRespMsg} AccountUserRiskRuleInfoRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserRiskRuleInfoRespMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountUserRiskRuleInfoRespMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.Success = reader.bool();
                        break;
                    }
                case 3: {
                        message.Error = reader.string();
                        break;
                    }
                case 4: {
                        message.Rule = $root.PropTradingProtocol.AccountUserRiskRule.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountUserRiskRuleInfoRespMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountUserRiskRuleInfoRespMsg} AccountUserRiskRuleInfoRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserRiskRuleInfoRespMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountUserRiskRuleInfoRespMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoRespMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountUserRiskRuleInfoRespMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Success != null && message.hasOwnProperty("Success"))
                if (typeof message.Success !== "boolean")
                    return "Success: boolean expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isString(message.Error))
                    return "Error: string expected";
            if (message.Rule != null && message.hasOwnProperty("Rule")) {
                let error = $root.PropTradingProtocol.AccountUserRiskRule.verify(message.Rule);
                if (error)
                    return "Rule." + error;
            }
            return null;
        };

        /**
         * Creates an AccountUserRiskRuleInfoRespMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoRespMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountUserRiskRuleInfoRespMsg} AccountUserRiskRuleInfoRespMsg
         */
        AccountUserRiskRuleInfoRespMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountUserRiskRuleInfoRespMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountUserRiskRuleInfoRespMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Success != null)
                message.Success = Boolean(object.Success);
            if (object.Error != null)
                message.Error = String(object.Error);
            if (object.Rule != null) {
                if (typeof object.Rule !== "object")
                    throw TypeError(".PropTradingProtocol.AccountUserRiskRuleInfoRespMsg.Rule: object expected");
                message.Rule = $root.PropTradingProtocol.AccountUserRiskRule.fromObject(object.Rule);
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountUserRiskRuleInfoRespMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoRespMsg
         * @static
         * @param {PropTradingProtocol.AccountUserRiskRuleInfoRespMsg} message AccountUserRiskRuleInfoRespMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountUserRiskRuleInfoRespMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.Success = false;
                object.Error = "";
                object.Rule = null;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Success != null && message.hasOwnProperty("Success"))
                object.Success = message.Success;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            if (message.Rule != null && message.hasOwnProperty("Rule"))
                object.Rule = $root.PropTradingProtocol.AccountUserRiskRule.toObject(message.Rule, options);
            return object;
        };

        /**
         * Converts this AccountUserRiskRuleInfoRespMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoRespMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountUserRiskRuleInfoRespMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountUserRiskRuleInfoRespMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountUserRiskRuleInfoRespMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountUserRiskRuleInfoRespMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountUserRiskRuleInfoRespMsg";
        };

        return AccountUserRiskRuleInfoRespMsg;
    })();

    PropTradingProtocol.AccountUserRiskRuleSetReqMsg = (function() {

        /**
         * Properties of an AccountUserRiskRuleSetReqMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountUserRiskRuleSetReqMsg
         * @property {number|Long|null} [RequestId] AccountUserRiskRuleSetReqMsg RequestId
         * @property {PropTradingProtocol.IAccountUserRiskRule|null} [Rule] AccountUserRiskRuleSetReqMsg Rule
         */

        /**
         * Constructs a new AccountUserRiskRuleSetReqMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountUserRiskRuleSetReqMsg.
         * @implements IAccountUserRiskRuleSetReqMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountUserRiskRuleSetReqMsg=} [properties] Properties to set
         */
        function AccountUserRiskRuleSetReqMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountUserRiskRuleSetReqMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetReqMsg
         * @instance
         */
        AccountUserRiskRuleSetReqMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountUserRiskRuleSetReqMsg Rule.
         * @member {PropTradingProtocol.IAccountUserRiskRule|null|undefined} Rule
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetReqMsg
         * @instance
         */
        AccountUserRiskRuleSetReqMsg.prototype.Rule = null;

        /**
         * Creates a new AccountUserRiskRuleSetReqMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountUserRiskRuleSetReqMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountUserRiskRuleSetReqMsg} AccountUserRiskRuleSetReqMsg instance
         */
        AccountUserRiskRuleSetReqMsg.create = function create(properties) {
            return new AccountUserRiskRuleSetReqMsg(properties);
        };

        /**
         * Encodes the specified AccountUserRiskRuleSetReqMsg message. Does not implicitly {@link PropTradingProtocol.AccountUserRiskRuleSetReqMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountUserRiskRuleSetReqMsg} message AccountUserRiskRuleSetReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserRiskRuleSetReqMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Rule != null && Object.hasOwnProperty.call(message, "Rule"))
                $root.PropTradingProtocol.AccountUserRiskRule.encode(message.Rule, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccountUserRiskRuleSetReqMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountUserRiskRuleSetReqMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountUserRiskRuleSetReqMsg} message AccountUserRiskRuleSetReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserRiskRuleSetReqMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountUserRiskRuleSetReqMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountUserRiskRuleSetReqMsg} AccountUserRiskRuleSetReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserRiskRuleSetReqMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountUserRiskRuleSetReqMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.Rule = $root.PropTradingProtocol.AccountUserRiskRule.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountUserRiskRuleSetReqMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountUserRiskRuleSetReqMsg} AccountUserRiskRuleSetReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserRiskRuleSetReqMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountUserRiskRuleSetReqMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetReqMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountUserRiskRuleSetReqMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Rule != null && message.hasOwnProperty("Rule")) {
                let error = $root.PropTradingProtocol.AccountUserRiskRule.verify(message.Rule);
                if (error)
                    return "Rule." + error;
            }
            return null;
        };

        /**
         * Creates an AccountUserRiskRuleSetReqMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetReqMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountUserRiskRuleSetReqMsg} AccountUserRiskRuleSetReqMsg
         */
        AccountUserRiskRuleSetReqMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountUserRiskRuleSetReqMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountUserRiskRuleSetReqMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Rule != null) {
                if (typeof object.Rule !== "object")
                    throw TypeError(".PropTradingProtocol.AccountUserRiskRuleSetReqMsg.Rule: object expected");
                message.Rule = $root.PropTradingProtocol.AccountUserRiskRule.fromObject(object.Rule);
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountUserRiskRuleSetReqMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetReqMsg
         * @static
         * @param {PropTradingProtocol.AccountUserRiskRuleSetReqMsg} message AccountUserRiskRuleSetReqMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountUserRiskRuleSetReqMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.Rule = null;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Rule != null && message.hasOwnProperty("Rule"))
                object.Rule = $root.PropTradingProtocol.AccountUserRiskRule.toObject(message.Rule, options);
            return object;
        };

        /**
         * Converts this AccountUserRiskRuleSetReqMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetReqMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountUserRiskRuleSetReqMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountUserRiskRuleSetReqMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetReqMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountUserRiskRuleSetReqMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountUserRiskRuleSetReqMsg";
        };

        return AccountUserRiskRuleSetReqMsg;
    })();

    PropTradingProtocol.AccountUserRiskRuleSetRespMsg = (function() {

        /**
         * Properties of an AccountUserRiskRuleSetRespMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountUserRiskRuleSetRespMsg
         * @property {number|Long|null} [RequestId] AccountUserRiskRuleSetRespMsg RequestId
         * @property {boolean|null} [Success] AccountUserRiskRuleSetRespMsg Success
         * @property {Array.<string>|null} [Errors] AccountUserRiskRuleSetRespMsg Errors
         */

        /**
         * Constructs a new AccountUserRiskRuleSetRespMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountUserRiskRuleSetRespMsg.
         * @implements IAccountUserRiskRuleSetRespMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountUserRiskRuleSetRespMsg=} [properties] Properties to set
         */
        function AccountUserRiskRuleSetRespMsg(properties) {
            this.Errors = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountUserRiskRuleSetRespMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetRespMsg
         * @instance
         */
        AccountUserRiskRuleSetRespMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountUserRiskRuleSetRespMsg Success.
         * @member {boolean} Success
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetRespMsg
         * @instance
         */
        AccountUserRiskRuleSetRespMsg.prototype.Success = false;

        /**
         * AccountUserRiskRuleSetRespMsg Errors.
         * @member {Array.<string>} Errors
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetRespMsg
         * @instance
         */
        AccountUserRiskRuleSetRespMsg.prototype.Errors = $util.emptyArray;

        /**
         * Creates a new AccountUserRiskRuleSetRespMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountUserRiskRuleSetRespMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountUserRiskRuleSetRespMsg} AccountUserRiskRuleSetRespMsg instance
         */
        AccountUserRiskRuleSetRespMsg.create = function create(properties) {
            return new AccountUserRiskRuleSetRespMsg(properties);
        };

        /**
         * Encodes the specified AccountUserRiskRuleSetRespMsg message. Does not implicitly {@link PropTradingProtocol.AccountUserRiskRuleSetRespMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountUserRiskRuleSetRespMsg} message AccountUserRiskRuleSetRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserRiskRuleSetRespMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Success != null && Object.hasOwnProperty.call(message, "Success"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.Success);
            if (message.Errors != null && message.Errors.length)
                for (let i = 0; i < message.Errors.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.Errors[i]);
            return writer;
        };

        /**
         * Encodes the specified AccountUserRiskRuleSetRespMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountUserRiskRuleSetRespMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountUserRiskRuleSetRespMsg} message AccountUserRiskRuleSetRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountUserRiskRuleSetRespMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountUserRiskRuleSetRespMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountUserRiskRuleSetRespMsg} AccountUserRiskRuleSetRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserRiskRuleSetRespMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountUserRiskRuleSetRespMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.Success = reader.bool();
                        break;
                    }
                case 3: {
                        if (!(message.Errors && message.Errors.length))
                            message.Errors = [];
                        message.Errors.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountUserRiskRuleSetRespMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountUserRiskRuleSetRespMsg} AccountUserRiskRuleSetRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountUserRiskRuleSetRespMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountUserRiskRuleSetRespMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetRespMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountUserRiskRuleSetRespMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Success != null && message.hasOwnProperty("Success"))
                if (typeof message.Success !== "boolean")
                    return "Success: boolean expected";
            if (message.Errors != null && message.hasOwnProperty("Errors")) {
                if (!Array.isArray(message.Errors))
                    return "Errors: array expected";
                for (let i = 0; i < message.Errors.length; ++i)
                    if (!$util.isString(message.Errors[i]))
                        return "Errors: string[] expected";
            }
            return null;
        };

        /**
         * Creates an AccountUserRiskRuleSetRespMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetRespMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountUserRiskRuleSetRespMsg} AccountUserRiskRuleSetRespMsg
         */
        AccountUserRiskRuleSetRespMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountUserRiskRuleSetRespMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountUserRiskRuleSetRespMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Success != null)
                message.Success = Boolean(object.Success);
            if (object.Errors) {
                if (!Array.isArray(object.Errors))
                    throw TypeError(".PropTradingProtocol.AccountUserRiskRuleSetRespMsg.Errors: array expected");
                message.Errors = [];
                for (let i = 0; i < object.Errors.length; ++i)
                    message.Errors[i] = String(object.Errors[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountUserRiskRuleSetRespMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetRespMsg
         * @static
         * @param {PropTradingProtocol.AccountUserRiskRuleSetRespMsg} message AccountUserRiskRuleSetRespMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountUserRiskRuleSetRespMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.Errors = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.Success = false;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Success != null && message.hasOwnProperty("Success"))
                object.Success = message.Success;
            if (message.Errors && message.Errors.length) {
                object.Errors = [];
                for (let j = 0; j < message.Errors.length; ++j)
                    object.Errors[j] = message.Errors[j];
            }
            return object;
        };

        /**
         * Converts this AccountUserRiskRuleSetRespMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetRespMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountUserRiskRuleSetRespMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountUserRiskRuleSetRespMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountUserRiskRuleSetRespMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountUserRiskRuleSetRespMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountUserRiskRuleSetRespMsg";
        };

        return AccountUserRiskRuleSetRespMsg;
    })();

    PropTradingProtocol.AccountDailyLockoutReqMsg = (function() {

        /**
         * Properties of an AccountDailyLockoutReqMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountDailyLockoutReqMsg
         * @property {number|Long|null} [RequestId] AccountDailyLockoutReqMsg RequestId
         * @property {number|Long|null} [AccountId] AccountDailyLockoutReqMsg AccountId
         */

        /**
         * Constructs a new AccountDailyLockoutReqMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountDailyLockoutReqMsg.
         * @implements IAccountDailyLockoutReqMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountDailyLockoutReqMsg=} [properties] Properties to set
         */
        function AccountDailyLockoutReqMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountDailyLockoutReqMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.AccountDailyLockoutReqMsg
         * @instance
         */
        AccountDailyLockoutReqMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountDailyLockoutReqMsg AccountId.
         * @member {number|Long} AccountId
         * @memberof PropTradingProtocol.AccountDailyLockoutReqMsg
         * @instance
         */
        AccountDailyLockoutReqMsg.prototype.AccountId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AccountDailyLockoutReqMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountDailyLockoutReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountDailyLockoutReqMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountDailyLockoutReqMsg} AccountDailyLockoutReqMsg instance
         */
        AccountDailyLockoutReqMsg.create = function create(properties) {
            return new AccountDailyLockoutReqMsg(properties);
        };

        /**
         * Encodes the specified AccountDailyLockoutReqMsg message. Does not implicitly {@link PropTradingProtocol.AccountDailyLockoutReqMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountDailyLockoutReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountDailyLockoutReqMsg} message AccountDailyLockoutReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountDailyLockoutReqMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.AccountId != null && Object.hasOwnProperty.call(message, "AccountId"))
                writer.uint32(/* id 2, wireType 0 =*/16).sint64(message.AccountId);
            return writer;
        };

        /**
         * Encodes the specified AccountDailyLockoutReqMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountDailyLockoutReqMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountDailyLockoutReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountDailyLockoutReqMsg} message AccountDailyLockoutReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountDailyLockoutReqMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountDailyLockoutReqMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountDailyLockoutReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountDailyLockoutReqMsg} AccountDailyLockoutReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountDailyLockoutReqMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountDailyLockoutReqMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.AccountId = reader.sint64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountDailyLockoutReqMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountDailyLockoutReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountDailyLockoutReqMsg} AccountDailyLockoutReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountDailyLockoutReqMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountDailyLockoutReqMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountDailyLockoutReqMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountDailyLockoutReqMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (!$util.isInteger(message.AccountId) && !(message.AccountId && $util.isInteger(message.AccountId.low) && $util.isInteger(message.AccountId.high)))
                    return "AccountId: integer|Long expected";
            return null;
        };

        /**
         * Creates an AccountDailyLockoutReqMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountDailyLockoutReqMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountDailyLockoutReqMsg} AccountDailyLockoutReqMsg
         */
        AccountDailyLockoutReqMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountDailyLockoutReqMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountDailyLockoutReqMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.AccountId != null)
                if ($util.Long)
                    (message.AccountId = $util.Long.fromValue(object.AccountId)).unsigned = false;
                else if (typeof object.AccountId === "string")
                    message.AccountId = parseInt(object.AccountId, 10);
                else if (typeof object.AccountId === "number")
                    message.AccountId = object.AccountId;
                else if (typeof object.AccountId === "object")
                    message.AccountId = new $util.LongBits(object.AccountId.low >>> 0, object.AccountId.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from an AccountDailyLockoutReqMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountDailyLockoutReqMsg
         * @static
         * @param {PropTradingProtocol.AccountDailyLockoutReqMsg} message AccountDailyLockoutReqMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountDailyLockoutReqMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.AccountId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.AccountId = options.longs === String ? "0" : 0;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.AccountId != null && message.hasOwnProperty("AccountId"))
                if (typeof message.AccountId === "number")
                    object.AccountId = options.longs === String ? String(message.AccountId) : message.AccountId;
                else
                    object.AccountId = options.longs === String ? $util.Long.prototype.toString.call(message.AccountId) : options.longs === Number ? new $util.LongBits(message.AccountId.low >>> 0, message.AccountId.high >>> 0).toNumber() : message.AccountId;
            return object;
        };

        /**
         * Converts this AccountDailyLockoutReqMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountDailyLockoutReqMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountDailyLockoutReqMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountDailyLockoutReqMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountDailyLockoutReqMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountDailyLockoutReqMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountDailyLockoutReqMsg";
        };

        return AccountDailyLockoutReqMsg;
    })();

    PropTradingProtocol.AccountDailyLockoutRespMsg = (function() {

        /**
         * Properties of an AccountDailyLockoutRespMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountDailyLockoutRespMsg
         * @property {number|Long|null} [RequestId] AccountDailyLockoutRespMsg RequestId
         * @property {boolean|null} [Success] AccountDailyLockoutRespMsg Success
         * @property {string|null} [Error] AccountDailyLockoutRespMsg Error
         */

        /**
         * Constructs a new AccountDailyLockoutRespMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountDailyLockoutRespMsg.
         * @implements IAccountDailyLockoutRespMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountDailyLockoutRespMsg=} [properties] Properties to set
         */
        function AccountDailyLockoutRespMsg(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountDailyLockoutRespMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.AccountDailyLockoutRespMsg
         * @instance
         */
        AccountDailyLockoutRespMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountDailyLockoutRespMsg Success.
         * @member {boolean} Success
         * @memberof PropTradingProtocol.AccountDailyLockoutRespMsg
         * @instance
         */
        AccountDailyLockoutRespMsg.prototype.Success = false;

        /**
         * AccountDailyLockoutRespMsg Error.
         * @member {string} Error
         * @memberof PropTradingProtocol.AccountDailyLockoutRespMsg
         * @instance
         */
        AccountDailyLockoutRespMsg.prototype.Error = "";

        /**
         * Creates a new AccountDailyLockoutRespMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountDailyLockoutRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountDailyLockoutRespMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountDailyLockoutRespMsg} AccountDailyLockoutRespMsg instance
         */
        AccountDailyLockoutRespMsg.create = function create(properties) {
            return new AccountDailyLockoutRespMsg(properties);
        };

        /**
         * Encodes the specified AccountDailyLockoutRespMsg message. Does not implicitly {@link PropTradingProtocol.AccountDailyLockoutRespMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountDailyLockoutRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountDailyLockoutRespMsg} message AccountDailyLockoutRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountDailyLockoutRespMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Success != null && Object.hasOwnProperty.call(message, "Success"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.Success);
            if (message.Error != null && Object.hasOwnProperty.call(message, "Error"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Error);
            return writer;
        };

        /**
         * Encodes the specified AccountDailyLockoutRespMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountDailyLockoutRespMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountDailyLockoutRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountDailyLockoutRespMsg} message AccountDailyLockoutRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountDailyLockoutRespMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountDailyLockoutRespMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountDailyLockoutRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountDailyLockoutRespMsg} AccountDailyLockoutRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountDailyLockoutRespMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountDailyLockoutRespMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        message.Success = reader.bool();
                        break;
                    }
                case 3: {
                        message.Error = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountDailyLockoutRespMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountDailyLockoutRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountDailyLockoutRespMsg} AccountDailyLockoutRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountDailyLockoutRespMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountDailyLockoutRespMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountDailyLockoutRespMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountDailyLockoutRespMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Success != null && message.hasOwnProperty("Success"))
                if (typeof message.Success !== "boolean")
                    return "Success: boolean expected";
            if (message.Error != null && message.hasOwnProperty("Error"))
                if (!$util.isString(message.Error))
                    return "Error: string expected";
            return null;
        };

        /**
         * Creates an AccountDailyLockoutRespMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountDailyLockoutRespMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountDailyLockoutRespMsg} AccountDailyLockoutRespMsg
         */
        AccountDailyLockoutRespMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountDailyLockoutRespMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountDailyLockoutRespMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Success != null)
                message.Success = Boolean(object.Success);
            if (object.Error != null)
                message.Error = String(object.Error);
            return message;
        };

        /**
         * Creates a plain object from an AccountDailyLockoutRespMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountDailyLockoutRespMsg
         * @static
         * @param {PropTradingProtocol.AccountDailyLockoutRespMsg} message AccountDailyLockoutRespMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountDailyLockoutRespMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.Success = false;
                object.Error = "";
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Success != null && message.hasOwnProperty("Success"))
                object.Success = message.Success;
            if (message.Error != null && message.hasOwnProperty("Error"))
                object.Error = message.Error;
            return object;
        };

        /**
         * Converts this AccountDailyLockoutRespMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountDailyLockoutRespMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountDailyLockoutRespMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountDailyLockoutRespMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountDailyLockoutRespMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountDailyLockoutRespMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountDailyLockoutRespMsg";
        };

        return AccountDailyLockoutRespMsg;
    })();

    /**
     * AccountHistoricalEntityEnum enum.
     * @name PropTradingProtocol.AccountHistoricalEntityEnum
     * @enum {number}
     * @property {number} All=0 All value
     * @property {number} Orders=1 Orders value
     * @property {number} Trades=2 Trades value
     * @property {number} Fills=3 Fills value
     * @property {number} FillTrades=4 FillTrades value
     */
    PropTradingProtocol.AccountHistoricalEntityEnum = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "All"] = 0;
        values[valuesById[1] = "Orders"] = 1;
        values[valuesById[2] = "Trades"] = 2;
        values[valuesById[3] = "Fills"] = 3;
        values[valuesById[4] = "FillTrades"] = 4;
        return values;
    })();

    PropTradingProtocol.AccountHistoricalSessionReqMsg = (function() {

        /**
         * Properties of an AccountHistoricalSessionReqMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountHistoricalSessionReqMsg
         * @property {number|Long|null} [RequestId] AccountHistoricalSessionReqMsg RequestId
         * @property {Array.<number|Long>|null} [AccountIds] AccountHistoricalSessionReqMsg AccountIds
         * @property {PropTradingProtocol.AccountHistoricalEntityEnum|null} [Entity] AccountHistoricalSessionReqMsg Entity
         */

        /**
         * Constructs a new AccountHistoricalSessionReqMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountHistoricalSessionReqMsg.
         * @implements IAccountHistoricalSessionReqMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountHistoricalSessionReqMsg=} [properties] Properties to set
         */
        function AccountHistoricalSessionReqMsg(properties) {
            this.AccountIds = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountHistoricalSessionReqMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.AccountHistoricalSessionReqMsg
         * @instance
         */
        AccountHistoricalSessionReqMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountHistoricalSessionReqMsg AccountIds.
         * @member {Array.<number|Long>} AccountIds
         * @memberof PropTradingProtocol.AccountHistoricalSessionReqMsg
         * @instance
         */
        AccountHistoricalSessionReqMsg.prototype.AccountIds = $util.emptyArray;

        /**
         * AccountHistoricalSessionReqMsg Entity.
         * @member {PropTradingProtocol.AccountHistoricalEntityEnum} Entity
         * @memberof PropTradingProtocol.AccountHistoricalSessionReqMsg
         * @instance
         */
        AccountHistoricalSessionReqMsg.prototype.Entity = 0;

        /**
         * Creates a new AccountHistoricalSessionReqMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountHistoricalSessionReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountHistoricalSessionReqMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountHistoricalSessionReqMsg} AccountHistoricalSessionReqMsg instance
         */
        AccountHistoricalSessionReqMsg.create = function create(properties) {
            return new AccountHistoricalSessionReqMsg(properties);
        };

        /**
         * Encodes the specified AccountHistoricalSessionReqMsg message. Does not implicitly {@link PropTradingProtocol.AccountHistoricalSessionReqMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountHistoricalSessionReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountHistoricalSessionReqMsg} message AccountHistoricalSessionReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountHistoricalSessionReqMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.AccountIds != null && message.AccountIds.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (let i = 0; i < message.AccountIds.length; ++i)
                    writer.sint64(message.AccountIds[i]);
                writer.ldelim();
            }
            if (message.Entity != null && Object.hasOwnProperty.call(message, "Entity"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Entity);
            return writer;
        };

        /**
         * Encodes the specified AccountHistoricalSessionReqMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountHistoricalSessionReqMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountHistoricalSessionReqMsg
         * @static
         * @param {PropTradingProtocol.IAccountHistoricalSessionReqMsg} message AccountHistoricalSessionReqMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountHistoricalSessionReqMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountHistoricalSessionReqMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountHistoricalSessionReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountHistoricalSessionReqMsg} AccountHistoricalSessionReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountHistoricalSessionReqMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountHistoricalSessionReqMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        if (!(message.AccountIds && message.AccountIds.length))
                            message.AccountIds = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.AccountIds.push(reader.sint64());
                        } else
                            message.AccountIds.push(reader.sint64());
                        break;
                    }
                case 3: {
                        message.Entity = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountHistoricalSessionReqMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountHistoricalSessionReqMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountHistoricalSessionReqMsg} AccountHistoricalSessionReqMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountHistoricalSessionReqMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountHistoricalSessionReqMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountHistoricalSessionReqMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountHistoricalSessionReqMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.AccountIds != null && message.hasOwnProperty("AccountIds")) {
                if (!Array.isArray(message.AccountIds))
                    return "AccountIds: array expected";
                for (let i = 0; i < message.AccountIds.length; ++i)
                    if (!$util.isInteger(message.AccountIds[i]) && !(message.AccountIds[i] && $util.isInteger(message.AccountIds[i].low) && $util.isInteger(message.AccountIds[i].high)))
                        return "AccountIds: integer|Long[] expected";
            }
            if (message.Entity != null && message.hasOwnProperty("Entity"))
                switch (message.Entity) {
                default:
                    return "Entity: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        /**
         * Creates an AccountHistoricalSessionReqMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountHistoricalSessionReqMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountHistoricalSessionReqMsg} AccountHistoricalSessionReqMsg
         */
        AccountHistoricalSessionReqMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountHistoricalSessionReqMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountHistoricalSessionReqMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.AccountIds) {
                if (!Array.isArray(object.AccountIds))
                    throw TypeError(".PropTradingProtocol.AccountHistoricalSessionReqMsg.AccountIds: array expected");
                message.AccountIds = [];
                for (let i = 0; i < object.AccountIds.length; ++i)
                    if ($util.Long)
                        (message.AccountIds[i] = $util.Long.fromValue(object.AccountIds[i])).unsigned = false;
                    else if (typeof object.AccountIds[i] === "string")
                        message.AccountIds[i] = parseInt(object.AccountIds[i], 10);
                    else if (typeof object.AccountIds[i] === "number")
                        message.AccountIds[i] = object.AccountIds[i];
                    else if (typeof object.AccountIds[i] === "object")
                        message.AccountIds[i] = new $util.LongBits(object.AccountIds[i].low >>> 0, object.AccountIds[i].high >>> 0).toNumber();
            }
            switch (object.Entity) {
            default:
                if (typeof object.Entity === "number") {
                    message.Entity = object.Entity;
                    break;
                }
                break;
            case "All":
            case 0:
                message.Entity = 0;
                break;
            case "Orders":
            case 1:
                message.Entity = 1;
                break;
            case "Trades":
            case 2:
                message.Entity = 2;
                break;
            case "Fills":
            case 3:
                message.Entity = 3;
                break;
            case "FillTrades":
            case 4:
                message.Entity = 4;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from an AccountHistoricalSessionReqMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountHistoricalSessionReqMsg
         * @static
         * @param {PropTradingProtocol.AccountHistoricalSessionReqMsg} message AccountHistoricalSessionReqMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountHistoricalSessionReqMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.AccountIds = [];
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.Entity = options.enums === String ? "All" : 0;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.AccountIds && message.AccountIds.length) {
                object.AccountIds = [];
                for (let j = 0; j < message.AccountIds.length; ++j)
                    if (typeof message.AccountIds[j] === "number")
                        object.AccountIds[j] = options.longs === String ? String(message.AccountIds[j]) : message.AccountIds[j];
                    else
                        object.AccountIds[j] = options.longs === String ? $util.Long.prototype.toString.call(message.AccountIds[j]) : options.longs === Number ? new $util.LongBits(message.AccountIds[j].low >>> 0, message.AccountIds[j].high >>> 0).toNumber() : message.AccountIds[j];
            }
            if (message.Entity != null && message.hasOwnProperty("Entity"))
                object.Entity = options.enums === String ? $root.PropTradingProtocol.AccountHistoricalEntityEnum[message.Entity] === undefined ? message.Entity : $root.PropTradingProtocol.AccountHistoricalEntityEnum[message.Entity] : message.Entity;
            return object;
        };

        /**
         * Converts this AccountHistoricalSessionReqMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountHistoricalSessionReqMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountHistoricalSessionReqMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountHistoricalSessionReqMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountHistoricalSessionReqMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountHistoricalSessionReqMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountHistoricalSessionReqMsg";
        };

        return AccountHistoricalSessionReqMsg;
    })();

    PropTradingProtocol.AccountHistoricalSessionRespMsg = (function() {

        /**
         * Properties of an AccountHistoricalSessionRespMsg.
         * @memberof PropTradingProtocol
         * @interface IAccountHistoricalSessionRespMsg
         * @property {number|Long|null} [RequestId] AccountHistoricalSessionRespMsg RequestId
         * @property {Array.<PropTradingProtocol.IFillReportMsg>|null} [Fills] AccountHistoricalSessionRespMsg Fills
         * @property {Array.<PropTradingProtocol.ITradeReportMsg>|null} [Trades] AccountHistoricalSessionRespMsg Trades
         * @property {Array.<PropTradingProtocol.IOrderInfoMsg>|null} [Orders] AccountHistoricalSessionRespMsg Orders
         * @property {Array.<PropTradingProtocol.IFillTradeReportMsg>|null} [FillTrades] AccountHistoricalSessionRespMsg FillTrades
         * @property {boolean|null} [IsPartial] AccountHistoricalSessionRespMsg IsPartial
         */

        /**
         * Constructs a new AccountHistoricalSessionRespMsg.
         * @memberof PropTradingProtocol
         * @classdesc Represents an AccountHistoricalSessionRespMsg.
         * @implements IAccountHistoricalSessionRespMsg
         * @constructor
         * @param {PropTradingProtocol.IAccountHistoricalSessionRespMsg=} [properties] Properties to set
         */
        function AccountHistoricalSessionRespMsg(properties) {
            this.Fills = [];
            this.Trades = [];
            this.Orders = [];
            this.FillTrades = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountHistoricalSessionRespMsg RequestId.
         * @member {number|Long} RequestId
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @instance
         */
        AccountHistoricalSessionRespMsg.prototype.RequestId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AccountHistoricalSessionRespMsg Fills.
         * @member {Array.<PropTradingProtocol.IFillReportMsg>} Fills
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @instance
         */
        AccountHistoricalSessionRespMsg.prototype.Fills = $util.emptyArray;

        /**
         * AccountHistoricalSessionRespMsg Trades.
         * @member {Array.<PropTradingProtocol.ITradeReportMsg>} Trades
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @instance
         */
        AccountHistoricalSessionRespMsg.prototype.Trades = $util.emptyArray;

        /**
         * AccountHistoricalSessionRespMsg Orders.
         * @member {Array.<PropTradingProtocol.IOrderInfoMsg>} Orders
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @instance
         */
        AccountHistoricalSessionRespMsg.prototype.Orders = $util.emptyArray;

        /**
         * AccountHistoricalSessionRespMsg FillTrades.
         * @member {Array.<PropTradingProtocol.IFillTradeReportMsg>} FillTrades
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @instance
         */
        AccountHistoricalSessionRespMsg.prototype.FillTrades = $util.emptyArray;

        /**
         * AccountHistoricalSessionRespMsg IsPartial.
         * @member {boolean} IsPartial
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @instance
         */
        AccountHistoricalSessionRespMsg.prototype.IsPartial = false;

        /**
         * Creates a new AccountHistoricalSessionRespMsg instance using the specified properties.
         * @function create
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountHistoricalSessionRespMsg=} [properties] Properties to set
         * @returns {PropTradingProtocol.AccountHistoricalSessionRespMsg} AccountHistoricalSessionRespMsg instance
         */
        AccountHistoricalSessionRespMsg.create = function create(properties) {
            return new AccountHistoricalSessionRespMsg(properties);
        };

        /**
         * Encodes the specified AccountHistoricalSessionRespMsg message. Does not implicitly {@link PropTradingProtocol.AccountHistoricalSessionRespMsg.verify|verify} messages.
         * @function encode
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountHistoricalSessionRespMsg} message AccountHistoricalSessionRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountHistoricalSessionRespMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RequestId != null && Object.hasOwnProperty.call(message, "RequestId"))
                writer.uint32(/* id 1, wireType 0 =*/8).sint64(message.RequestId);
            if (message.Fills != null && message.Fills.length)
                for (let i = 0; i < message.Fills.length; ++i)
                    $root.PropTradingProtocol.FillReportMsg.encode(message.Fills[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.Trades != null && message.Trades.length)
                for (let i = 0; i < message.Trades.length; ++i)
                    $root.PropTradingProtocol.TradeReportMsg.encode(message.Trades[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.Orders != null && message.Orders.length)
                for (let i = 0; i < message.Orders.length; ++i)
                    $root.PropTradingProtocol.OrderInfoMsg.encode(message.Orders[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.FillTrades != null && message.FillTrades.length)
                for (let i = 0; i < message.FillTrades.length; ++i)
                    $root.PropTradingProtocol.FillTradeReportMsg.encode(message.FillTrades[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.IsPartial != null && Object.hasOwnProperty.call(message, "IsPartial"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.IsPartial);
            return writer;
        };

        /**
         * Encodes the specified AccountHistoricalSessionRespMsg message, length delimited. Does not implicitly {@link PropTradingProtocol.AccountHistoricalSessionRespMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @static
         * @param {PropTradingProtocol.IAccountHistoricalSessionRespMsg} message AccountHistoricalSessionRespMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountHistoricalSessionRespMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountHistoricalSessionRespMsg message from the specified reader or buffer.
         * @function decode
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {PropTradingProtocol.AccountHistoricalSessionRespMsg} AccountHistoricalSessionRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountHistoricalSessionRespMsg.decode = function decode(reader, length, error) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PropTradingProtocol.AccountHistoricalSessionRespMsg();
            while (reader.pos < end) {
                let tag = reader.uint32();
                if (tag === error)
                    break;
                switch (tag >>> 3) {
                case 1: {
                        message.RequestId = reader.sint64();
                        break;
                    }
                case 2: {
                        if (!(message.Fills && message.Fills.length))
                            message.Fills = [];
                        message.Fills.push($root.PropTradingProtocol.FillReportMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.Trades && message.Trades.length))
                            message.Trades = [];
                        message.Trades.push($root.PropTradingProtocol.TradeReportMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.Orders && message.Orders.length))
                            message.Orders = [];
                        message.Orders.push($root.PropTradingProtocol.OrderInfoMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        if (!(message.FillTrades && message.FillTrades.length))
                            message.FillTrades = [];
                        message.FillTrades.push($root.PropTradingProtocol.FillTradeReportMsg.decode(reader, reader.uint32()));
                        break;
                    }
                case 6: {
                        message.IsPartial = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountHistoricalSessionRespMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {PropTradingProtocol.AccountHistoricalSessionRespMsg} AccountHistoricalSessionRespMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountHistoricalSessionRespMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountHistoricalSessionRespMsg message.
         * @function verify
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountHistoricalSessionRespMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (!$util.isInteger(message.RequestId) && !(message.RequestId && $util.isInteger(message.RequestId.low) && $util.isInteger(message.RequestId.high)))
                    return "RequestId: integer|Long expected";
            if (message.Fills != null && message.hasOwnProperty("Fills")) {
                if (!Array.isArray(message.Fills))
                    return "Fills: array expected";
                for (let i = 0; i < message.Fills.length; ++i) {
                    let error = $root.PropTradingProtocol.FillReportMsg.verify(message.Fills[i]);
                    if (error)
                        return "Fills." + error;
                }
            }
            if (message.Trades != null && message.hasOwnProperty("Trades")) {
                if (!Array.isArray(message.Trades))
                    return "Trades: array expected";
                for (let i = 0; i < message.Trades.length; ++i) {
                    let error = $root.PropTradingProtocol.TradeReportMsg.verify(message.Trades[i]);
                    if (error)
                        return "Trades." + error;
                }
            }
            if (message.Orders != null && message.hasOwnProperty("Orders")) {
                if (!Array.isArray(message.Orders))
                    return "Orders: array expected";
                for (let i = 0; i < message.Orders.length; ++i) {
                    let error = $root.PropTradingProtocol.OrderInfoMsg.verify(message.Orders[i]);
                    if (error)
                        return "Orders." + error;
                }
            }
            if (message.FillTrades != null && message.hasOwnProperty("FillTrades")) {
                if (!Array.isArray(message.FillTrades))
                    return "FillTrades: array expected";
                for (let i = 0; i < message.FillTrades.length; ++i) {
                    let error = $root.PropTradingProtocol.FillTradeReportMsg.verify(message.FillTrades[i]);
                    if (error)
                        return "FillTrades." + error;
                }
            }
            if (message.IsPartial != null && message.hasOwnProperty("IsPartial"))
                if (typeof message.IsPartial !== "boolean")
                    return "IsPartial: boolean expected";
            return null;
        };

        /**
         * Creates an AccountHistoricalSessionRespMsg message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {PropTradingProtocol.AccountHistoricalSessionRespMsg} AccountHistoricalSessionRespMsg
         */
        AccountHistoricalSessionRespMsg.fromObject = function fromObject(object) {
            if (object instanceof $root.PropTradingProtocol.AccountHistoricalSessionRespMsg)
                return object;
            let message = new $root.PropTradingProtocol.AccountHistoricalSessionRespMsg();
            if (object.RequestId != null)
                if ($util.Long)
                    (message.RequestId = $util.Long.fromValue(object.RequestId)).unsigned = false;
                else if (typeof object.RequestId === "string")
                    message.RequestId = parseInt(object.RequestId, 10);
                else if (typeof object.RequestId === "number")
                    message.RequestId = object.RequestId;
                else if (typeof object.RequestId === "object")
                    message.RequestId = new $util.LongBits(object.RequestId.low >>> 0, object.RequestId.high >>> 0).toNumber();
            if (object.Fills) {
                if (!Array.isArray(object.Fills))
                    throw TypeError(".PropTradingProtocol.AccountHistoricalSessionRespMsg.Fills: array expected");
                message.Fills = [];
                for (let i = 0; i < object.Fills.length; ++i) {
                    if (typeof object.Fills[i] !== "object")
                        throw TypeError(".PropTradingProtocol.AccountHistoricalSessionRespMsg.Fills: object expected");
                    message.Fills[i] = $root.PropTradingProtocol.FillReportMsg.fromObject(object.Fills[i]);
                }
            }
            if (object.Trades) {
                if (!Array.isArray(object.Trades))
                    throw TypeError(".PropTradingProtocol.AccountHistoricalSessionRespMsg.Trades: array expected");
                message.Trades = [];
                for (let i = 0; i < object.Trades.length; ++i) {
                    if (typeof object.Trades[i] !== "object")
                        throw TypeError(".PropTradingProtocol.AccountHistoricalSessionRespMsg.Trades: object expected");
                    message.Trades[i] = $root.PropTradingProtocol.TradeReportMsg.fromObject(object.Trades[i]);
                }
            }
            if (object.Orders) {
                if (!Array.isArray(object.Orders))
                    throw TypeError(".PropTradingProtocol.AccountHistoricalSessionRespMsg.Orders: array expected");
                message.Orders = [];
                for (let i = 0; i < object.Orders.length; ++i) {
                    if (typeof object.Orders[i] !== "object")
                        throw TypeError(".PropTradingProtocol.AccountHistoricalSessionRespMsg.Orders: object expected");
                    message.Orders[i] = $root.PropTradingProtocol.OrderInfoMsg.fromObject(object.Orders[i]);
                }
            }
            if (object.FillTrades) {
                if (!Array.isArray(object.FillTrades))
                    throw TypeError(".PropTradingProtocol.AccountHistoricalSessionRespMsg.FillTrades: array expected");
                message.FillTrades = [];
                for (let i = 0; i < object.FillTrades.length; ++i) {
                    if (typeof object.FillTrades[i] !== "object")
                        throw TypeError(".PropTradingProtocol.AccountHistoricalSessionRespMsg.FillTrades: object expected");
                    message.FillTrades[i] = $root.PropTradingProtocol.FillTradeReportMsg.fromObject(object.FillTrades[i]);
                }
            }
            if (object.IsPartial != null)
                message.IsPartial = Boolean(object.IsPartial);
            return message;
        };

        /**
         * Creates a plain object from an AccountHistoricalSessionRespMsg message. Also converts values to other types if specified.
         * @function toObject
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @static
         * @param {PropTradingProtocol.AccountHistoricalSessionRespMsg} message AccountHistoricalSessionRespMsg
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AccountHistoricalSessionRespMsg.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.Fills = [];
                object.Trades = [];
                object.Orders = [];
                object.FillTrades = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.RequestId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.RequestId = options.longs === String ? "0" : 0;
                object.IsPartial = false;
            }
            if (message.RequestId != null && message.hasOwnProperty("RequestId"))
                if (typeof message.RequestId === "number")
                    object.RequestId = options.longs === String ? String(message.RequestId) : message.RequestId;
                else
                    object.RequestId = options.longs === String ? $util.Long.prototype.toString.call(message.RequestId) : options.longs === Number ? new $util.LongBits(message.RequestId.low >>> 0, message.RequestId.high >>> 0).toNumber() : message.RequestId;
            if (message.Fills && message.Fills.length) {
                object.Fills = [];
                for (let j = 0; j < message.Fills.length; ++j)
                    object.Fills[j] = $root.PropTradingProtocol.FillReportMsg.toObject(message.Fills[j], options);
            }
            if (message.Trades && message.Trades.length) {
                object.Trades = [];
                for (let j = 0; j < message.Trades.length; ++j)
                    object.Trades[j] = $root.PropTradingProtocol.TradeReportMsg.toObject(message.Trades[j], options);
            }
            if (message.Orders && message.Orders.length) {
                object.Orders = [];
                for (let j = 0; j < message.Orders.length; ++j)
                    object.Orders[j] = $root.PropTradingProtocol.OrderInfoMsg.toObject(message.Orders[j], options);
            }
            if (message.FillTrades && message.FillTrades.length) {
                object.FillTrades = [];
                for (let j = 0; j < message.FillTrades.length; ++j)
                    object.FillTrades[j] = $root.PropTradingProtocol.FillTradeReportMsg.toObject(message.FillTrades[j], options);
            }
            if (message.IsPartial != null && message.hasOwnProperty("IsPartial"))
                object.IsPartial = message.IsPartial;
            return object;
        };

        /**
         * Converts this AccountHistoricalSessionRespMsg to JSON.
         * @function toJSON
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AccountHistoricalSessionRespMsg.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AccountHistoricalSessionRespMsg
         * @function getTypeUrl
         * @memberof PropTradingProtocol.AccountHistoricalSessionRespMsg
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AccountHistoricalSessionRespMsg.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/PropTradingProtocol.AccountHistoricalSessionRespMsg";
        };

        return AccountHistoricalSessionRespMsg;
    })();

    return PropTradingProtocol;
})();

export { $root as default };
